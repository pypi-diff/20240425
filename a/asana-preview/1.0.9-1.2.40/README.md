# Comparing `tmp/asana_preview-1.0.9.tar.gz` & `tmp/asana_preview-1.2.40.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "/home/runner/work/python-asana-preview/python-asana-preview/dist/.tmp-3rbong4k/asana_preview-1.0.9.tar", last modified: Fri Jul 14 19:22:29 2023, max compression
+gzip compressed data, was "/home/runner/work/python-asana-preview/python-asana-preview/dist/.tmp-53gp92kn/asana_preview-1.2.40.tar", last modified: Thu Mar 14 22:30:30 2024, max compression
```

## Comparing `asana_preview-1.0.9.tar` & `asana_preview-1.2.40.tar`

### file list

```diff
@@ -1,918 +1,94 @@
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-14 19:22:29.000000 asana_preview-1.0.9/
--rw-r--r--   0 runner    (1001) docker     (123)    59579 2023-07-14 19:22:29.000000 asana_preview-1.0.9/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    59356 2023-07-14 19:22:15.000000 asana_preview-1.0.9/README.md
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-14 19:22:29.000000 asana_preview-1.0.9/asana_preview/
--rw-r--r--   0 runner    (1001) docker     (123)    36222 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-14 19:22:29.000000 asana_preview-1.0.9/asana_preview/api/
--rw-r--r--   0 runner    (1001) docker     (123)     2194 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)    23646 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/attachments_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    12527 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/audit_log_api_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     5560 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/batch_api_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    13741 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/custom_field_settings_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    45245 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/custom_fields_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     7763 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/events_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    27360 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/goal_relationships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    52947 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/goals_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     5240 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/jobs_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    18699 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/memberships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    11993 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/organization_exports_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    18543 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/portfolio_memberships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    63752 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/portfolios_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    20933 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/project_briefs_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    12066 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/project_memberships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    21913 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/project_statuses_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    28293 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/project_templates_api.py
--rw-r--r--   0 runner    (1001) docker     (123)   107816 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/projects_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     5848 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/rules_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    35837 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/sections_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    21760 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/status_updates_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    27300 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/stories_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    45876 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/tags_api.py
--rw-r--r--   0 runner    (1001) docker     (123)   163541 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/tasks_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    24353 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/team_memberships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    40712 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/teams_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    11681 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/time_periods_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    28130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/time_tracking_entries_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    11675 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/typeahead_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    10977 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/user_task_lists_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    28905 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/users_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    29484 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/webhooks_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    18371 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/workspace_memberships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    27463 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api/workspaces_api.py
--rw-r--r--   0 runner    (1001) docker     (123)    25183 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/api_client.py
--rw-r--r--   0 runner    (1001) docker     (123)     8415 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/configuration.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-14 19:22:29.000000 asana_preview-1.0.9/asana_preview/models/
--rw-r--r--   0 runner    (1001) docker     (123)    33965 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     7217 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/add_custom_field_setting_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3642 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/add_followers_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3584 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/add_members_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2611 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_project_response_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2627 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_project_template_base_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2643 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_project_template_response_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2631 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_story_response_new_date_value.py
--rw-r--r--   0 runner    (1001) docker     (123)     2631 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_story_response_old_date_value.py
--rw-r--r--   0 runner    (1001) docker     (123)     2639 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_task_response_assignee_section.py
--rw-r--r--   0 runner    (1001) docker     (123)     2615 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_user_task_list_base_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2631 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_user_task_list_base_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     2627 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_user_task_list_compact_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2643 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_user_task_list_compact_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     2627 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_user_task_list_request_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2643 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_user_task_list_request_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     2631 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_user_task_list_response_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2647 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_user_task_list_response_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     2707 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_workspace_membership_response_user_task_list_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     2723 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/all_of_workspace_membership_response_user_task_list_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     4902 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/asana_named_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)     3285 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/asana_named_resource_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     4149 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/asana_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)     5957 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/attachment_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     6017 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/attachment_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     8912 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/attachment_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    14064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/attachment_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3285 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/attachment_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3259 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/attachment_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     6047 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/attachment_response_parent.py
--rw-r--r--   0 runner    (1001) docker     (123)     8729 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/audit_log_event.py
--rw-r--r--   0 runner    (1001) docker     (123)     6120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/audit_log_event_actor.py
--rw-r--r--   0 runner    (1001) docker     (123)     3230 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/audit_log_event_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     8838 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/audit_log_event_context.py
--rw-r--r--   0 runner    (1001) docker     (123)     2591 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/audit_log_event_details.py
--rw-r--r--   0 runner    (1001) docker     (123)     6696 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/audit_log_event_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)     3137 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/batch_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3260 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/batch_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     6926 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/batch_request_action.py
--rw-r--r--   0 runner    (1001) docker     (123)     6946 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/batch_request_actions.py
--rw-r--r--   0 runner    (1001) docker     (123)     4866 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/batch_request_options.py
--rw-r--r--   0 runner    (1001) docker     (123)     5268 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/batch_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3230 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/batch_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     5019 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/create_membership_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     4670 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/create_time_tracking_entry_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    30420 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     4412 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_base_date_value.py
--rw-r--r--   0 runner    (1001) docker     (123)     6735 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_base_enum_options.py
--rw-r--r--   0 runner    (1001) docker     (123)     6687 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_base_enum_value.py
--rw-r--r--   0 runner    (1001) docker     (123)    16739 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     3312 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_gid_enum_options_body.py
--rw-r--r--   0 runner    (1001) docker     (123)    34312 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    33924 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3296 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     5148 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_response_created_by.py
--rw-r--r--   0 runner    (1001) docker     (123)     3270 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     5180 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_response_people_value.py
--rw-r--r--   0 runner    (1001) docker     (123)     4257 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_setting_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     4293 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_setting_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     7879 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_setting_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3373 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_setting_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)    35868 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_setting_response_custom_field.py
--rw-r--r--   0 runner    (1001) docker     (123)     3347 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_setting_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     5372 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_setting_response_parent.py
--rw-r--r--   0 runner    (1001) docker     (123)     5388 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_field_setting_response_project.py
--rw-r--r--   0 runner    (1001) docker     (123)     3211 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_fields_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3323 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/custom_fields_custom_field_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     5204 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/date_variable_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     4482 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/date_variable_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2563 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/empty_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3204 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/empty_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     6351 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/enum_option.py
--rw-r--r--   0 runner    (1001) docker     (123)     6447 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/enum_option_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     3171 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/enum_option_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     6062 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/enum_option_insert_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     8757 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/enum_option_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3295 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/enum_options_enum_option_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3266 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/enum_options_insert_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     5108 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/error.py
--rw-r--r--   0 runner    (1001) docker     (123)     3248 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/error_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     5332 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/error_response_errors.py
--rw-r--r--   0 runner    (1001) docker     (123)     7955 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/event_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3230 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/event_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     9221 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/event_response_change.py
--rw-r--r--   0 runner    (1001) docker     (123)     4918 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/event_response_parent.py
--rw-r--r--   0 runner    (1001) docker     (123)     4950 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/event_response_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)     4972 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/event_response_user.py
--rw-r--r--   0 runner    (1001) docker     (123)     5836 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_add_subgoal_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     7923 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_add_supporting_relationship_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3746 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_add_supporting_work_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    10472 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     5454 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     3282 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_gid_add_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3425 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_gid_add_supporting_relationship_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3306 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_gid_remove_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3458 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_gid_remove_supporting_relationship_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3240 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_gid_set_metric_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3372 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_gid_set_metric_current_value_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     7332 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_membership_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     5674 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_membership_base_goal.py
--rw-r--r--   0 runner    (1001) docker     (123)     7416 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_membership_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     7444 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)    15542 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_metric_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     5518 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_metric_current_value_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    15686 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_metric_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     8932 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_relationship_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     5894 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_relationship_base_supported_goal.py
--rw-r--r--   0 runner    (1001) docker     (123)     5468 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_relationship_base_supporting_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)     8105 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_relationship_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     9016 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_relationship_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     9044 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_relationship_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3351 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_relationship_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3325 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_relationship_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3418 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_relationships_goal_relationship_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3530 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_remove_subgoal_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     4026 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_remove_supporting_relationship_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    14351 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    13884 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_request_base.py
--rw-r--r--   0 runner    (1001) docker     (123)    18927 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3219 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     6979 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_response_current_status_update.py
--rw-r--r--   0 runner    (1001) docker     (123)     3193 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3986 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_response_likes.py
--rw-r--r--   0 runner    (1001) docker     (123)    17038 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_response_metric.py
--rw-r--r--   0 runner    (1001) docker     (123)     4866 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_response_team.py
--rw-r--r--   0 runner    (1001) docker     (123)     8125 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_response_time_period.py
--rw-r--r--   0 runner    (1001) docker     (123)     4956 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_response_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)    15329 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goal_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3134 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goals_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3208 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/goals_goal_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     4069 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/inline_response412.py
--rw-r--r--   0 runner    (1001) docker     (123)     3476 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/inline_response412_errors.py
--rw-r--r--   0 runner    (1001) docker     (123)     8812 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/job_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     5132 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/job_base_new_project.py
--rw-r--r--   0 runner    (1001) docker     (123)     5026 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/job_base_new_project_template.py
--rw-r--r--   0 runner    (1001) docker     (123)     6673 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/job_base_new_task.py
--rw-r--r--   0 runner    (1001) docker     (123)     8908 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/job_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     8940 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/job_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3182 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/job_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3830 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/like.py
--rw-r--r--   0 runner    (1001) docker     (123)     4832 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/member_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     3461 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/membership_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2583 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3285 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/membership_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3259 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/membership_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3218 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/memberships_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3304 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/memberships_membership_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3182 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/message_base_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3552 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/modify_dependencies_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3526 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/modify_dependents_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     8622 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/organization_export_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     8706 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/organization_export_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     3566 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/organization_export_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     8734 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/organization_export_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3347 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/organization_export_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3288 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/organization_exports_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     5749 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_add_item_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     6039 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     4876 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     3409 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_gid_add_custom_field_setting_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3282 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_gid_add_item_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3288 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_gid_add_members_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3442 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_gid_remove_custom_field_setting_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3315 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_gid_remove_item_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3321 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_gid_remove_members_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     5779 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_membership_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     5132 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_membership_base_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (123)     5839 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_membership_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     5859 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3384 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_membership_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3358 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_membership_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3451 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_remove_item_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     8603 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    18230 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3274 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     7079 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_response_current_status_update.py
--rw-r--r--   0 runner    (1001) docker     (123)     8159 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_response_custom_field_settings.py
--rw-r--r--   0 runner    (1001) docker     (123)    17399 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_response_custom_fields.py
--rw-r--r--   0 runner    (1001) docker     (123)     3248 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     5036 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolio_response_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     3189 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolios_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3285 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/portfolios_portfolio_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     8493 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/preview.py
--rw-r--r--   0 runner    (1001) docker     (123)    20495 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_base.py
--rw-r--r--   0 runner    (1001) docker     (123)    11697 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_base_current_status.py
--rw-r--r--   0 runner    (1001) docker     (123)     6959 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_base_current_status_update.py
--rw-r--r--   0 runner    (1001) docker     (123)     4940 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_base_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     5729 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_brief_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     4221 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_brief_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     6722 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_brief_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     8294 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_brief_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3281 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_brief_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     5292 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_brief_response_project.py
--rw-r--r--   0 runner    (1001) docker     (123)     3342 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_briefs_project_brief_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     5084 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     6547 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_duplicate_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     6158 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_duplicate_request_schedule_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     3393 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_gid_add_custom_field_setting_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3294 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_gid_add_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3272 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_gid_add_members_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3282 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_gid_duplicate_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3302 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_gid_project_briefs_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3321 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_gid_project_statuses_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3426 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_gid_remove_custom_field_setting_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3327 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_gid_remove_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3305 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_gid_remove_members_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3337 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_gid_save_as_template_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3247 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_gid_sections_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     4939 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_membership_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     4987 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_membership_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     7796 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3362 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_membership_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3336 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_membership_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     5120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_membership_response_member.py
--rw-r--r--   0 runner    (1001) docker     (123)    24286 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    31095 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3252 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     5116 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_response_completed_by.py
--rw-r--r--   0 runner    (1001) docker     (123)     5170 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_response_created_from_template.py
--rw-r--r--   0 runner    (1001) docker     (123)     3226 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     4317 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_response_project_brief.py
--rw-r--r--   0 runner    (1001) docker     (123)     4914 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_response_team.py
--rw-r--r--   0 runner    (1001) docker     (123)     6298 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_save_as_template_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     5572 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_section_insert_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     7805 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_status_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     4986 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_status_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     7889 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_status_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    11565 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_status_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3318 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_status_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3292 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_status_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)    12987 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     5428 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_base_requested_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     5148 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_base_requested_roles.py
--rw-r--r--   0 runner    (1001) docker     (123)     4978 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_base_team.py
--rw-r--r--   0 runner    (1001) docker     (123)     4978 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     3469 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_gid_instantiate_project_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     9448 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_instantiate_project_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     4902 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_instantiate_project_request_requested_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     4565 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_instantiate_project_request_requested_roles.py
--rw-r--r--   0 runner    (1001) docker     (123)    13191 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3340 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3314 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/project_template_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3167 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/projects_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3247 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/projects_project_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3677 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/remove_custom_field_setting_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3666 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/remove_followers_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3608 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/remove_members_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     4157 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/requested_role_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3251 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/rule_trigger_gid_run_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     4898 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/rule_trigger_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3388 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/rule_trigger_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3270 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/rule_trigger_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     4888 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/section_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     4936 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/section_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     3269 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/section_gid_add_task_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     5583 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/section_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     7358 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/section_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3252 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/section_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3226 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/section_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     5629 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/section_task_insert_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3254 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/sections_insert_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3247 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/sections_section_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     9879 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/status_update_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     6739 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/status_update_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)    10929 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/status_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    19665 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/status_update_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3307 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/status_update_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3281 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/status_update_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     5276 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/status_update_response_parent.py
--rw-r--r--   0 runner    (1001) docker     (123)     3222 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/status_updates_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3217 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/stories_story_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)    10110 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     8529 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)    10218 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    48927 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3230 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     5036 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_assignee.py
--rw-r--r--   0 runner    (1001) docker     (123)    17099 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_custom_field.py
--rw-r--r--   0 runner    (1001) docker     (123)     3204 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     5599 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     5647 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_old_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     6711 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_old_enum_value.py
--rw-r--r--   0 runner    (1001) docker     (123)     5080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_old_section.py
--rw-r--r--   0 runner    (1001) docker     (123)     8997 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_previews.py
--rw-r--r--   0 runner    (1001) docker     (123)     5180 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_project.py
--rw-r--r--   0 runner    (1001) docker     (123)     8697 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_story.py
--rw-r--r--   0 runner    (1001) docker     (123)     5108 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_tag.py
--rw-r--r--   0 runner    (1001) docker     (123)     6773 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_target.py
--rw-r--r--   0 runner    (1001) docker     (123)     6733 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/story_response_task.py
--rw-r--r--   0 runner    (1001) docker     (123)     6920 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/tag_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     5012 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/tag_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     8692 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/tag_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    10378 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/tag_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3208 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/tag_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3182 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/tag_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3123 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/tags_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3692 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_add_followers_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     6425 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_add_project_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3336 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_add_tag_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    35097 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     5004 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_base_completed_by.py
--rw-r--r--   0 runner    (1001) docker     (123)     4233 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_base_dependencies.py
--rw-r--r--   0 runner    (1001) docker     (123)     3739 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_base_external.py
--rw-r--r--   0 runner    (1001) docker     (123)     3993 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_base_memberships.py
--rw-r--r--   0 runner    (1001) docker     (123)     4952 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_base_section.py
--rw-r--r--   0 runner    (1001) docker     (123)     6613 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     8685 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_count_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3248 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_count_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     4393 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_duplicate_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3312 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_add_dependencies_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3290 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_add_dependents_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3282 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_add_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3260 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_add_project_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3216 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_add_tag_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3249 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_duplicate_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3336 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_remove_dependencies_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3314 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_remove_dependents_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3315 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_remove_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3293 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_remove_project_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3249 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_remove_tag_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3249 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_set_parent_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3209 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_stories_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3214 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_subtasks_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3359 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_gid_time_tracking_entries_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3716 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_remove_followers_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3494 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_remove_project_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3370 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_remove_tag_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    43510 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    44580 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3219 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)    34464 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_response_custom_fields.py
--rw-r--r--   0 runner    (1001) docker     (123)     3193 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     6753 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_response_parent.py
--rw-r--r--   0 runner    (1001) docker     (123)     5108 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_response_tags.py
--rw-r--r--   0 runner    (1001) docker     (123)     4956 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_response_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     5509 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/task_set_parent_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3134 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/tasks_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3190 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/tasks_task_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3424 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_add_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     4738 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     4786 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     3227 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_gid_add_user_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3223 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_gid_projects_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3260 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_gid_remove_user_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     8194 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_membership_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     8290 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_membership_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     8322 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3329 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_membership_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3303 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_membership_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3448 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_remove_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    19673 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    20553 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3219 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3193 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     5004 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/team_response_organization.py
--rw-r--r--   0 runner    (1001) docker     (123)     3134 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/teams_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3142 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/teams_body1.py
--rw-r--r--   0 runner    (1001) docker     (123)     4812 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/template_role.py
--rw-r--r--   0 runner    (1001) docker     (123)     8583 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/time_period_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     7985 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/time_period_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     8711 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/time_period_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3285 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/time_period_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3259 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/time_period_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3463 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/time_tracking_entries_time_tracking_entry_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     8398 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/time_tracking_entry_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     3292 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/time_tracking_entry_base_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     6933 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/time_tracking_entry_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     3351 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/time_tracking_entry_compact_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     4652 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/update_time_tracking_entry_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     4828 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     6332 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_base_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3237 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_base_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     7231 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_base_response_photo.py
--rw-r--r--   0 runner    (1001) docker     (123)     4876 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     4876 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     7359 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3219 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3193 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     6732 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_task_list_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     6822 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_task_list_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     6822 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_task_list_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     6852 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_task_list_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3281 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/user_task_list_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     6502 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/webhook_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     4966 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/webhook_compact_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)     7289 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/webhook_filter.py
--rw-r--r--   0 runner    (1001) docker     (123)     6008 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/webhook_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     7449 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/webhook_request_filters.py
--rw-r--r--   0 runner    (1001) docker     (123)    11774 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/webhook_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3252 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/webhook_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3226 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/webhook_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3848 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/webhook_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     3167 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/webhooks_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3265 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/webhooks_webhook_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3464 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_add_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     4828 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     4876 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     3282 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_gid_add_user_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3263 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_gid_projects_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3315 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_gid_remove_user_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     3222 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_gid_tags_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     5746 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_membership_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     5806 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_membership_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     5806 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_membership_request.py
--rw-r--r--   0 runner    (1001) docker     (123)    11253 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3384 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_membership_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3358 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_membership_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     7422 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_membership_response_user_task_list.py
--rw-r--r--   0 runner    (1001) docker     (123)     4733 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_membership_response_vacation_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     3488 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_remove_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     4876 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     6801 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     3274 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     3248 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspace_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     3285 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/models/workspaces_workspace_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)    13139 2023-07-14 19:22:15.000000 asana_preview-1.0.9/asana_preview/rest.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-14 19:22:29.000000 asana_preview-1.0.9/asana_preview.egg-info/
--rw-r--r--   0 runner    (1001) docker     (123)    59579 2023-07-14 19:22:29.000000 asana_preview-1.0.9/asana_preview.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (123)    39003 2023-07-14 19:22:29.000000 asana_preview-1.0.9/asana_preview.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (123)        1 2023-07-14 19:22:29.000000 asana_preview-1.0.9/asana_preview.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (123)       64 2023-07-14 19:22:29.000000 asana_preview-1.0.9/asana_preview.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (123)       19 2023-07-14 19:22:29.000000 asana_preview-1.0.9/asana_preview.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (123)       38 2023-07-14 19:22:29.000000 asana_preview-1.0.9/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (123)     1250 2023-07-14 19:22:15.000000 asana_preview-1.0.9/setup.py
-drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-07-14 19:22:29.000000 asana_preview-1.0.9/test/
--rw-r--r--   0 runner    (1001) docker     (123)       15 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/__init__.py
--rw-r--r--   0 runner    (1001) docker     (123)     1164 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_add_custom_field_setting_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_add_followers_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_add_members_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1140 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_project_response_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1174 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_project_template_base_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1206 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_project_template_response_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1184 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_story_response_new_date_value.py
--rw-r--r--   0 runner    (1001) docker     (123)     1184 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_story_response_old_date_value.py
--rw-r--r--   0 runner    (1001) docker     (123)     1198 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_task_response_assignee_section.py
--rw-r--r--   0 runner    (1001) docker     (123)     1152 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_user_task_list_base_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1184 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_user_task_list_base_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     1176 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_user_task_list_compact_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1208 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_user_task_list_compact_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     1176 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_user_task_list_request_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1208 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_user_task_list_request_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     1184 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_user_task_list_response_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1216 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_user_task_list_response_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     1340 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_workspace_membership_response_user_task_list_owner.py
--rw-r--r--   0 runner    (1001) docker     (123)     1372 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_all_of_workspace_membership_response_user_task_list_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_asana_named_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_asana_named_resource_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_asana_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_attachment_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1070 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_attachment_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1070 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_attachment_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_attachment_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_attachment_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_attachment_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1128 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_attachment_response_parent.py
--rw-r--r--   0 runner    (1001) docker     (123)     1477 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_attachments_api.py
--rw-r--r--   0 runner    (1001) docker     (123)      991 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_audit_log_api_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1040 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_audit_log_event.py
--rw-r--r--   0 runner    (1001) docker     (123)     1082 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_audit_log_event_actor.py
--rw-r--r--   0 runner    (1001) docker     (123)     1082 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_audit_log_event_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1098 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_audit_log_event_context.py
--rw-r--r--   0 runner    (1001) docker     (123)     1098 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_audit_log_event_details.py
--rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_audit_log_event_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)      979 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_batch_api_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_batch_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_batch_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_batch_request_action.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_batch_request_actions.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_batch_request_options.py
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_batch_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_batch_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_create_membership_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1180 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_create_time_tracking_entry_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1056 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1132 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_base_date_value.py
--rw-r--r--   0 runner    (1001) docker     (123)     1148 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_base_enum_options.py
--rw-r--r--   0 runner    (1001) docker     (123)     1132 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_base_enum_value.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1174 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_gid_enum_options_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1164 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_response_created_by.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1180 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_response_people_value.py
--rw-r--r--   0 runner    (1001) docker     (123)     1114 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_setting_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1138 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_setting_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1146 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_setting_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1188 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_setting_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1238 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_setting_response_custom_field.py
--rw-r--r--   0 runner    (1001) docker     (123)     1180 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_setting_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1196 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_setting_response_parent.py
--rw-r--r--   0 runner    (1001) docker     (123)     1204 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_setting_response_project.py
--rw-r--r--   0 runner    (1001) docker     (123)     1280 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_field_settings_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     2181 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_fields_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_fields_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1182 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_custom_fields_custom_field_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_date_variable_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_date_variable_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_empty_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_empty_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1014 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_enum_option.py
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_enum_option_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_enum_option_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_enum_option_insert_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_enum_option_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_enum_options_enum_option_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_enum_options_insert_body.py
--rw-r--r--   0 runner    (1001) docker     (123)      972 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_error.py
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_error_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_error_response_errors.py
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_event_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_event_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_event_response_change.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_event_response_parent.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_event_response_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_event_response_user.py
--rw-r--r--   0 runner    (1001) docker     (123)      948 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_events_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_add_subgoal_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1228 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_add_supporting_relationship_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1164 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_add_supporting_work_request.py
--rw-r--r--   0 runner    (1001) docker     (123)      998 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1124 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_gid_add_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1230 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_gid_add_supporting_relationship_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1148 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_gid_remove_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1254 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_gid_remove_supporting_relationship_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1100 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_gid_set_metric_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1200 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_gid_set_metric_current_value_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_membership_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1114 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_membership_base_goal.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_membership_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_metric_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1172 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_metric_current_value_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_metric_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_relationship_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1204 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_relationship_base_supported_goal.py
--rw-r--r--   0 runner    (1001) docker     (123)     1244 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_relationship_base_supporting_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_relationship_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_relationship_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1128 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_relationship_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1170 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_relationship_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1162 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_relationship_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1739 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_relationships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1262 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_relationships_goal_relationship_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_remove_subgoal_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1252 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_remove_supporting_relationship_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1056 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_request_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1188 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_response_current_status_update.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_response_likes.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_response_metric.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_response_team.py
--rw-r--r--   0 runner    (1001) docker     (123)     1114 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_response_time_period.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_response_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goal_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     2239 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goals_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goals_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_goals_goal_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1070 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_inline_response412.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_inline_response412_errors.py
--rw-r--r--   0 runner    (1001) docker     (123)      990 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_job_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1074 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_job_base_new_project.py
--rw-r--r--   0 runner    (1001) docker     (123)     1140 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_job_base_new_project_template.py
--rw-r--r--   0 runner    (1001) docker     (123)     1050 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_job_base_new_task.py
--rw-r--r--   0 runner    (1001) docker     (123)     1014 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_job_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_job_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1056 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_job_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)      923 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_jobs_api.py
--rw-r--r--   0 runner    (1001) docker     (123)      964 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_like.py
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_member_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1070 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_membership_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1078 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_membership_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_membership_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1433 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_memberships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_memberships_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1162 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_memberships_membership_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1056 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_message_base_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1136 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_modify_dependencies_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_modify_dependents_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_organization_export_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1136 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_organization_export_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1136 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_organization_export_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1144 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_organization_export_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1178 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_organization_export_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1238 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_organization_exports_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_organization_exports_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_add_item_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1062 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1240 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_gid_add_custom_field_setting_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1124 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_gid_add_item_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1148 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_gid_add_members_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1264 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_gid_remove_custom_field_setting_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1148 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_gid_remove_item_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1172 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_gid_remove_members_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_membership_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1194 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_membership_base_portfolio.py
--rw-r--r--   0 runner    (1001) docker     (123)     1144 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_membership_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1152 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1194 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_membership_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1186 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_membership_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1437 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_memberships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1146 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_remove_item_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1062 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1070 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1228 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_response_current_status_update.py
--rw-r--r--   0 runner    (1001) docker     (123)     1228 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_response_custom_field_settings.py
--rw-r--r--   0 runner    (1001) docker     (123)     1170 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_response_custom_fields.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1144 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolio_response_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     2823 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolios_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolios_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1146 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_portfolios_portfolio_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)      988 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_preview.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_base_current_status.py
--rw-r--r--   0 runner    (1001) docker     (123)     1180 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_base_current_status_update.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_base_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_brief_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_brief_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_brief_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_brief_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_brief_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1154 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_brief_response_project.py
--rw-r--r--   0 runner    (1001) docker     (123)     1470 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_briefs_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1198 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_briefs_project_brief_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_duplicate_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1228 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_duplicate_request_schedule_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     1224 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_gid_add_custom_field_setting_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1148 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_gid_add_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1132 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_gid_add_members_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_gid_duplicate_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1156 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_gid_project_briefs_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1172 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_gid_project_statuses_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1248 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_gid_remove_custom_field_setting_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1172 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_gid_remove_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1156 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_gid_remove_members_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1166 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_gid_save_as_template_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1114 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_gid_sections_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_membership_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1128 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_membership_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1136 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1178 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_membership_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1170 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_membership_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1186 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_membership_response_member.py
--rw-r--r--   0 runner    (1001) docker     (123)     1230 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_memberships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1146 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_response_completed_by.py
--rw-r--r--   0 runner    (1001) docker     (123)     1212 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_response_created_from_template.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1154 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_response_project_brief.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_response_team.py
--rw-r--r--   0 runner    (1001) docker     (123)     1164 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_save_as_template_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1154 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_section_insert_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_status_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_status_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_status_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_status_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1146 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_status_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1138 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_status_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1542 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_statuses_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1204 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_base_requested_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     1204 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_base_requested_roles.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_base_team.py
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1262 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_gid_instantiate_project_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1260 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_instantiate_project_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1376 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_instantiate_project_request_requested_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     1376 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_instantiate_project_request_requested_roles.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1162 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1154 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_template_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1721 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_project_templates_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     3993 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_projects_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_projects_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1114 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_projects_project_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1188 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_remove_custom_field_setting_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_remove_followers_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_remove_members_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_requested_role_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1108 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_rule_trigger_gid_run_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_rule_trigger_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_rule_trigger_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_rule_trigger_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)      937 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_rules_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_section_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_section_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1108 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_section_gid_add_task_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_section_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_section_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_section_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_section_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_section_task_insert_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1907 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_sections_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_sections_insert_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1114 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_sections_section_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_status_update_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_status_update_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_status_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_status_update_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1138 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_status_update_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_status_update_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1146 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_status_update_response_parent.py
--rw-r--r--   0 runner    (1001) docker     (123)     1467 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_status_updates_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_status_updates_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1531 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_stories_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_stories_story_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_assignee.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_custom_field.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_old_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     1140 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_old_enum_value.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_old_section.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_previews.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_project.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_story.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_tag.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_target.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_story_response_task.py
--rw-r--r--   0 runner    (1001) docker     (123)      990 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_tag_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1014 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_tag_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1014 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_tag_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_tag_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_tag_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1056 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_tag_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1918 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_tags_api.py
--rw-r--r--   0 runner    (1001) docker     (123)      998 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_tags_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_add_followers_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_add_project_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1074 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_add_tag_request.py
--rw-r--r--   0 runner    (1001) docker     (123)      998 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_base_completed_by.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_base_dependencies.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_base_external.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_base_memberships.py
--rw-r--r--   0 runner    (1001) docker     (123)     1056 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_base_section.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_count_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_count_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_duplicate_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1148 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_add_dependencies_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1132 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_add_dependents_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1124 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_add_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1108 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_add_project_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1076 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_add_tag_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1098 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_duplicate_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1172 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_remove_dependencies_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1156 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_remove_dependents_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1148 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_remove_followers_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1132 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_remove_project_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1100 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_remove_tag_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1100 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_set_parent_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1082 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_stories_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_subtasks_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1182 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_gid_time_tracking_entries_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1146 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_remove_followers_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_remove_project_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1098 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_remove_tag_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_response_custom_fields.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_response_parent.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_response_tags.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_response_workspace.py
--rw-r--r--   0 runner    (1001) docker     (123)     1098 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_task_set_parent_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     4936 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_tasks_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_tasks_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_tasks_task_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1082 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_add_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)      998 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1084 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_gid_add_user_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_gid_projects_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1108 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_gid_remove_user_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_membership_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_membership_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1154 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_membership_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1146 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_membership_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1530 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_memberships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_remove_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1128 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_team_response_organization.py
--rw-r--r--   0 runner    (1001) docker     (123)     1822 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_teams_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1006 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_teams_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1014 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_teams_body1.py
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_template_role.py
--rw-r--r--   0 runner    (1001) docker     (123)     1048 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_period_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_period_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1080 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_period_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_period_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1114 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_period_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_periods_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1774 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_tracking_entries_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1290 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_tracking_entries_time_tracking_entry_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_tracking_entry_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1140 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_tracking_entry_base_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_tracking_entry_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1172 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_time_tracking_entry_compact_array.py
--rw-r--r--   0 runner    (1001) docker     (123)      990 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_typeahead_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1180 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_update_time_tracking_entry_request.py
--rw-r--r--   0 runner    (1001) docker     (123)      998 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_base_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1098 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_base_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1106 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_base_response_photo.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1022 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1072 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1064 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1066 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_task_list_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_task_list_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1090 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_task_list_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1098 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_task_list_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1132 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_task_list_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1170 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_user_task_lists_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1556 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_users_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhook_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhook_compact_resource.py
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhook_filter.py
--rw-r--r--   0 runner    (1001) docker     (123)     1046 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhook_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhook_request_filters.py
--rw-r--r--   0 runner    (1001) docker     (123)     1054 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhook_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhook_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1088 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhook_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1096 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhook_update_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1517 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhooks_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1030 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhooks_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1114 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_webhooks_webhook_gid_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_add_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1038 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1062 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1124 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_gid_add_user_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1130 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_gid_projects_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1148 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_gid_remove_user_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1098 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_gid_tags_body.py
--rw-r--r--   0 runner    (1001) docker     (123)     1120 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_membership_base.py
--rw-r--r--   0 runner    (1001) docker     (123)     1144 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_membership_compact.py
--rw-r--r--   0 runner    (1001) docker     (123)     1144 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_membership_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1152 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_membership_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1194 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_membership_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1186 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_membership_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1254 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_membership_response_user_task_list.py
--rw-r--r--   0 runner    (1001) docker     (123)     1260 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_membership_response_vacation_dates.py
--rw-r--r--   0 runner    (1001) docker     (123)     1470 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_memberships_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1146 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_remove_user_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1062 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_request.py
--rw-r--r--   0 runner    (1001) docker     (123)     1070 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_response.py
--rw-r--r--   0 runner    (1001) docker     (123)     1112 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_response_array.py
--rw-r--r--   0 runner    (1001) docker     (123)     1104 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspace_response_data.py
--rw-r--r--   0 runner    (1001) docker     (123)     1635 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspaces_api.py
--rw-r--r--   0 runner    (1001) docker     (123)     1146 2023-07-14 19:22:15.000000 asana_preview-1.0.9/test/test_workspaces_workspace_gid_body.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-14 22:30:30.000000 asana_preview-1.2.40/
+-rw-r--r--   0 runner    (1001) docker     (127)    62567 2024-03-14 22:30:30.000000 asana_preview-1.2.40/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)    62343 2024-03-14 22:30:24.000000 asana_preview-1.2.40/README.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-14 22:30:30.000000 asana_preview-1.2.40/asana_preview/
+-rw-r--r--   0 runner    (1001) docker     (127)     2768 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-14 22:30:30.000000 asana_preview-1.2.40/asana_preview/api/
+-rw-r--r--   0 runner    (1001) docker     (127)     2260 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32281 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/attachments_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13907 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/audit_log_api_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7664 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/batch_api_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17521 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/custom_field_settings_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    59868 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/custom_fields_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9776 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/events_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    37180 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/goal_relationships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    70113 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/goals_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7171 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/jobs_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27446 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/memberships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14439 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/organization_exports_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23725 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/portfolio_memberships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    84994 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/portfolios_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28106 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/project_briefs_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15721 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/project_memberships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29290 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/project_statuses_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    37382 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/project_templates_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)   139888 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/projects_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7776 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/rules_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    48811 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/sections_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28798 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/status_updates_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    35078 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/stories_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    56653 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/tags_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28007 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/task_templates_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)   209273 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/tasks_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    31327 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/team_memberships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    49908 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/teams_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15124 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/time_periods_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    37131 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/time_tracking_entries_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13391 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/typeahead_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14597 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/user_task_lists_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    39070 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/users_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    38391 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/webhooks_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23841 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/workspace_memberships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    36376 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api/workspaces_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25276 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/api_client.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8750 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/configuration.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-14 22:30:30.000000 asana_preview-1.2.40/asana_preview/pagination/
+-rw-r--r--   0 runner    (1001) docker     (127)      618 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/pagination/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1123 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/pagination/event_iterator.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2426 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/pagination/page_iterator.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13136 2024-03-14 22:30:24.000000 asana_preview-1.2.40/asana_preview/rest.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-14 22:30:30.000000 asana_preview-1.2.40/asana_preview.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)    62567 2024-03-14 22:30:30.000000 asana_preview-1.2.40/asana_preview.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     2848 2024-03-14 22:30:30.000000 asana_preview-1.2.40/asana_preview.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-03-14 22:30:30.000000 asana_preview-1.2.40/asana_preview.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       64 2024-03-14 22:30:30.000000 asana_preview-1.2.40/asana_preview.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       19 2024-03-14 22:30:30.000000 asana_preview-1.2.40/asana_preview.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       38 2024-03-14 22:30:30.000000 asana_preview-1.2.40/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (127)     1251 2024-03-14 22:30:24.000000 asana_preview-1.2.40/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-03-14 22:30:30.000000 asana_preview-1.2.40/test/
+-rw-r--r--   0 runner    (1001) docker     (127)       15 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1477 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_attachments_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)      991 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_audit_log_api_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)      979 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_batch_api_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1280 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_custom_field_settings_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2181 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_custom_fields_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)      948 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_events_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1739 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_goal_relationships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2239 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_goals_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)      923 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_jobs_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1424 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_memberships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1238 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_organization_exports_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1437 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_portfolio_memberships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2823 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_portfolios_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1470 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_project_briefs_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1230 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_project_memberships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1542 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_project_statuses_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1721 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_project_templates_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3993 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_projects_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)      937 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_rules_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1907 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_sections_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1467 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_status_updates_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1531 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_stories_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1918 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_tags_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1321 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_task_templates_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4936 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_tasks_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1530 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_team_memberships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1822 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_teams_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1122 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_time_periods_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1774 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_time_tracking_entries_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)      990 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_typeahead_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1170 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_user_task_lists_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1556 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_users_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1517 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_webhooks_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1470 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_workspace_memberships_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1635 2024-03-14 22:30:24.000000 asana_preview-1.2.40/test/test_workspaces_api.py
```

### Comparing `asana_preview-1.0.9/asana_preview/api/__init__.py` & `asana_preview-1.2.40/asana_preview/api/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -22,14 +22,15 @@
 from asana_preview.api.project_templates_api import ProjectTemplatesApi
 from asana_preview.api.projects_api import ProjectsApi
 from asana_preview.api.rules_api import RulesApi
 from asana_preview.api.sections_api import SectionsApi
 from asana_preview.api.status_updates_api import StatusUpdatesApi
 from asana_preview.api.stories_api import StoriesApi
 from asana_preview.api.tags_api import TagsApi
+from asana_preview.api.task_templates_api import TaskTemplatesApi
 from asana_preview.api.tasks_api import TasksApi
 from asana_preview.api.team_memberships_api import TeamMembershipsApi
 from asana_preview.api.teams_api import TeamsApi
 from asana_preview.api.time_periods_api import TimePeriodsApi
 from asana_preview.api.time_tracking_entries_api import TimeTrackingEntriesApi
 from asana_preview.api.typeahead_api import TypeaheadApi
 from asana_preview.api.user_task_lists_api import UserTaskListsApi
```

### Comparing `asana_preview-1.0.9/asana_preview/api/attachments_api.py` & `asana_preview-1.2.40/asana_preview/api/task_templates_api.py`

 * *Files 19% similar despite different names*

```diff
@@ -12,445 +12,584 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
-
-class AttachmentsApi(object):
+class TaskTemplatesApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_attachment_for_object(self, **kwargs):  # noqa: E501
-        """Upload an attachment  # noqa: E501
+    def delete_task_template(self, task_template_gid, **kwargs):  # noqa: E501
+        """Delete a task template  # noqa: E501
 
-        Upload an attachment.  This method uploads an attachment on an object and returns the compact record for the created attachment object. This is possible by either:  - Providing the URL of the external resource being attached, or - Downloading the file content first and then uploading it as any other attachment. Note that it is not possible to attach files from third party services such as Dropbox, Box, Vimeo & Google Drive via the API  The 100MB size limit on attachments in Asana is enforced on this endpoint.  This endpoint expects a multipart/form-data encoded request containing the full contents of the file to be uploaded.  Requests made should follow the HTTP/1.1 specification that line terminators are of the form `CRLF` or `\\r\\n` outlined [here](http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01#Basic-Rules) in order for the server to reliably and properly handle the request.  # noqa: E501
+        A specific, existing task template can be deleted by making a DELETE request on the URL for that task template. Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_attachment_for_object(async_req=True)
+        >>> thread = api.delete_task_template(task_template_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str resource_subtype:
-        :param str file:
-        :param str parent:
-        :param str url:
-        :param str name:
-        :param bool connect_to_app:
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: AttachmentResponseData
+        :param str task_template_gid: Globally unique identifier for the task template. (required)
+        :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_attachment_for_object_with_http_info(**kwargs)  # noqa: E501
+            return self.delete_task_template_with_http_info(task_template_gid, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_attachment_for_object_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.delete_task_template_with_http_info(task_template_gid, **kwargs)  # noqa: E501
             return data
 
-    def create_attachment_for_object_with_http_info(self, **kwargs):  # noqa: E501
-        """Upload an attachment  # noqa: E501
+    def delete_task_template_with_http_info(self, task_template_gid, **kwargs):  # noqa: E501
+        """Delete a task template  # noqa: E501
 
-        Upload an attachment.  This method uploads an attachment on an object and returns the compact record for the created attachment object. This is possible by either:  - Providing the URL of the external resource being attached, or - Downloading the file content first and then uploading it as any other attachment. Note that it is not possible to attach files from third party services such as Dropbox, Box, Vimeo & Google Drive via the API  The 100MB size limit on attachments in Asana is enforced on this endpoint.  This endpoint expects a multipart/form-data encoded request containing the full contents of the file to be uploaded.  Requests made should follow the HTTP/1.1 specification that line terminators are of the form `CRLF` or `\\r\\n` outlined [here](http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01#Basic-Rules) in order for the server to reliably and properly handle the request.  # noqa: E501
+        A specific, existing task template can be deleted by making a DELETE request on the URL for that task template. Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_attachment_for_object_with_http_info(async_req=True)
+        >>> thread = api.delete_task_template_with_http_info(task_template_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str resource_subtype:
-        :param str file:
-        :param str parent:
-        :param str url:
-        :param str name:
-        :param bool connect_to_app:
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: AttachmentResponseData
+        :param str task_template_gid: Globally unique identifier for the task template. (required)
+        :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['resource_subtype', 'file', 'parent', 'url', 'name', 'connect_to_app', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create_attachment_for_object" % key
+                    " to method delete_task_template" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'task_template_gid' is set
+        if (task_template_gid is None):
+            raise ValueError("Missing the required parameter `task_template_gid` when calling `delete_task_template`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        path_params['task_template_gid'] = task_template_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
-        if 'resource_subtype' in params:
-            form_params.append(('resource_subtype', params['resource_subtype']))  # noqa: E501
-        if 'file' in params:
-            local_var_files['file'] = params['file']  # noqa: E501
-        if 'parent' in params:
-            form_params.append(('parent', params['parent']))  # noqa: E501
-        if 'url' in params:
-            form_params.append(('url', params['url']))  # noqa: E501
-        if 'name' in params:
-            form_params.append(('name', params['name']))  # noqa: E501
-        if 'connect_to_app' in params:
-            form_params.append(('connect_to_app', params['connect_to_app']))  # noqa: E501
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['multipart/form-data'])  # noqa: E501
-
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/attachments', 'POST',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/task_templates/{task_template_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/task_templates/{task_template_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/task_templates/{task_template_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='AttachmentResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def delete_attachment(self, attachment_gid, **kwargs):  # noqa: E501
-        """Delete an attachment  # noqa: E501
+    def get_task_template(self, task_template_gid, opts, **kwargs):  # noqa: E501
+        """Get a task template  # noqa: E501
 
-        Deletes a specific, existing attachment.  Returns an empty data record.  # noqa: E501
+        Returns the complete task template record for a single task template.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_attachment(attachment_gid, async_req=True)
+        >>> thread = api.get_task_template(task_template_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str attachment_gid: Globally unique identifier for the attachment. (required)
-        :return: EmptyResponseData
+        :param str task_template_gid: Globally unique identifier for the task template. (required)
+        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
+        :return: TaskTemplateResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.delete_attachment_with_http_info(attachment_gid, **kwargs)  # noqa: E501
+            return self.get_task_template_with_http_info(task_template_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.delete_attachment_with_http_info(attachment_gid, **kwargs)  # noqa: E501
+            (data) = self.get_task_template_with_http_info(task_template_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def delete_attachment_with_http_info(self, attachment_gid, **kwargs):  # noqa: E501
-        """Delete an attachment  # noqa: E501
+    def get_task_template_with_http_info(self, task_template_gid, opts, **kwargs):  # noqa: E501
+        """Get a task template  # noqa: E501
 
-        Deletes a specific, existing attachment.  Returns an empty data record.  # noqa: E501
+        Returns the complete task template record for a single task template.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_attachment_with_http_info(attachment_gid, async_req=True)
+        >>> thread = api.get_task_template_with_http_info(task_template_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str attachment_gid: Globally unique identifier for the attachment. (required)
-        :return: EmptyResponseData
+        :param str task_template_gid: Globally unique identifier for the task template. (required)
+        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
+        :return: TaskTemplateResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['attachment_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method delete_attachment" % key
+                    " to method get_task_template" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'attachment_gid' is set
-        if ('attachment_gid' not in params or
-                params['attachment_gid'] is None):
-            raise ValueError("Missing the required parameter `attachment_gid` when calling `delete_attachment`")  # noqa: E501
+        # verify the required parameter 'task_template_gid' is set
+        if (task_template_gid is None):
+            raise ValueError("Missing the required parameter `task_template_gid` when calling `get_task_template`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'attachment_gid' in params:
-            path_params['attachment_gid'] = params['attachment_gid']  # noqa: E501
+        path_params['task_template_gid'] = task_template_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/attachments/{attachment_gid}', 'DELETE',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/task_templates/{task_template_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/task_templates/{task_template_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/task_templates/{task_template_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_attachment(self, attachment_gid, **kwargs):  # noqa: E501
-        """Get an attachment  # noqa: E501
+    def get_task_templates(self, opts, **kwargs):  # noqa: E501
+        """Get multiple task templates  # noqa: E501
 
-        Get the full record for a single attachment.  # noqa: E501
+        Returns the compact task template records for some filtered set of task templates. You must specify a `project`  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_attachment(attachment_gid, async_req=True)
+        >>> thread = api.get_task_templates(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str attachment_gid: Globally unique identifier for the attachment. (required)
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str project: The project to filter task templates on.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: AttachmentResponseData
+        :return: TaskTemplateResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_attachment_with_http_info(attachment_gid, **kwargs)  # noqa: E501
+            return self.get_task_templates_with_http_info(opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_attachment_with_http_info(attachment_gid, **kwargs)  # noqa: E501
+            (data) = self.get_task_templates_with_http_info(opts, **kwargs)  # noqa: E501
             return data
 
-    def get_attachment_with_http_info(self, attachment_gid, **kwargs):  # noqa: E501
-        """Get an attachment  # noqa: E501
+    def get_task_templates_with_http_info(self, opts, **kwargs):  # noqa: E501
+        """Get multiple task templates  # noqa: E501
 
-        Get the full record for a single attachment.  # noqa: E501
+        Returns the compact task template records for some filtered set of task templates. You must specify a `project`  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_attachment_with_http_info(attachment_gid, async_req=True)
+        >>> thread = api.get_task_templates_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str attachment_gid: Globally unique identifier for the attachment. (required)
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str project: The project to filter task templates on.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: AttachmentResponseData
+        :return: TaskTemplateResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['attachment_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_attachment" % key
+                    " to method get_task_templates" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'attachment_gid' is set
-        if ('attachment_gid' not in params or
-                params['attachment_gid'] is None):
-            raise ValueError("Missing the required parameter `attachment_gid` when calling `get_attachment`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'attachment_gid' in params:
-            path_params['attachment_gid'] = params['attachment_gid']  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/attachments/{attachment_gid}', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/task_templates', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/task_templates',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/task_templates', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='AttachmentResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_attachments_for_object(self, parent, **kwargs):  # noqa: E501
-        """Get attachments from an object  # noqa: E501
+    def instantiate_task(self, task_template_gid, opts, **kwargs):  # noqa: E501
+        """Instantiate a task from a task template  # noqa: E501
 
-        Returns the compact records for all attachments on the object.  There are three possible `parent` values for this request: `project`, `project_brief`, and `task`. For a project, an attachment refers to a file uploaded to the \"Key resources\" section in the project Overview. For a project brief, an attachment refers to inline files in the project brief itself. For a task, an attachment refers to a file directly associated to that task.  Note that within the Asana app, inline images in the task description do not appear in the index of image thumbnails nor as stories in the task. However, requests made to `GET /attachments` for a task will return all of the images in the task, including inline images.  # noqa: E501
+        Creates and returns a job that will asynchronously handle the task instantiation.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_attachments_for_object(parent, async_req=True)
+        >>> thread = api.instantiate_task(task_template_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str parent: Globally unique identifier for object to fetch statuses from. Must be a GID for a `project`, `project_brief`, or `task`. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str task_template_gid: Globally unique identifier for the task template. (required)
+        :param dict body: Describes the inputs used for instantiating a task - the task's name.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: AttachmentResponseArray
+        :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_attachments_for_object_with_http_info(parent, **kwargs)  # noqa: E501
+            return self.instantiate_task_with_http_info(task_template_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_attachments_for_object_with_http_info(parent, **kwargs)  # noqa: E501
+            (data) = self.instantiate_task_with_http_info(task_template_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_attachments_for_object_with_http_info(self, parent, **kwargs):  # noqa: E501
-        """Get attachments from an object  # noqa: E501
+    def instantiate_task_with_http_info(self, task_template_gid, opts, **kwargs):  # noqa: E501
+        """Instantiate a task from a task template  # noqa: E501
 
-        Returns the compact records for all attachments on the object.  There are three possible `parent` values for this request: `project`, `project_brief`, and `task`. For a project, an attachment refers to a file uploaded to the \"Key resources\" section in the project Overview. For a project brief, an attachment refers to inline files in the project brief itself. For a task, an attachment refers to a file directly associated to that task.  Note that within the Asana app, inline images in the task description do not appear in the index of image thumbnails nor as stories in the task. However, requests made to `GET /attachments` for a task will return all of the images in the task, including inline images.  # noqa: E501
+        Creates and returns a job that will asynchronously handle the task instantiation.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_attachments_for_object_with_http_info(parent, async_req=True)
+        >>> thread = api.instantiate_task_with_http_info(task_template_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str parent: Globally unique identifier for object to fetch statuses from. Must be a GID for a `project`, `project_brief`, or `task`. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str task_template_gid: Globally unique identifier for the task template. (required)
+        :param dict body: Describes the inputs used for instantiating a task - the task's name.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: AttachmentResponseArray
+        :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['parent', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_attachments_for_object" % key
+                    " to method instantiate_task" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'parent' is set
-        if ('parent' not in params or
-                params['parent'] is None):
-            raise ValueError("Missing the required parameter `parent` when calling `get_attachments_for_object`")  # noqa: E501
+        # verify the required parameter 'task_template_gid' is set
+        if (task_template_gid is None):
+            raise ValueError("Missing the required parameter `task_template_gid` when calling `instantiate_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        path_params['task_template_gid'] = task_template_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'parent' in params:
-            query_params.append(('parent', params['parent']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json; charset=UTF-8'])  # noqa: E501
+
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/attachments', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/task_templates/{task_template_gid}/instantiateTask', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/task_templates/{task_template_gid}/instantiateTask', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/task_templates/{task_template_gid}/instantiateTask', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='AttachmentResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/audit_log_api_api.py` & `asana_preview-1.2.40/asana_preview/api/audit_log_api_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -12,31 +12,31 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class AuditLogAPIApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def get_audit_log_events(self, workspace_gid, **kwargs):  # noqa: E501
+    def get_audit_log_events(self, workspace_gid, opts, **kwargs):  # noqa: E501
         """Get audit log events  # noqa: E501
 
         Retrieve the audit log events that have been captured in your domain.  This endpoint will return a list of [AuditLogEvent](/reference/audit-log-api) objects, sorted by creation time in ascending order. Note that the Audit Log API captures events from October 8th, 2021 and later. Queries for events before this date will not return results.  There are a number of query parameters (below) that can be used to filter the set of [AuditLogEvent](/reference/audit-log-api) objects that are returned in the response. Any combination of query parameters is valid. When no filters are provided, all of the events that have been captured in your domain will match.  The list of events will always be [paginated](/docs/pagination). The default limit is 1000 events. The next set of events can be retrieved using the `offset` from the previous response. If there are no events that match the provided filters in your domain, the endpoint will return `null` for the `next_page` field. Querying again with the same filters may return new events if they were captured after the last request. Once a response includes a `next_page` with an `offset`, subsequent requests can be made with the latest `offset` to poll for new events that match the provided filters.  *Note: If the filters you provided match events in your domain and `next_page` is present in the response, we will continue to send `next_page` on subsequent requests even when there are no more events that match the filters. This was put in place so that you can implement an audit log stream that will return future events that match these filters. If you are not interested in future events that match the filters you have defined, you can rely on checking empty `data` response for the end of current events that match your filters.*  When no `offset` is provided, the response will begin with the oldest events that match the provided filters. It is important to note that [AuditLogEvent](/reference/audit-log-api) objects will be permanently deleted from our systems after 90 days. If you wish to keep a permanent record of these events, we recommend using a SIEM tool to ingest and store these logs.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_audit_log_events(workspace_gid, async_req=True)
         >>> result = thread.get()
@@ -51,22 +51,22 @@
         :param str resource_gid: Filter to events with this resource ID.
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :return: AuditLogEventArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_audit_log_events_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            return self.get_audit_log_events_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_audit_log_events_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            (data) = self.get_audit_log_events_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_audit_log_events_with_http_info(self, workspace_gid, **kwargs):  # noqa: E501
+    def get_audit_log_events_with_http_info(self, workspace_gid, opts, **kwargs):  # noqa: E501
         """Get audit log events  # noqa: E501
 
         Retrieve the audit log events that have been captured in your domain.  This endpoint will return a list of [AuditLogEvent](/reference/audit-log-api) objects, sorted by creation time in ascending order. Note that the Audit Log API captures events from October 8th, 2021 and later. Queries for events before this date will not return results.  There are a number of query parameters (below) that can be used to filter the set of [AuditLogEvent](/reference/audit-log-api) objects that are returned in the response. Any combination of query parameters is valid. When no filters are provided, all of the events that have been captured in your domain will match.  The list of events will always be [paginated](/docs/pagination). The default limit is 1000 events. The next set of events can be retrieved using the `offset` from the previous response. If there are no events that match the provided filters in your domain, the endpoint will return `null` for the `next_page` field. Querying again with the same filters may return new events if they were captured after the last request. Once a response includes a `next_page` with an `offset`, subsequent requests can be made with the latest `offset` to poll for new events that match the provided filters.  *Note: If the filters you provided match events in your domain and `next_page` is present in the response, we will continue to send `next_page` on subsequent requests even when there are no more events that match the filters. This was put in place so that you can implement an audit log stream that will return future events that match these filters. If you are not interested in future events that match the filters you have defined, you can rely on checking empty `data` response for the end of current events that match your filters.*  When no `offset` is provided, the response will begin with the oldest events that match the provided filters. It is important to note that [AuditLogEvent](/reference/audit-log-api) objects will be permanently deleted from our systems after 90 days. If you wish to keep a permanent record of these events, we recommend using a SIEM tool to ingest and store these logs.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_audit_log_events_with_http_info(workspace_gid, async_req=True)
         >>> result = thread.get()
@@ -81,80 +81,109 @@
         :param str resource_gid: Filter to events with this resource ID.
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :return: AuditLogEventArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace_gid', 'start_at', 'end_at', 'event_type', 'actor_type', 'actor_gid', 'resource_gid', 'limit', 'offset']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_audit_log_events" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'workspace_gid' is set
-        if ('workspace_gid' not in params or
-                params['workspace_gid'] is None):
+        if (workspace_gid is None):
             raise ValueError("Missing the required parameter `workspace_gid` when calling `get_audit_log_events`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'workspace_gid' in params:
-            path_params['workspace_gid'] = params['workspace_gid']  # noqa: E501
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
 
-        query_params = []
-        if 'start_at' in params:
-            query_params.append(('start_at', params['start_at']))  # noqa: E501
-        if 'end_at' in params:
-            query_params.append(('end_at', params['end_at']))  # noqa: E501
-        if 'event_type' in params:
-            query_params.append(('event_type', params['event_type']))  # noqa: E501
-        if 'actor_type' in params:
-            query_params.append(('actor_type', params['actor_type']))  # noqa: E501
-        if 'actor_gid' in params:
-            query_params.append(('actor_gid', params['actor_gid']))  # noqa: E501
-        if 'resource_gid' in params:
-            query_params.append(('resource_gid', params['resource_gid']))  # noqa: E501
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/audit_log_events', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/workspaces/{workspace_gid}/audit_log_events',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/workspaces/{workspace_gid}/audit_log_events', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='AuditLogEventArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/batch_api_api.py` & `asana_preview-1.2.40/asana_preview/api/batch_api_api.py`

 * *Files 20% similar despite different names*

```diff
@@ -12,126 +12,167 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class BatchAPIApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_batch_request(self, body, **kwargs):  # noqa: E501
+    def create_batch_request(self, body, opts, **kwargs):  # noqa: E501
         """Submit parallel requests  # noqa: E501
 
         Make multiple requests in parallel to Asana's API.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_batch_request(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param BatchBody body: The requests to batch together via the Batch API. (required)
+        :param dict body: The requests to batch together via the Batch API. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: BatchResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_batch_request_with_http_info(body, **kwargs)  # noqa: E501
+            return self.create_batch_request_with_http_info(body, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_batch_request_with_http_info(body, **kwargs)  # noqa: E501
+            (data) = self.create_batch_request_with_http_info(body, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_batch_request_with_http_info(self, body, **kwargs):  # noqa: E501
+    def create_batch_request_with_http_info(self, body, opts, **kwargs):  # noqa: E501
         """Submit parallel requests  # noqa: E501
 
         Make multiple requests in parallel to Asana's API.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_batch_request_with_http_info(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param BatchBody body: The requests to batch together via the Batch API. (required)
+        :param dict body: The requests to batch together via the Batch API. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: BatchResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_batch_request" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_batch_request`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/batch', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/batch',
+                    "method": 'POST',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/batch', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='BatchResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/custom_field_settings_api.py` & `asana_preview-1.2.40/asana_preview/api/project_memberships_api.py`

 * *Files 16% similar despite different names*

```diff
@@ -12,238 +12,309 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
-
-class CustomFieldSettingsApi(object):
+class ProjectMembershipsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def get_custom_field_settings_for_portfolio(self, portfolio_gid, **kwargs):  # noqa: E501
-        """Get a portfolio's custom fields  # noqa: E501
+    def get_project_membership(self, project_membership_gid, opts, **kwargs):  # noqa: E501
+        """Get a project membership  # noqa: E501
 
-        Returns a list of all of the custom fields settings on a portfolio, in compact form.  # noqa: E501
+        Returns the complete project record for a single project membership.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_custom_field_settings_for_portfolio(portfolio_gid, async_req=True)
+        >>> thread = api.get_project_membership(project_membership_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str project_membership_gid: (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldSettingResponseArray
+        :return: ProjectMembershipNormalResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_custom_field_settings_for_portfolio_with_http_info(portfolio_gid, **kwargs)  # noqa: E501
+            return self.get_project_membership_with_http_info(project_membership_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_custom_field_settings_for_portfolio_with_http_info(portfolio_gid, **kwargs)  # noqa: E501
+            (data) = self.get_project_membership_with_http_info(project_membership_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_custom_field_settings_for_portfolio_with_http_info(self, portfolio_gid, **kwargs):  # noqa: E501
-        """Get a portfolio's custom fields  # noqa: E501
+    def get_project_membership_with_http_info(self, project_membership_gid, opts, **kwargs):  # noqa: E501
+        """Get a project membership  # noqa: E501
 
-        Returns a list of all of the custom fields settings on a portfolio, in compact form.  # noqa: E501
+        Returns the complete project record for a single project membership.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_custom_field_settings_for_portfolio_with_http_info(portfolio_gid, async_req=True)
+        >>> thread = api.get_project_membership_with_http_info(project_membership_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str project_membership_gid: (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldSettingResponseArray
+        :return: ProjectMembershipNormalResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['portfolio_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_custom_field_settings_for_portfolio" % key
+                    " to method get_project_membership" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'portfolio_gid' is set
-        if ('portfolio_gid' not in params or
-                params['portfolio_gid'] is None):
-            raise ValueError("Missing the required parameter `portfolio_gid` when calling `get_custom_field_settings_for_portfolio`")  # noqa: E501
+        # verify the required parameter 'project_membership_gid' is set
+        if (project_membership_gid is None):
+            raise ValueError("Missing the required parameter `project_membership_gid` when calling `get_project_membership`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'portfolio_gid' in params:
-            path_params['portfolio_gid'] = params['portfolio_gid']  # noqa: E501
+        path_params['project_membership_gid'] = project_membership_gid  # noqa: E501
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/portfolios/{portfolio_gid}/custom_field_settings', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/project_memberships/{project_membership_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/project_memberships/{project_membership_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/project_memberships/{project_membership_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='CustomFieldSettingResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_custom_field_settings_for_project(self, project_gid, **kwargs):  # noqa: E501
-        """Get a project's custom fields  # noqa: E501
+    def get_project_memberships_for_project(self, project_gid, opts, **kwargs):  # noqa: E501
+        """Get memberships from a project  # noqa: E501
 
-        Returns a list of all of the custom fields settings on a project, in compact form. Note that, as in all queries to collections which return compact representation, `opt_fields` can be used to include more data than is returned in the compact representation. See the [documentation for input/output options](https://developers.asana.com/docs/inputoutput-options) for more information.  # noqa: E501
+        Returns the compact project membership records for the project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_custom_field_settings_for_project(project_gid, async_req=True)
+        >>> thread = api.get_project_memberships_for_project(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
+        :param str user: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user.
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldSettingResponseArray
+        :return: ProjectMembershipCompactArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_custom_field_settings_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            return self.get_project_memberships_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_custom_field_settings_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            (data) = self.get_project_memberships_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_custom_field_settings_for_project_with_http_info(self, project_gid, **kwargs):  # noqa: E501
-        """Get a project's custom fields  # noqa: E501
+    def get_project_memberships_for_project_with_http_info(self, project_gid, opts, **kwargs):  # noqa: E501
+        """Get memberships from a project  # noqa: E501
 
-        Returns a list of all of the custom fields settings on a project, in compact form. Note that, as in all queries to collections which return compact representation, `opt_fields` can be used to include more data than is returned in the compact representation. See the [documentation for input/output options](https://developers.asana.com/docs/inputoutput-options) for more information.  # noqa: E501
+        Returns the compact project membership records for the project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_custom_field_settings_for_project_with_http_info(project_gid, async_req=True)
+        >>> thread = api.get_project_memberships_for_project_with_http_info(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
+        :param str user: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user.
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldSettingResponseArray
+        :return: ProjectMembershipCompactArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_custom_field_settings_for_project" % key
+                    " to method get_project_memberships_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
-            raise ValueError("Missing the required parameter `project_gid` when calling `get_custom_field_settings_for_project`")  # noqa: E501
+        if (project_gid is None):
+            raise ValueError("Missing the required parameter `project_gid` when calling `get_project_memberships_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/projects/{project_gid}/custom_field_settings', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/project_memberships', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/projects/{project_gid}/project_memberships',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/projects/{project_gid}/project_memberships', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='CustomFieldSettingResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/custom_fields_api.py` & `asana_preview-1.2.40/asana_preview/api/users_api.py`

 * *Files 16% similar despite different names*

```diff
@@ -12,857 +12,751 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
-
-class CustomFieldsApi(object):
+class UsersApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_custom_field(self, **kwargs):  # noqa: E501
-        """Create a custom field  # noqa: E501
+    def get_favorites_for_user(self, user_gid, resource_type, workspace, opts, **kwargs):  # noqa: E501
+        """Get a user's favorites  # noqa: E501
 
-        Creates a new custom field in a workspace. Every custom field is required to be created in a specific workspace, and this workspace cannot be changed once set.  A custom field’s name must be unique within a workspace and not conflict with names of existing task properties such as `Due Date` or `Assignee`. A custom field’s type must be one of `text`, `enum`, `multi_enum`, `number`, `date`, or `people`.  Returns the full record of the newly created custom field.  # noqa: E501
+        Returns all of a user's favorites in the given workspace, of the given type. Results are given in order (The same order as Asana's sidebar).  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_custom_field(async_req=True)
+        >>> thread = api.get_favorites_for_user(user_gid, resource_type, workspace, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param CustomFieldsBody body: The custom field object to create.
+        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
+        :param str resource_type: The resource type of favorites to be returned. (required)
+        :param str workspace: The workspace in which to get favorites. (required)
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldResponseData
+        :return: AsanaNamedResourceArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_custom_field_with_http_info(**kwargs)  # noqa: E501
+            return self.get_favorites_for_user_with_http_info(user_gid, resource_type, workspace, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_custom_field_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_favorites_for_user_with_http_info(user_gid, resource_type, workspace, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_custom_field_with_http_info(self, **kwargs):  # noqa: E501
-        """Create a custom field  # noqa: E501
+    def get_favorites_for_user_with_http_info(self, user_gid, resource_type, workspace, opts, **kwargs):  # noqa: E501
+        """Get a user's favorites  # noqa: E501
 
-        Creates a new custom field in a workspace. Every custom field is required to be created in a specific workspace, and this workspace cannot be changed once set.  A custom field’s name must be unique within a workspace and not conflict with names of existing task properties such as `Due Date` or `Assignee`. A custom field’s type must be one of `text`, `enum`, `multi_enum`, `number`, `date`, or `people`.  Returns the full record of the newly created custom field.  # noqa: E501
+        Returns all of a user's favorites in the given workspace, of the given type. Results are given in order (The same order as Asana's sidebar).  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_custom_field_with_http_info(async_req=True)
+        >>> thread = api.get_favorites_for_user_with_http_info(user_gid, resource_type, workspace, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param CustomFieldsBody body: The custom field object to create.
+        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
+        :param str resource_type: The resource type of favorites to be returned. (required)
+        :param str workspace: The workspace in which to get favorites. (required)
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldResponseData
+        :return: AsanaNamedResourceArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create_custom_field" % key
+                    " to method get_favorites_for_user" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'user_gid' is set
+        if (user_gid is None):
+            raise ValueError("Missing the required parameter `user_gid` when calling `get_favorites_for_user`")  # noqa: E501
+        # verify the required parameter 'resource_type' is set
+        if (resource_type is None):
+            raise ValueError("Missing the required parameter `resource_type` when calling `get_favorites_for_user`")  # noqa: E501
+        # verify the required parameter 'workspace' is set
+        if (workspace is None):
+            raise ValueError("Missing the required parameter `workspace` when calling `get_favorites_for_user`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        path_params['user_gid'] = user_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
+        query_params = {}
+        query_params = opts
+        query_params['resource_type'] = resource_type
+        query_params['workspace'] = workspace
 
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/custom_fields', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='CustomFieldResponseData',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def create_enum_option_for_custom_field(self, custom_field_gid, **kwargs):  # noqa: E501
-        """Create an enum option  # noqa: E501
-
-        Creates an enum option and adds it to this custom field’s list of enum options. A custom field can have at most 500 enum options (including disabled options). By default new enum options are inserted at the end of a custom field’s list. Locked custom fields can only have enum options added by the user who locked the field. Returns the full record of the newly created enum option.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_enum_option_for_custom_field(custom_field_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
-        :param CustomFieldGidEnumOptionsBody body: The enum option object to create.
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: EnumOptionData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_enum_option_for_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
-        else:
-            (data) = self.create_enum_option_for_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
-            return data
-
-    def create_enum_option_for_custom_field_with_http_info(self, custom_field_gid, **kwargs):  # noqa: E501
-        """Create an enum option  # noqa: E501
-
-        Creates an enum option and adds it to this custom field’s list of enum options. A custom field can have at most 500 enum options (including disabled options). By default new enum options are inserted at the end of a custom field’s list. Locked custom fields can only have enum options added by the user who locked the field. Returns the full record of the newly created enum option.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_enum_option_for_custom_field_with_http_info(custom_field_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
-        :param CustomFieldGidEnumOptionsBody body: The enum option object to create.
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: EnumOptionData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['custom_field_gid', 'body', 'opt_fields']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_enum_option_for_custom_field" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'custom_field_gid' is set
-        if ('custom_field_gid' not in params or
-                params['custom_field_gid'] is None):
-            raise ValueError("Missing the required parameter `custom_field_gid` when calling `create_enum_option_for_custom_field`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'custom_field_gid' in params:
-            path_params['custom_field_gid'] = params['custom_field_gid']  # noqa: E501
-
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/custom_fields/{custom_field_gid}/enum_options', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='EnumOptionData',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def delete_custom_field(self, custom_field_gid, **kwargs):  # noqa: E501
-        """Delete a custom field  # noqa: E501
-
-        A specific, existing custom field can be deleted by making a DELETE request on the URL for that custom field. Locked custom fields can only be deleted by the user who locked the field. Returns an empty data record.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_custom_field(custom_field_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
-        :return: EmptyResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
-        else:
-            (data) = self.delete_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
-            return data
-
-    def delete_custom_field_with_http_info(self, custom_field_gid, **kwargs):  # noqa: E501
-        """Delete a custom field  # noqa: E501
-
-        A specific, existing custom field can be deleted by making a DELETE request on the URL for that custom field. Locked custom fields can only be deleted by the user who locked the field. Returns an empty data record.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_custom_field_with_http_info(custom_field_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
-        :return: EmptyResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['custom_field_gid']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_custom_field" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'custom_field_gid' is set
-        if ('custom_field_gid' not in params or
-                params['custom_field_gid'] is None):
-            raise ValueError("Missing the required parameter `custom_field_gid` when calling `delete_custom_field`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'custom_field_gid' in params:
-            path_params['custom_field_gid'] = params['custom_field_gid']  # noqa: E501
 
-        query_params = []
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/custom_fields/{custom_field_gid}', 'DELETE',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/users/{user_gid}/favorites', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/users/{user_gid}/favorites',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/users/{user_gid}/favorites', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_custom_field(self, custom_field_gid, **kwargs):  # noqa: E501
-        """Get a custom field  # noqa: E501
+    def get_user(self, user_gid, opts, **kwargs):  # noqa: E501
+        """Get a user  # noqa: E501
 
-        Get the complete definition of a custom field’s metadata.  Since custom fields can be defined for one of a number of types, and these types have different data and behaviors, there are fields that are relevant to a particular type. For instance, as noted above, enum_options is only relevant for the enum type and defines the set of choices that the enum could represent. The examples below show some of these type-specific custom field definitions.  # noqa: E501
+        Returns the full user record for the single user with the provided ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_custom_field(custom_field_gid, async_req=True)
+        >>> thread = api.get_user(user_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
+        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldResponseData
+        :return: UserResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
+            return self.get_user_with_http_info(user_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
+            (data) = self.get_user_with_http_info(user_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_custom_field_with_http_info(self, custom_field_gid, **kwargs):  # noqa: E501
-        """Get a custom field  # noqa: E501
+    def get_user_with_http_info(self, user_gid, opts, **kwargs):  # noqa: E501
+        """Get a user  # noqa: E501
 
-        Get the complete definition of a custom field’s metadata.  Since custom fields can be defined for one of a number of types, and these types have different data and behaviors, there are fields that are relevant to a particular type. For instance, as noted above, enum_options is only relevant for the enum type and defines the set of choices that the enum could represent. The examples below show some of these type-specific custom field definitions.  # noqa: E501
+        Returns the full user record for the single user with the provided ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_custom_field_with_http_info(custom_field_gid, async_req=True)
+        >>> thread = api.get_user_with_http_info(user_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
+        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldResponseData
+        :return: UserResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['custom_field_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_custom_field" % key
+                    " to method get_user" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'custom_field_gid' is set
-        if ('custom_field_gid' not in params or
-                params['custom_field_gid'] is None):
-            raise ValueError("Missing the required parameter `custom_field_gid` when calling `get_custom_field`")  # noqa: E501
+        # verify the required parameter 'user_gid' is set
+        if (user_gid is None):
+            raise ValueError("Missing the required parameter `user_gid` when calling `get_user`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'custom_field_gid' in params:
-            path_params['custom_field_gid'] = params['custom_field_gid']  # noqa: E501
+        path_params['user_gid'] = user_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/custom_fields/{custom_field_gid}', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/users/{user_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/users/{user_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/users/{user_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='CustomFieldResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_custom_fields_for_workspace(self, workspace_gid, **kwargs):  # noqa: E501
-        """Get a workspace's custom fields  # noqa: E501
+    def get_users(self, opts, **kwargs):  # noqa: E501
+        """Get multiple users  # noqa: E501
 
-        Returns a list of the compact representation of all of the custom fields in a workspace.  # noqa: E501
+        Returns the user records for all users in all workspaces and organizations accessible to the authenticated user. Accepts an optional workspace ID parameter. Results are sorted by user ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_custom_fields_for_workspace(workspace_gid, async_req=True)
+        >>> thread = api.get_users(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
+        :param str workspace: The workspace or organization ID to filter users on.
+        :param str team: The team ID to filter users on.
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldResponseArray
+        :return: UserResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_custom_fields_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            return self.get_users_with_http_info(opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_custom_fields_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            (data) = self.get_users_with_http_info(opts, **kwargs)  # noqa: E501
             return data
 
-    def get_custom_fields_for_workspace_with_http_info(self, workspace_gid, **kwargs):  # noqa: E501
-        """Get a workspace's custom fields  # noqa: E501
+    def get_users_with_http_info(self, opts, **kwargs):  # noqa: E501
+        """Get multiple users  # noqa: E501
 
-        Returns a list of the compact representation of all of the custom fields in a workspace.  # noqa: E501
+        Returns the user records for all users in all workspaces and organizations accessible to the authenticated user. Accepts an optional workspace ID parameter. Results are sorted by user ID.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_custom_fields_for_workspace_with_http_info(workspace_gid, async_req=True)
+        >>> thread = api.get_users_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
+        :param str workspace: The workspace or organization ID to filter users on.
+        :param str team: The team ID to filter users on.
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldResponseArray
+        :return: UserResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_custom_fields_for_workspace" % key
+                    " to method get_users" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'workspace_gid' is set
-        if ('workspace_gid' not in params or
-                params['workspace_gid'] is None):
-            raise ValueError("Missing the required parameter `workspace_gid` when calling `get_custom_fields_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'workspace_gid' in params:
-            path_params['workspace_gid'] = params['workspace_gid']  # noqa: E501
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
 
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/workspaces/{workspace_gid}/custom_fields', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='CustomFieldResponseArray',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def insert_enum_option_for_custom_field(self, custom_field_gid, **kwargs):  # noqa: E501
-        """Reorder a custom field's enum  # noqa: E501
-
-        Moves a particular enum option to be either before or after another specified enum option in the custom field. Locked custom fields can only be reordered by the user who locked the field.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.insert_enum_option_for_custom_field(custom_field_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
-        :param EnumOptionsInsertBody body: The enum option object to create.
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: EnumOptionData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.insert_enum_option_for_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
-        else:
-            (data) = self.insert_enum_option_for_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
-            return data
-
-    def insert_enum_option_for_custom_field_with_http_info(self, custom_field_gid, **kwargs):  # noqa: E501
-        """Reorder a custom field's enum  # noqa: E501
-
-        Moves a particular enum option to be either before or after another specified enum option in the custom field. Locked custom fields can only be reordered by the user who locked the field.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.insert_enum_option_for_custom_field_with_http_info(custom_field_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
-        :param EnumOptionsInsertBody body: The enum option object to create.
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: EnumOptionData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['custom_field_gid', 'body', 'opt_fields']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method insert_enum_option_for_custom_field" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'custom_field_gid' is set
-        if ('custom_field_gid' not in params or
-                params['custom_field_gid'] is None):
-            raise ValueError("Missing the required parameter `custom_field_gid` when calling `insert_enum_option_for_custom_field`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'custom_field_gid' in params:
-            path_params['custom_field_gid'] = params['custom_field_gid']  # noqa: E501
-
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/custom_fields/{custom_field_gid}/enum_options/insert', 'POST',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/users', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/users',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/users', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EnumOptionData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_custom_field(self, custom_field_gid, **kwargs):  # noqa: E501
-        """Update a custom field  # noqa: E501
+    def get_users_for_team(self, team_gid, opts, **kwargs):  # noqa: E501
+        """Get users in a team  # noqa: E501
 
-        A specific, existing custom field can be updated by making a PUT request on the URL for that custom field. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the custom field. A custom field’s `type` cannot be updated. An enum custom field’s `enum_options` cannot be updated with this endpoint. Instead see “Work With Enum Options” for information on how to update `enum_options`. Locked custom fields can only be updated by the user who locked the field. Returns the complete updated custom field record.  # noqa: E501
+        Returns the compact records for all users that are members of the team. Results are sorted alphabetically and limited to 2000. For more results use the `/users` endpoint.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_custom_field(custom_field_gid, async_req=True)
+        >>> thread = api.get_users_for_team(team_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
-        :param CustomFieldsCustomFieldGidBody body: The custom field object with all updated properties.
+        :param str team_gid: Globally unique identifier for the team. (required)
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldResponseData
+        :return: UserResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
+            return self.get_users_for_team_with_http_info(team_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
+            (data) = self.get_users_for_team_with_http_info(team_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_custom_field_with_http_info(self, custom_field_gid, **kwargs):  # noqa: E501
-        """Update a custom field  # noqa: E501
+    def get_users_for_team_with_http_info(self, team_gid, opts, **kwargs):  # noqa: E501
+        """Get users in a team  # noqa: E501
 
-        A specific, existing custom field can be updated by making a PUT request on the URL for that custom field. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the custom field. A custom field’s `type` cannot be updated. An enum custom field’s `enum_options` cannot be updated with this endpoint. Instead see “Work With Enum Options” for information on how to update `enum_options`. Locked custom fields can only be updated by the user who locked the field. Returns the complete updated custom field record.  # noqa: E501
+        Returns the compact records for all users that are members of the team. Results are sorted alphabetically and limited to 2000. For more results use the `/users` endpoint.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_custom_field_with_http_info(custom_field_gid, async_req=True)
+        >>> thread = api.get_users_for_team_with_http_info(team_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
-        :param CustomFieldsCustomFieldGidBody body: The custom field object with all updated properties.
+        :param str team_gid: Globally unique identifier for the team. (required)
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: CustomFieldResponseData
+        :return: UserResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['custom_field_gid', 'body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_custom_field" % key
+                    " to method get_users_for_team" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'custom_field_gid' is set
-        if ('custom_field_gid' not in params or
-                params['custom_field_gid'] is None):
-            raise ValueError("Missing the required parameter `custom_field_gid` when calling `update_custom_field`")  # noqa: E501
+        # verify the required parameter 'team_gid' is set
+        if (team_gid is None):
+            raise ValueError("Missing the required parameter `team_gid` when calling `get_users_for_team`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'custom_field_gid' in params:
-            path_params['custom_field_gid'] = params['custom_field_gid']  # noqa: E501
+        path_params['team_gid'] = team_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/custom_fields/{custom_field_gid}', 'PUT',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/teams/{team_gid}/users', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/teams/{team_gid}/users',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/teams/{team_gid}/users', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='CustomFieldResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_enum_option(self, enum_option_gid, **kwargs):  # noqa: E501
-        """Update an enum option  # noqa: E501
+    def get_users_for_workspace(self, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Get users in a workspace or organization  # noqa: E501
 
-        Updates an existing enum option. Enum custom fields require at least one enabled enum option. Locked custom fields can only be updated by the user who locked the field. Returns the full record of the updated enum option.  # noqa: E501
+        Returns the compact records for all users in the specified workspace or organization. Results are sorted alphabetically and limited to 2000. For more results use the `/users` endpoint.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_enum_option(enum_option_gid, async_req=True)
+        >>> thread = api.get_users_for_workspace(workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str enum_option_gid: Globally unique identifier for the enum option. (required)
-        :param EnumOptionsEnumOptionGidBody body: The enum option object to update
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: EnumOptionData
+        :return: UserResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_enum_option_with_http_info(enum_option_gid, **kwargs)  # noqa: E501
+            return self.get_users_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_enum_option_with_http_info(enum_option_gid, **kwargs)  # noqa: E501
+            (data) = self.get_users_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_enum_option_with_http_info(self, enum_option_gid, **kwargs):  # noqa: E501
-        """Update an enum option  # noqa: E501
+    def get_users_for_workspace_with_http_info(self, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Get users in a workspace or organization  # noqa: E501
 
-        Updates an existing enum option. Enum custom fields require at least one enabled enum option. Locked custom fields can only be updated by the user who locked the field. Returns the full record of the updated enum option.  # noqa: E501
+        Returns the compact records for all users in the specified workspace or organization. Results are sorted alphabetically and limited to 2000. For more results use the `/users` endpoint.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_enum_option_with_http_info(enum_option_gid, async_req=True)
+        >>> thread = api.get_users_for_workspace_with_http_info(workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str enum_option_gid: Globally unique identifier for the enum option. (required)
-        :param EnumOptionsEnumOptionGidBody body: The enum option object to update
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: EnumOptionData
+        :return: UserResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['enum_option_gid', 'body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_enum_option" % key
+                    " to method get_users_for_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'enum_option_gid' is set
-        if ('enum_option_gid' not in params or
-                params['enum_option_gid'] is None):
-            raise ValueError("Missing the required parameter `enum_option_gid` when calling `update_enum_option`")  # noqa: E501
+        # verify the required parameter 'workspace_gid' is set
+        if (workspace_gid is None):
+            raise ValueError("Missing the required parameter `workspace_gid` when calling `get_users_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'enum_option_gid' in params:
-            path_params['enum_option_gid'] = params['enum_option_gid']  # noqa: E501
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/enum_options/{enum_option_gid}', 'PUT',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/users', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/workspaces/{workspace_gid}/users',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/workspaces/{workspace_gid}/users', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EnumOptionData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

#### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

### Comparing `asana_preview-1.0.9/asana_preview/api/events_api.py` & `asana_preview-1.2.40/asana_preview/api/events_api.py`

 * *Files 15% similar despite different names*

```diff
@@ -12,126 +12,166 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class EventsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def get_events(self, resource, **kwargs):  # noqa: E501
+    def get_events(self, resource, opts, **kwargs):  # noqa: E501
         """Get events on a resource  # noqa: E501
 
         Returns the full record for all events that have occurred since the sync token was created.  A `GET` request to the endpoint `/[path_to_resource]/events` can be made in lieu of including the resource ID in the data for the request.  Asana limits a single sync token to 100 events. If more than 100 events exist for a given resource, `has_more: true` will be returned in the response, indicating that there are more events to pull.  *Note: The resource returned will be the resource that triggered the event. This may be different from the one that the events were requested for. For example, a subscription to a project will contain events for tasks contained within the project.*  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_events(resource, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str resource: A resource ID to subscribe to. The resource can be a task or project. (required)
+        :param str resource: A resource ID to subscribe to. The resource can be a task, project, or goal. (required)
         :param str sync: A sync token received from the last request, or none on first sync. Events will be returned from the point in time that the sync token was generated. *Note: On your first request, omit the sync token. The response will be the same as for an expired sync token, and will include a new valid sync token.If the sync token is too old (which may happen from time to time) the API will return a `412 Precondition Failed` error, and include a fresh sync token in the response.*
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: EventResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_events_with_http_info(resource, **kwargs)  # noqa: E501
+            return self.get_events_with_http_info(resource, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_events_with_http_info(resource, **kwargs)  # noqa: E501
+            (data) = self.get_events_with_http_info(resource, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_events_with_http_info(self, resource, **kwargs):  # noqa: E501
+    def get_events_with_http_info(self, resource, opts, **kwargs):  # noqa: E501
         """Get events on a resource  # noqa: E501
 
         Returns the full record for all events that have occurred since the sync token was created.  A `GET` request to the endpoint `/[path_to_resource]/events` can be made in lieu of including the resource ID in the data for the request.  Asana limits a single sync token to 100 events. If more than 100 events exist for a given resource, `has_more: true` will be returned in the response, indicating that there are more events to pull.  *Note: The resource returned will be the resource that triggered the event. This may be different from the one that the events were requested for. For example, a subscription to a project will contain events for tasks contained within the project.*  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_events_with_http_info(resource, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str resource: A resource ID to subscribe to. The resource can be a task or project. (required)
+        :param str resource: A resource ID to subscribe to. The resource can be a task, project, or goal. (required)
         :param str sync: A sync token received from the last request, or none on first sync. Events will be returned from the point in time that the sync token was generated. *Note: On your first request, omit the sync token. The response will be the same as for an expired sync token, and will include a new valid sync token.If the sync token is too old (which may happen from time to time) the API will return a `412 Precondition Failed` error, and include a fresh sync token in the response.*
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: EventResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['resource', 'sync', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_events" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'resource' is set
-        if ('resource' not in params or
-                params['resource'] is None):
+        if (resource is None):
             raise ValueError("Missing the required parameter `resource` when calling `get_events`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'resource' in params:
-            query_params.append(('resource', params['resource']))  # noqa: E501
-        if 'sync' in params:
-            query_params.append(('sync', params['sync']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+        query_params['resource'] = resource
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/events', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return EventIterator(
+                self.api_client,
+                {
+                    "resource_path": '/events',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/events', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EventResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/goal_relationships_api.py` & `asana_preview-1.2.40/asana_preview/api/project_statuses_api.py`

 * *Files 23% similar despite different names*

```diff
@@ -12,557 +12,591 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
-
-class GoalRelationshipsApi(object):
+class ProjectStatusesApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def add_supporting_relationship(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Add a supporting goal relationship  # noqa: E501
+    def create_project_status_for_project(self, body, project_gid, opts, **kwargs):  # noqa: E501
+        """Create a project status  # noqa: E501
 
-        Creates a goal relationship by adding a supporting resource to a given goal.  Returns the newly created goal relationship record.  # noqa: E501
+        *Deprecated: new integrations should prefer the `/status_updates` route.*  Creates a new status update on the project.  Returns the full record of the newly created project status update.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.add_supporting_relationship(body, goal_gid, async_req=True)
+        >>> thread = api.create_project_status_for_project(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalGidAddSupportingRelationshipBody body: The supporting resource to be added to the goal (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param dict body: The project status to create. (required)
+        :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalRelationshipResponseData
+        :return: ProjectStatusResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.add_supporting_relationship_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            return self.create_project_status_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.add_supporting_relationship_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            (data) = self.create_project_status_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def add_supporting_relationship_with_http_info(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Add a supporting goal relationship  # noqa: E501
+    def create_project_status_for_project_with_http_info(self, body, project_gid, opts, **kwargs):  # noqa: E501
+        """Create a project status  # noqa: E501
 
-        Creates a goal relationship by adding a supporting resource to a given goal.  Returns the newly created goal relationship record.  # noqa: E501
+        *Deprecated: new integrations should prefer the `/status_updates` route.*  Creates a new status update on the project.  Returns the full record of the newly created project status update.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.add_supporting_relationship_with_http_info(body, goal_gid, async_req=True)
+        >>> thread = api.create_project_status_for_project_with_http_info(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalGidAddSupportingRelationshipBody body: The supporting resource to be added to the goal (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param dict body: The project status to create. (required)
+        :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalRelationshipResponseData
+        :return: ProjectStatusResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'goal_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method add_supporting_relationship" % key
+                    " to method create_project_status_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `add_supporting_relationship`")  # noqa: E501
-        # verify the required parameter 'goal_gid' is set
-        if ('goal_gid' not in params or
-                params['goal_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_gid` when calling `add_supporting_relationship`")  # noqa: E501
+        if (body is None):
+            raise ValueError("Missing the required parameter `body` when calling `create_project_status_for_project`")  # noqa: E501
+        # verify the required parameter 'project_gid' is set
+        if (project_gid is None):
+            raise ValueError("Missing the required parameter `project_gid` when calling `create_project_status_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'goal_gid' in params:
-            path_params['goal_gid'] = params['goal_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goals/{goal_gid}/addSupportingRelationship', 'POST',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/project_statuses', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/project_statuses', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/projects/{project_gid}/project_statuses', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GoalRelationshipResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_goal_relationship(self, goal_relationship_gid, **kwargs):  # noqa: E501
-        """Get a goal relationship  # noqa: E501
+    def delete_project_status(self, project_status_gid, **kwargs):  # noqa: E501
+        """Delete a project status  # noqa: E501
 
-        Returns the complete updated goal relationship record for a single goal relationship.  # noqa: E501
+        *Deprecated: new integrations should prefer the `/status_updates/{status_gid}` route.*  Deletes a specific, existing project status update.  Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_goal_relationship(goal_relationship_gid, async_req=True)
+        >>> thread = api.delete_project_status(project_status_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str goal_relationship_gid: Globally unique identifier for the goal relationship. (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalRelationshipResponseData
+        :param str project_status_gid: The project status update to get. (required)
+        :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_goal_relationship_with_http_info(goal_relationship_gid, **kwargs)  # noqa: E501
+            return self.delete_project_status_with_http_info(project_status_gid, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_goal_relationship_with_http_info(goal_relationship_gid, **kwargs)  # noqa: E501
+            (data) = self.delete_project_status_with_http_info(project_status_gid, **kwargs)  # noqa: E501
             return data
 
-    def get_goal_relationship_with_http_info(self, goal_relationship_gid, **kwargs):  # noqa: E501
-        """Get a goal relationship  # noqa: E501
+    def delete_project_status_with_http_info(self, project_status_gid, **kwargs):  # noqa: E501
+        """Delete a project status  # noqa: E501
 
-        Returns the complete updated goal relationship record for a single goal relationship.  # noqa: E501
+        *Deprecated: new integrations should prefer the `/status_updates/{status_gid}` route.*  Deletes a specific, existing project status update.  Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_goal_relationship_with_http_info(goal_relationship_gid, async_req=True)
+        >>> thread = api.delete_project_status_with_http_info(project_status_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str goal_relationship_gid: Globally unique identifier for the goal relationship. (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalRelationshipResponseData
+        :param str project_status_gid: The project status update to get. (required)
+        :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['goal_relationship_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_goal_relationship" % key
+                    " to method delete_project_status" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'goal_relationship_gid' is set
-        if ('goal_relationship_gid' not in params or
-                params['goal_relationship_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_relationship_gid` when calling `get_goal_relationship`")  # noqa: E501
+        # verify the required parameter 'project_status_gid' is set
+        if (project_status_gid is None):
+            raise ValueError("Missing the required parameter `project_status_gid` when calling `delete_project_status`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'goal_relationship_gid' in params:
-            path_params['goal_relationship_gid'] = params['goal_relationship_gid']  # noqa: E501
+        path_params['project_status_gid'] = project_status_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goal_relationships/{goal_relationship_gid}', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/project_statuses/{project_status_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/project_statuses/{project_status_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/project_statuses/{project_status_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GoalRelationshipResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_goal_relationships(self, supported_goal, **kwargs):  # noqa: E501
-        """Get goal relationships  # noqa: E501
+    def get_project_status(self, project_status_gid, opts, **kwargs):  # noqa: E501
+        """Get a project status  # noqa: E501
 
-        Returns compact goal relationship records.  # noqa: E501
+        *Deprecated: new integrations should prefer the `/status_updates/{status_gid}` route.*  Returns the complete record for a single status update.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_goal_relationships(supported_goal, async_req=True)
+        >>> thread = api.get_project_status(project_status_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str supported_goal: Globally unique identifier for the supported goal in the goal relationship. (required)
-        :param str resource_subtype: If provided, filter to goal relationships with a given resource_subtype.
+        :param str project_status_gid: The project status update to get. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalRelationshipResponseArray
+        :return: ProjectStatusResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_goal_relationships_with_http_info(supported_goal, **kwargs)  # noqa: E501
+            return self.get_project_status_with_http_info(project_status_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_goal_relationships_with_http_info(supported_goal, **kwargs)  # noqa: E501
+            (data) = self.get_project_status_with_http_info(project_status_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_goal_relationships_with_http_info(self, supported_goal, **kwargs):  # noqa: E501
-        """Get goal relationships  # noqa: E501
+    def get_project_status_with_http_info(self, project_status_gid, opts, **kwargs):  # noqa: E501
+        """Get a project status  # noqa: E501
 
-        Returns compact goal relationship records.  # noqa: E501
+        *Deprecated: new integrations should prefer the `/status_updates/{status_gid}` route.*  Returns the complete record for a single status update.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_goal_relationships_with_http_info(supported_goal, async_req=True)
+        >>> thread = api.get_project_status_with_http_info(project_status_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str supported_goal: Globally unique identifier for the supported goal in the goal relationship. (required)
-        :param str resource_subtype: If provided, filter to goal relationships with a given resource_subtype.
+        :param str project_status_gid: The project status update to get. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalRelationshipResponseArray
+        :return: ProjectStatusResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['supported_goal', 'resource_subtype', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_goal_relationships" % key
+                    " to method get_project_status" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'supported_goal' is set
-        if ('supported_goal' not in params or
-                params['supported_goal'] is None):
-            raise ValueError("Missing the required parameter `supported_goal` when calling `get_goal_relationships`")  # noqa: E501
+        # verify the required parameter 'project_status_gid' is set
+        if (project_status_gid is None):
+            raise ValueError("Missing the required parameter `project_status_gid` when calling `get_project_status`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        path_params['project_status_gid'] = project_status_gid  # noqa: E501
 
-        query_params = []
-        if 'supported_goal' in params:
-            query_params.append(('supported_goal', params['supported_goal']))  # noqa: E501
-        if 'resource_subtype' in params:
-            query_params.append(('resource_subtype', params['resource_subtype']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        return self.api_client.call_api(
-            '/goal_relationships', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='GoalRelationshipResponseArray',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def remove_supporting_relationship(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Removes a supporting goal relationship  # noqa: E501
 
-        Removes a goal relationship for a given parent goal.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.remove_supporting_relationship(body, goal_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param GoalGidRemoveSupportingRelationshipBody body: The supporting resource to be removed from the goal (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
-        :return: EmptyResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.remove_supporting_relationship_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
-        else:
-            (data) = self.remove_supporting_relationship_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
-            return data
-
-    def remove_supporting_relationship_with_http_info(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Removes a supporting goal relationship  # noqa: E501
-
-        Removes a goal relationship for a given parent goal.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.remove_supporting_relationship_with_http_info(body, goal_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param GoalGidRemoveSupportingRelationshipBody body: The supporting resource to be removed from the goal (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
-        :return: EmptyResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body', 'goal_gid']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method remove_supporting_relationship" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `remove_supporting_relationship`")  # noqa: E501
-        # verify the required parameter 'goal_gid' is set
-        if ('goal_gid' not in params or
-                params['goal_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_gid` when calling `remove_supporting_relationship`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'goal_gid' in params:
-            path_params['goal_gid'] = params['goal_gid']  # noqa: E501
-
-        query_params = []
-
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goals/{goal_gid}/removeSupportingRelationship', 'POST',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/project_statuses/{project_status_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/project_statuses/{project_status_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/project_statuses/{project_status_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_goal_relationship(self, body, goal_relationship_gid, **kwargs):  # noqa: E501
-        """Update a goal relationship  # noqa: E501
+    def get_project_statuses_for_project(self, project_gid, opts, **kwargs):  # noqa: E501
+        """Get statuses from a project  # noqa: E501
 
-        An existing goal relationship can be updated by making a PUT request on the URL for that goal relationship. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated goal relationship record.  # noqa: E501
+        *Deprecated: new integrations should prefer the `/status_updates` route.*  Returns the compact project status update records for all updates on the project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_goal_relationship(body, goal_relationship_gid, async_req=True)
+        >>> thread = api.get_project_statuses_for_project(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalRelationshipsGoalRelationshipGidBody body: The updated fields for the goal relationship. (required)
-        :param str goal_relationship_gid: Globally unique identifier for the goal relationship. (required)
+        :param str project_gid: Globally unique identifier for the project. (required)
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalRelationshipResponseData
+        :return: ProjectStatusResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_goal_relationship_with_http_info(body, goal_relationship_gid, **kwargs)  # noqa: E501
+            return self.get_project_statuses_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_goal_relationship_with_http_info(body, goal_relationship_gid, **kwargs)  # noqa: E501
+            (data) = self.get_project_statuses_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_goal_relationship_with_http_info(self, body, goal_relationship_gid, **kwargs):  # noqa: E501
-        """Update a goal relationship  # noqa: E501
+    def get_project_statuses_for_project_with_http_info(self, project_gid, opts, **kwargs):  # noqa: E501
+        """Get statuses from a project  # noqa: E501
 
-        An existing goal relationship can be updated by making a PUT request on the URL for that goal relationship. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated goal relationship record.  # noqa: E501
+        *Deprecated: new integrations should prefer the `/status_updates` route.*  Returns the compact project status update records for all updates on the project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_goal_relationship_with_http_info(body, goal_relationship_gid, async_req=True)
+        >>> thread = api.get_project_statuses_for_project_with_http_info(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalRelationshipsGoalRelationshipGidBody body: The updated fields for the goal relationship. (required)
-        :param str goal_relationship_gid: Globally unique identifier for the goal relationship. (required)
+        :param str project_gid: Globally unique identifier for the project. (required)
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalRelationshipResponseData
+        :return: ProjectStatusResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'goal_relationship_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_goal_relationship" % key
+                    " to method get_project_statuses_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_goal_relationship`")  # noqa: E501
-        # verify the required parameter 'goal_relationship_gid' is set
-        if ('goal_relationship_gid' not in params or
-                params['goal_relationship_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_relationship_gid` when calling `update_goal_relationship`")  # noqa: E501
+        # verify the required parameter 'project_gid' is set
+        if (project_gid is None):
+            raise ValueError("Missing the required parameter `project_gid` when calling `get_project_statuses_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'goal_relationship_gid' in params:
-            path_params['goal_relationship_gid'] = params['goal_relationship_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goal_relationships/{goal_relationship_gid}', 'PUT',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/project_statuses', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/projects/{project_gid}/project_statuses',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/projects/{project_gid}/project_statuses', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GoalRelationshipResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/goals_api.py` & `asana_preview-1.2.40/asana_preview/api/custom_fields_api.py`

 * *Files 23% similar despite different names*

```diff
@@ -12,1106 +12,1165 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
-
-class GoalsApi(object):
+class CustomFieldsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def add_followers(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Add a collaborator to a goal  # noqa: E501
+    def create_custom_field(self, body, opts, **kwargs):  # noqa: E501
+        """Create a custom field  # noqa: E501
 
-        Adds followers to a goal. Returns the goal the followers were added to. Each goal can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated goal record, described above.  # noqa: E501
+        Creates a new custom field in a workspace. Every custom field is required to be created in a specific workspace, and this workspace cannot be changed once set.  A custom field’s name must be unique within a workspace and not conflict with names of existing task properties such as `Due Date` or `Assignee`. A custom field’s type must be one of `text`, `enum`, `multi_enum`, `number`, `date`, or `people`.  Returns the full record of the newly created custom field.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.add_followers(body, goal_gid, async_req=True)
+        >>> thread = api.create_custom_field(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalGidAddFollowersBody body: The followers to be added as collaborators (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param dict body: The custom field object to create. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: CustomFieldResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.add_followers_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            return self.create_custom_field_with_http_info(body, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.add_followers_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            (data) = self.create_custom_field_with_http_info(body, opts, **kwargs)  # noqa: E501
             return data
 
-    def add_followers_with_http_info(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Add a collaborator to a goal  # noqa: E501
+    def create_custom_field_with_http_info(self, body, opts, **kwargs):  # noqa: E501
+        """Create a custom field  # noqa: E501
 
-        Adds followers to a goal. Returns the goal the followers were added to. Each goal can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated goal record, described above.  # noqa: E501
+        Creates a new custom field in a workspace. Every custom field is required to be created in a specific workspace, and this workspace cannot be changed once set.  A custom field’s name must be unique within a workspace and not conflict with names of existing task properties such as `Due Date` or `Assignee`. A custom field’s type must be one of `text`, `enum`, `multi_enum`, `number`, `date`, or `people`.  Returns the full record of the newly created custom field.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.add_followers_with_http_info(body, goal_gid, async_req=True)
+        >>> thread = api.create_custom_field_with_http_info(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalGidAddFollowersBody body: The followers to be added as collaborators (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param dict body: The custom field object to create. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: CustomFieldResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'goal_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method add_followers" % key
+                    " to method create_custom_field" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `add_followers`")  # noqa: E501
-        # verify the required parameter 'goal_gid' is set
-        if ('goal_gid' not in params or
-                params['goal_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_gid` when calling `add_followers`")  # noqa: E501
+        if (body is None):
+            raise ValueError("Missing the required parameter `body` when calling `create_custom_field`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'goal_gid' in params:
-            path_params['goal_gid'] = params['goal_gid']  # noqa: E501
-
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/goals/{goal_gid}/addFollowers', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='GoalResponseData',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def create_goal(self, body, **kwargs):  # noqa: E501
-        """Create a goal  # noqa: E501
-
-        Creates a new goal in a workspace or team.  Returns the full record of the newly created goal.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_goal(body, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param GoalsBody body: The goal to create. (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_goal_with_http_info(body, **kwargs)  # noqa: E501
-        else:
-            (data) = self.create_goal_with_http_info(body, **kwargs)  # noqa: E501
-            return data
 
-    def create_goal_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Create a goal  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        Creates a new goal in a workspace or team.  Returns the full record of the newly created goal.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_goal_with_http_info(body, async_req=True)
-        >>> result = thread.get()
 
-        :param async_req bool
-        :param GoalsBody body: The goal to create. (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body', 'opt_fields']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_goal" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `create_goal`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goals', 'POST',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/custom_fields', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/custom_fields', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/custom_fields', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GoalResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create_goal_metric(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Create a goal metric  # noqa: E501
+    def create_enum_option_for_custom_field(self, custom_field_gid, opts, **kwargs):  # noqa: E501
+        """Create an enum option  # noqa: E501
 
-        Creates and adds a goal metric to a specified goal. Note that this replaces an existing goal metric if one already exists.  # noqa: E501
+        Creates an enum option and adds it to this custom field’s list of enum options. A custom field can have at most 500 enum options (including disabled options). By default new enum options are inserted at the end of a custom field’s list. Locked custom fields can only have enum options added by the user who locked the field. Returns the full record of the newly created enum option.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_goal_metric(body, goal_gid, async_req=True)
+        >>> thread = api.create_enum_option_for_custom_field(custom_field_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalGidSetMetricBody body: The goal metric to create. (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
+        :param dict body: The enum option object to create.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: EnumOptionData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_goal_metric_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            return self.create_enum_option_for_custom_field_with_http_info(custom_field_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_goal_metric_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            (data) = self.create_enum_option_for_custom_field_with_http_info(custom_field_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_goal_metric_with_http_info(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Create a goal metric  # noqa: E501
+    def create_enum_option_for_custom_field_with_http_info(self, custom_field_gid, opts, **kwargs):  # noqa: E501
+        """Create an enum option  # noqa: E501
 
-        Creates and adds a goal metric to a specified goal. Note that this replaces an existing goal metric if one already exists.  # noqa: E501
+        Creates an enum option and adds it to this custom field’s list of enum options. A custom field can have at most 500 enum options (including disabled options). By default new enum options are inserted at the end of a custom field’s list. Locked custom fields can only have enum options added by the user who locked the field. Returns the full record of the newly created enum option.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_goal_metric_with_http_info(body, goal_gid, async_req=True)
+        >>> thread = api.create_enum_option_for_custom_field_with_http_info(custom_field_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalGidSetMetricBody body: The goal metric to create. (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
+        :param dict body: The enum option object to create.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: EnumOptionData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'goal_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create_goal_metric" % key
+                    " to method create_enum_option_for_custom_field" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `create_goal_metric`")  # noqa: E501
-        # verify the required parameter 'goal_gid' is set
-        if ('goal_gid' not in params or
-                params['goal_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_gid` when calling `create_goal_metric`")  # noqa: E501
+        # verify the required parameter 'custom_field_gid' is set
+        if (custom_field_gid is None):
+            raise ValueError("Missing the required parameter `custom_field_gid` when calling `create_enum_option_for_custom_field`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'goal_gid' in params:
-            path_params['goal_gid'] = params['goal_gid']  # noqa: E501
+        path_params['custom_field_gid'] = custom_field_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goals/{goal_gid}/setMetric', 'POST',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/custom_fields/{custom_field_gid}/enum_options', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/custom_fields/{custom_field_gid}/enum_options', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/custom_fields/{custom_field_gid}/enum_options', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GoalResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def delete_goal(self, goal_gid, **kwargs):  # noqa: E501
-        """Delete a goal  # noqa: E501
+    def delete_custom_field(self, custom_field_gid, **kwargs):  # noqa: E501
+        """Delete a custom field  # noqa: E501
 
-        A specific, existing goal can be deleted by making a DELETE request on the URL for that goal.  Returns an empty data record.  # noqa: E501
+        A specific, existing custom field can be deleted by making a DELETE request on the URL for that custom field. Locked custom fields can only be deleted by the user who locked the field. Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_goal(goal_gid, async_req=True)
+        >>> thread = api.delete_custom_field(custom_field_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.delete_goal_with_http_info(goal_gid, **kwargs)  # noqa: E501
+            return self.delete_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
         else:
-            (data) = self.delete_goal_with_http_info(goal_gid, **kwargs)  # noqa: E501
+            (data) = self.delete_custom_field_with_http_info(custom_field_gid, **kwargs)  # noqa: E501
             return data
 
-    def delete_goal_with_http_info(self, goal_gid, **kwargs):  # noqa: E501
-        """Delete a goal  # noqa: E501
+    def delete_custom_field_with_http_info(self, custom_field_gid, **kwargs):  # noqa: E501
+        """Delete a custom field  # noqa: E501
 
-        A specific, existing goal can be deleted by making a DELETE request on the URL for that goal.  Returns an empty data record.  # noqa: E501
+        A specific, existing custom field can be deleted by making a DELETE request on the URL for that custom field. Locked custom fields can only be deleted by the user who locked the field. Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_goal_with_http_info(goal_gid, async_req=True)
+        >>> thread = api.delete_custom_field_with_http_info(custom_field_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['goal_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method delete_goal" % key
+                    " to method delete_custom_field" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'goal_gid' is set
-        if ('goal_gid' not in params or
-                params['goal_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_gid` when calling `delete_goal`")  # noqa: E501
+        # verify the required parameter 'custom_field_gid' is set
+        if (custom_field_gid is None):
+            raise ValueError("Missing the required parameter `custom_field_gid` when calling `delete_custom_field`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'goal_gid' in params:
-            path_params['goal_gid'] = params['goal_gid']  # noqa: E501
+        path_params['custom_field_gid'] = custom_field_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goals/{goal_gid}', 'DELETE',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/custom_fields/{custom_field_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/custom_fields/{custom_field_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/custom_fields/{custom_field_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_goal(self, goal_gid, **kwargs):  # noqa: E501
-        """Get a goal  # noqa: E501
+    def get_custom_field(self, custom_field_gid, opts, **kwargs):  # noqa: E501
+        """Get a custom field  # noqa: E501
 
-        Returns the complete goal record for a single goal.  # noqa: E501
+        Get the complete definition of a custom field’s metadata.  Since custom fields can be defined for one of a number of types, and these types have different data and behaviors, there are fields that are relevant to a particular type. For instance, as noted above, enum_options is only relevant for the enum type and defines the set of choices that the enum could represent. The examples below show some of these type-specific custom field definitions.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_goal(goal_gid, async_req=True)
+        >>> thread = api.get_custom_field(custom_field_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: CustomFieldResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_goal_with_http_info(goal_gid, **kwargs)  # noqa: E501
+            return self.get_custom_field_with_http_info(custom_field_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_goal_with_http_info(goal_gid, **kwargs)  # noqa: E501
+            (data) = self.get_custom_field_with_http_info(custom_field_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_goal_with_http_info(self, goal_gid, **kwargs):  # noqa: E501
-        """Get a goal  # noqa: E501
+    def get_custom_field_with_http_info(self, custom_field_gid, opts, **kwargs):  # noqa: E501
+        """Get a custom field  # noqa: E501
 
-        Returns the complete goal record for a single goal.  # noqa: E501
+        Get the complete definition of a custom field’s metadata.  Since custom fields can be defined for one of a number of types, and these types have different data and behaviors, there are fields that are relevant to a particular type. For instance, as noted above, enum_options is only relevant for the enum type and defines the set of choices that the enum could represent. The examples below show some of these type-specific custom field definitions.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_goal_with_http_info(goal_gid, async_req=True)
+        >>> thread = api.get_custom_field_with_http_info(custom_field_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: CustomFieldResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['goal_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_goal" % key
+                    " to method get_custom_field" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'goal_gid' is set
-        if ('goal_gid' not in params or
-                params['goal_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_gid` when calling `get_goal`")  # noqa: E501
+        # verify the required parameter 'custom_field_gid' is set
+        if (custom_field_gid is None):
+            raise ValueError("Missing the required parameter `custom_field_gid` when calling `get_custom_field`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'goal_gid' in params:
-            path_params['goal_gid'] = params['goal_gid']  # noqa: E501
+        path_params['custom_field_gid'] = custom_field_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goals/{goal_gid}', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/custom_fields/{custom_field_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/custom_fields/{custom_field_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/custom_fields/{custom_field_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GoalResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_goals(self, **kwargs):  # noqa: E501
-        """Get goals  # noqa: E501
+    def get_custom_fields_for_workspace(self, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Get a workspace's custom fields  # noqa: E501
 
-        Returns compact goal records.  # noqa: E501
+        Returns a list of the compact representation of all of the custom fields in a workspace.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_goals(async_req=True)
+        >>> thread = api.get_custom_fields_for_workspace(workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str portfolio: Globally unique identifier for supporting portfolio.
-        :param str project: Globally unique identifier for supporting project.
-        :param bool is_workspace_level: Filter to goals with is_workspace_level set to query value. Must be used with the workspace parameter.
-        :param str team: Globally unique identifier for the team.
-        :param str workspace: Globally unique identifier for the workspace.
-        :param list[str] time_periods: Globally unique identifiers for the time periods.
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseArray
+        :return: CustomFieldResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_goals_with_http_info(**kwargs)  # noqa: E501
+            return self.get_custom_fields_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_goals_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_custom_fields_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_goals_with_http_info(self, **kwargs):  # noqa: E501
-        """Get goals  # noqa: E501
+    def get_custom_fields_for_workspace_with_http_info(self, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Get a workspace's custom fields  # noqa: E501
 
-        Returns compact goal records.  # noqa: E501
+        Returns a list of the compact representation of all of the custom fields in a workspace.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_goals_with_http_info(async_req=True)
+        >>> thread = api.get_custom_fields_for_workspace_with_http_info(workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str portfolio: Globally unique identifier for supporting portfolio.
-        :param str project: Globally unique identifier for supporting project.
-        :param bool is_workspace_level: Filter to goals with is_workspace_level set to query value. Must be used with the workspace parameter.
-        :param str team: Globally unique identifier for the team.
-        :param str workspace: Globally unique identifier for the workspace.
-        :param list[str] time_periods: Globally unique identifiers for the time periods.
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseArray
+        :return: CustomFieldResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['portfolio', 'project', 'is_workspace_level', 'team', 'workspace', 'time_periods', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_goals" % key
+                    " to method get_custom_fields_for_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'workspace_gid' is set
+        if (workspace_gid is None):
+            raise ValueError("Missing the required parameter `workspace_gid` when calling `get_custom_fields_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
 
-        query_params = []
-        if 'portfolio' in params:
-            query_params.append(('portfolio', params['portfolio']))  # noqa: E501
-        if 'project' in params:
-            query_params.append(('project', params['project']))  # noqa: E501
-        if 'is_workspace_level' in params:
-            query_params.append(('is_workspace_level', params['is_workspace_level']))  # noqa: E501
-        if 'team' in params:
-            query_params.append(('team', params['team']))  # noqa: E501
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'time_periods' in params:
-            query_params.append(('time_periods', params['time_periods']))  # noqa: E501
-            collection_formats['time_periods'] = 'multi'  # noqa: E501
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/goals', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='GoalResponseArray',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_parent_goals_for_goal(self, goal_gid, **kwargs):  # noqa: E501
-        """Get parent goals from a goal  # noqa: E501
-
-        Returns a compact representation of all of the parent goals of a goal.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_parent_goals_for_goal(goal_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str goal_gid: Globally unique identifier for the goal. (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseArray
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_parent_goals_for_goal_with_http_info(goal_gid, **kwargs)  # noqa: E501
-        else:
-            (data) = self.get_parent_goals_for_goal_with_http_info(goal_gid, **kwargs)  # noqa: E501
-            return data
-
-    def get_parent_goals_for_goal_with_http_info(self, goal_gid, **kwargs):  # noqa: E501
-        """Get parent goals from a goal  # noqa: E501
-
-        Returns a compact representation of all of the parent goals of a goal.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_parent_goals_for_goal_with_http_info(goal_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str goal_gid: Globally unique identifier for the goal. (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseArray
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
+        query_params = {}
+        query_params = opts
 
-        all_params = ['goal_gid', 'opt_fields']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
 
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_parent_goals_for_goal" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'goal_gid' is set
-        if ('goal_gid' not in params or
-                params['goal_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_gid` when calling `get_parent_goals_for_goal`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'goal_gid' in params:
-            path_params['goal_gid'] = params['goal_gid']  # noqa: E501
-
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goals/{goal_gid}/parentGoals', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/custom_fields', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/workspaces/{workspace_gid}/custom_fields',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/workspaces/{workspace_gid}/custom_fields', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GoalResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def remove_followers(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Remove a collaborator from a goal  # noqa: E501
+    def insert_enum_option_for_custom_field(self, custom_field_gid, opts, **kwargs):  # noqa: E501
+        """Reorder a custom field's enum  # noqa: E501
 
-        Removes followers from a goal. Returns the goal the followers were removed from. Each goal can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated goal record, described above.  # noqa: E501
+        Moves a particular enum option to be either before or after another specified enum option in the custom field. Locked custom fields can only be reordered by the user who locked the field.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.remove_followers(body, goal_gid, async_req=True)
+        >>> thread = api.insert_enum_option_for_custom_field(custom_field_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalGidRemoveFollowersBody body: The followers to be removed as collaborators (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
+        :param dict body: The enum option object to create.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: EnumOptionData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.remove_followers_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            return self.insert_enum_option_for_custom_field_with_http_info(custom_field_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.remove_followers_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            (data) = self.insert_enum_option_for_custom_field_with_http_info(custom_field_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def remove_followers_with_http_info(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Remove a collaborator from a goal  # noqa: E501
+    def insert_enum_option_for_custom_field_with_http_info(self, custom_field_gid, opts, **kwargs):  # noqa: E501
+        """Reorder a custom field's enum  # noqa: E501
 
-        Removes followers from a goal. Returns the goal the followers were removed from. Each goal can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated goal record, described above.  # noqa: E501
+        Moves a particular enum option to be either before or after another specified enum option in the custom field. Locked custom fields can only be reordered by the user who locked the field.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.remove_followers_with_http_info(body, goal_gid, async_req=True)
+        >>> thread = api.insert_enum_option_for_custom_field_with_http_info(custom_field_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalGidRemoveFollowersBody body: The followers to be removed as collaborators (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
+        :param dict body: The enum option object to create.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: EnumOptionData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'goal_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method remove_followers" % key
+                    " to method insert_enum_option_for_custom_field" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `remove_followers`")  # noqa: E501
-        # verify the required parameter 'goal_gid' is set
-        if ('goal_gid' not in params or
-                params['goal_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_gid` when calling `remove_followers`")  # noqa: E501
+        # verify the required parameter 'custom_field_gid' is set
+        if (custom_field_gid is None):
+            raise ValueError("Missing the required parameter `custom_field_gid` when calling `insert_enum_option_for_custom_field`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'goal_gid' in params:
-            path_params['goal_gid'] = params['goal_gid']  # noqa: E501
+        path_params['custom_field_gid'] = custom_field_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goals/{goal_gid}/removeFollowers', 'POST',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/custom_fields/{custom_field_gid}/enum_options/insert', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/custom_fields/{custom_field_gid}/enum_options/insert', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/custom_fields/{custom_field_gid}/enum_options/insert', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GoalResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_goal(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Update a goal  # noqa: E501
+    def update_custom_field(self, custom_field_gid, opts, **kwargs):  # noqa: E501
+        """Update a custom field  # noqa: E501
 
-        An existing goal can be updated by making a PUT request on the URL for that goal. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated goal record.  # noqa: E501
+        A specific, existing custom field can be updated by making a PUT request on the URL for that custom field. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the custom field. A custom field’s `type` cannot be updated. An enum custom field’s `enum_options` cannot be updated with this endpoint. Instead see “Work With Enum Options” for information on how to update `enum_options`. Locked custom fields can only be updated by the user who locked the field. Returns the complete updated custom field record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_goal(body, goal_gid, async_req=True)
+        >>> thread = api.update_custom_field(custom_field_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalsGoalGidBody body: The updated fields for the goal. (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
+        :param dict body: The custom field object with all updated properties.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: CustomFieldResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_goal_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            return self.update_custom_field_with_http_info(custom_field_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_goal_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            (data) = self.update_custom_field_with_http_info(custom_field_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_goal_with_http_info(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Update a goal  # noqa: E501
+    def update_custom_field_with_http_info(self, custom_field_gid, opts, **kwargs):  # noqa: E501
+        """Update a custom field  # noqa: E501
 
-        An existing goal can be updated by making a PUT request on the URL for that goal. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated goal record.  # noqa: E501
+        A specific, existing custom field can be updated by making a PUT request on the URL for that custom field. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the custom field. A custom field’s `type` cannot be updated. An enum custom field’s `enum_options` cannot be updated with this endpoint. Instead see “Work With Enum Options” for information on how to update `enum_options`. Locked custom fields can only be updated by the user who locked the field. Returns the complete updated custom field record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_goal_with_http_info(body, goal_gid, async_req=True)
+        >>> thread = api.update_custom_field_with_http_info(custom_field_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalsGoalGidBody body: The updated fields for the goal. (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str custom_field_gid: Globally unique identifier for the custom field. (required)
+        :param dict body: The custom field object with all updated properties.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: CustomFieldResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'goal_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_goal" % key
+                    " to method update_custom_field" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_goal`")  # noqa: E501
-        # verify the required parameter 'goal_gid' is set
-        if ('goal_gid' not in params or
-                params['goal_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_gid` when calling `update_goal`")  # noqa: E501
+        # verify the required parameter 'custom_field_gid' is set
+        if (custom_field_gid is None):
+            raise ValueError("Missing the required parameter `custom_field_gid` when calling `update_custom_field`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'goal_gid' in params:
-            path_params['goal_gid'] = params['goal_gid']  # noqa: E501
+        path_params['custom_field_gid'] = custom_field_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goals/{goal_gid}', 'PUT',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/custom_fields/{custom_field_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/custom_fields/{custom_field_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/custom_fields/{custom_field_gid}', 'PUT',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GoalResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_goal_metric(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Update a goal metric  # noqa: E501
+    def update_enum_option(self, enum_option_gid, opts, **kwargs):  # noqa: E501
+        """Update an enum option  # noqa: E501
 
-        Updates a goal's existing metric's `current_number_value` if one exists, otherwise responds with a 400 status code.  Returns the complete updated goal metric record.  # noqa: E501
+        Updates an existing enum option. Enum custom fields require at least one enabled enum option. Locked custom fields can only be updated by the user who locked the field. Returns the full record of the updated enum option.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_goal_metric(body, goal_gid, async_req=True)
+        >>> thread = api.update_enum_option(enum_option_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalGidSetMetricCurrentValueBody body: The updated fields for the goal metric. (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str enum_option_gid: Globally unique identifier for the enum option. (required)
+        :param dict body: The enum option object to update
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: EnumOptionData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_goal_metric_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            return self.update_enum_option_with_http_info(enum_option_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_goal_metric_with_http_info(body, goal_gid, **kwargs)  # noqa: E501
+            (data) = self.update_enum_option_with_http_info(enum_option_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_goal_metric_with_http_info(self, body, goal_gid, **kwargs):  # noqa: E501
-        """Update a goal metric  # noqa: E501
+    def update_enum_option_with_http_info(self, enum_option_gid, opts, **kwargs):  # noqa: E501
+        """Update an enum option  # noqa: E501
 
-        Updates a goal's existing metric's `current_number_value` if one exists, otherwise responds with a 400 status code.  Returns the complete updated goal metric record.  # noqa: E501
+        Updates an existing enum option. Enum custom fields require at least one enabled enum option. Locked custom fields can only be updated by the user who locked the field. Returns the full record of the updated enum option.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_goal_metric_with_http_info(body, goal_gid, async_req=True)
+        >>> thread = api.update_enum_option_with_http_info(enum_option_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param GoalGidSetMetricCurrentValueBody body: The updated fields for the goal metric. (required)
-        :param str goal_gid: Globally unique identifier for the goal. (required)
+        :param str enum_option_gid: Globally unique identifier for the enum option. (required)
+        :param dict body: The enum option object to update
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: GoalResponseData
+        :return: EnumOptionData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'goal_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_goal_metric" % key
+                    " to method update_enum_option" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_goal_metric`")  # noqa: E501
-        # verify the required parameter 'goal_gid' is set
-        if ('goal_gid' not in params or
-                params['goal_gid'] is None):
-            raise ValueError("Missing the required parameter `goal_gid` when calling `update_goal_metric`")  # noqa: E501
+        # verify the required parameter 'enum_option_gid' is set
+        if (enum_option_gid is None):
+            raise ValueError("Missing the required parameter `enum_option_gid` when calling `update_enum_option`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'goal_gid' in params:
-            path_params['goal_gid'] = params['goal_gid']  # noqa: E501
+        path_params['enum_option_gid'] = enum_option_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/goals/{goal_gid}/setMetricCurrentValue', 'POST',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/enum_options/{enum_option_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/enum_options/{enum_option_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/enum_options/{enum_option_gid}', 'PUT',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='GoalResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `asana_preview-1.0.9/asana_preview/api/jobs_api.py` & `asana_preview-1.2.40/asana_preview/api/jobs_api.py`

 * *Files 25% similar despite different names*

```diff
@@ -12,31 +12,31 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class JobsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def get_job(self, job_gid, **kwargs):  # noqa: E501
+    def get_job(self, job_gid, opts, **kwargs):  # noqa: E501
         """Get a job by id  # noqa: E501
 
         Returns the full record for a job.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_job(job_gid, async_req=True)
         >>> result = thread.get()
@@ -44,22 +44,22 @@
         :param async_req bool
         :param str job_gid: Globally unique identifier for the job. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_job_with_http_info(job_gid, **kwargs)  # noqa: E501
+            return self.get_job_with_http_info(job_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_job_with_http_info(job_gid, **kwargs)  # noqa: E501
+            (data) = self.get_job_with_http_info(job_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_job_with_http_info(self, job_gid, **kwargs):  # noqa: E501
+    def get_job_with_http_info(self, job_gid, opts, **kwargs):  # noqa: E501
         """Get a job by id  # noqa: E501
 
         Returns the full record for a job.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_job_with_http_info(job_gid, async_req=True)
         >>> result = thread.get()
@@ -67,67 +67,106 @@
         :param async_req bool
         :param str job_gid: Globally unique identifier for the job. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['job_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_job" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'job_gid' is set
-        if ('job_gid' not in params or
-                params['job_gid'] is None):
+        if (job_gid is None):
             raise ValueError("Missing the required parameter `job_gid` when calling `get_job`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'job_gid' in params:
-            path_params['job_gid'] = params['job_gid']  # noqa: E501
+        path_params['job_gid'] = job_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/jobs/{job_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/jobs/{job_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/jobs/{job_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='JobResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/memberships_api.py` & `asana_preview-1.2.40/asana_preview/api/portfolio_memberships_api.py`

 * *Files 26% similar despite different names*

```diff
@@ -12,418 +12,455 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
-
-class MembershipsApi(object):
+class PortfolioMembershipsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_membership(self, **kwargs):  # noqa: E501
-        """Create a membership  # noqa: E501
+    def get_portfolio_membership(self, portfolio_membership_gid, opts, **kwargs):  # noqa: E501
+        """Get a portfolio membership  # noqa: E501
 
-        Creates a new membership in a `goal`. `Teams` or `users` can be a member of `goals`.  Returns the full record of the newly created membership.  # noqa: E501
+        Returns the complete portfolio record for a single portfolio membership.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_membership(async_req=True)
+        >>> thread = api.get_portfolio_membership(portfolio_membership_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param MembershipsBody body: The updated fields for the membership.
-        :return: MembershipResponseData
+        :param str portfolio_membership_gid: (required)
+        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
+        :return: PortfolioMembershipResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_membership_with_http_info(**kwargs)  # noqa: E501
+            return self.get_portfolio_membership_with_http_info(portfolio_membership_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_membership_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_portfolio_membership_with_http_info(portfolio_membership_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_membership_with_http_info(self, **kwargs):  # noqa: E501
-        """Create a membership  # noqa: E501
+    def get_portfolio_membership_with_http_info(self, portfolio_membership_gid, opts, **kwargs):  # noqa: E501
+        """Get a portfolio membership  # noqa: E501
 
-        Creates a new membership in a `goal`. `Teams` or `users` can be a member of `goals`.  Returns the full record of the newly created membership.  # noqa: E501
+        Returns the complete portfolio record for a single portfolio membership.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_membership_with_http_info(async_req=True)
+        >>> thread = api.get_portfolio_membership_with_http_info(portfolio_membership_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param MembershipsBody body: The updated fields for the membership.
-        :return: MembershipResponseData
+        :param str portfolio_membership_gid: (required)
+        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
+        :return: PortfolioMembershipResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create_membership" % key
+                    " to method get_portfolio_membership" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'portfolio_membership_gid' is set
+        if (portfolio_membership_gid is None):
+            raise ValueError("Missing the required parameter `portfolio_membership_gid` when calling `get_portfolio_membership`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        path_params['portfolio_membership_gid'] = portfolio_membership_gid  # noqa: E501
 
-        query_params = []
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/memberships', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='MembershipResponseData',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def delete_membership(self, membership_gid, **kwargs):  # noqa: E501
-        """Delete a membership  # noqa: E501
-
-        A specific, existing membership can be deleted by making a `DELETE` request on the URL for that membership.  Returns an empty data record.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_membership(membership_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str membership_gid: Globally unique identifier for the membership. (required)
-        :return: EmptyResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_membership_with_http_info(membership_gid, **kwargs)  # noqa: E501
-        else:
-            (data) = self.delete_membership_with_http_info(membership_gid, **kwargs)  # noqa: E501
-            return data
-
-    def delete_membership_with_http_info(self, membership_gid, **kwargs):  # noqa: E501
-        """Delete a membership  # noqa: E501
-
-        A specific, existing membership can be deleted by making a `DELETE` request on the URL for that membership.  Returns an empty data record.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_membership_with_http_info(membership_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str membership_gid: Globally unique identifier for the membership. (required)
-        :return: EmptyResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['membership_gid']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_membership" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'membership_gid' is set
-        if ('membership_gid' not in params or
-                params['membership_gid'] is None):
-            raise ValueError("Missing the required parameter `membership_gid` when calling `delete_membership`")  # noqa: E501
-
-        collection_formats = {}
+        query_params = {}
+        query_params = opts
 
-        path_params = {}
-        if 'membership_gid' in params:
-            path_params['membership_gid'] = params['membership_gid']  # noqa: E501
 
-        query_params = []
-
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/memberships/{membership_gid}', 'DELETE',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolio_memberships/{portfolio_membership_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/portfolio_memberships/{portfolio_membership_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/portfolio_memberships/{portfolio_membership_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_memberships(self, **kwargs):  # noqa: E501
-        """Get multiple memberships  # noqa: E501
+    def get_portfolio_memberships(self, opts, **kwargs):  # noqa: E501
+        """Get multiple portfolio memberships  # noqa: E501
 
-        Returns compact `goal_membership` records. The possible types for `parent` in this request are `goal`. An additional member (user GID or team GID) can be passed in to filter to a specific membership.  # noqa: E501
+        Returns a list of portfolio memberships in compact representation. You must specify `portfolio`, `portfolio` and `user`, or `workspace` and `user`.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_memberships(async_req=True)
+        >>> thread = api.get_portfolio_memberships(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str parent: Globally unique identifier for `goal`.
-        :param str member: Globally unique identifier for `team` or `user`.
-        :param int limit: Pagination limit for the request.
+        :param str portfolio: The portfolio to filter results on.
+        :param str workspace: The workspace to filter results on.
+        :param str user: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user.
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :return: MembershipResponseArray
+        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
+        :return: PortfolioMembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_memberships_with_http_info(**kwargs)  # noqa: E501
+            return self.get_portfolio_memberships_with_http_info(opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_memberships_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_portfolio_memberships_with_http_info(opts, **kwargs)  # noqa: E501
             return data
 
-    def get_memberships_with_http_info(self, **kwargs):  # noqa: E501
-        """Get multiple memberships  # noqa: E501
+    def get_portfolio_memberships_with_http_info(self, opts, **kwargs):  # noqa: E501
+        """Get multiple portfolio memberships  # noqa: E501
 
-        Returns compact `goal_membership` records. The possible types for `parent` in this request are `goal`. An additional member (user GID or team GID) can be passed in to filter to a specific membership.  # noqa: E501
+        Returns a list of portfolio memberships in compact representation. You must specify `portfolio`, `portfolio` and `user`, or `workspace` and `user`.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_memberships_with_http_info(async_req=True)
+        >>> thread = api.get_portfolio_memberships_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str parent: Globally unique identifier for `goal`.
-        :param str member: Globally unique identifier for `team` or `user`.
-        :param int limit: Pagination limit for the request.
+        :param str portfolio: The portfolio to filter results on.
+        :param str workspace: The workspace to filter results on.
+        :param str user: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user.
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :return: MembershipResponseArray
+        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
+        :return: PortfolioMembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['parent', 'member', 'limit', 'offset']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_memberships" % key
+                    " to method get_portfolio_memberships" % key
                 )
             params[key] = val
         del params['kwargs']
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'parent' in params:
-            query_params.append(('parent', params['parent']))  # noqa: E501
-        if 'member' in params:
-            query_params.append(('member', params['member']))  # noqa: E501
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
+        query_params = {}
+        query_params = opts
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/memberships', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolio_memberships', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/portfolio_memberships',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/portfolio_memberships', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='MembershipResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_membership(self, membership_gid, **kwargs):  # noqa: E501
-        """Update a membership  # noqa: E501
+    def get_portfolio_memberships_for_portfolio(self, portfolio_gid, opts, **kwargs):  # noqa: E501
+        """Get memberships from a portfolio  # noqa: E501
 
-        An existing membership can be updated by making a `PUT` request on the URL for that goal. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged. Memberships on `project`, `portfolio`, `team`, and `goals` can be updated.  # noqa: E501
+        Returns the compact portfolio membership records for the portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_membership(membership_gid, async_req=True)
+        >>> thread = api.get_portfolio_memberships_for_portfolio(portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str membership_gid: Globally unique identifier for the membership. (required)
-        :param MembershipsMembershipGidBody body: The updated fields for the membership.
-        :return: MembershipResponseData
+        :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
+        :param str user: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user.
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
+        :return: PortfolioMembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_membership_with_http_info(membership_gid, **kwargs)  # noqa: E501
+            return self.get_portfolio_memberships_for_portfolio_with_http_info(portfolio_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_membership_with_http_info(membership_gid, **kwargs)  # noqa: E501
+            (data) = self.get_portfolio_memberships_for_portfolio_with_http_info(portfolio_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_membership_with_http_info(self, membership_gid, **kwargs):  # noqa: E501
-        """Update a membership  # noqa: E501
+    def get_portfolio_memberships_for_portfolio_with_http_info(self, portfolio_gid, opts, **kwargs):  # noqa: E501
+        """Get memberships from a portfolio  # noqa: E501
 
-        An existing membership can be updated by making a `PUT` request on the URL for that goal. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged. Memberships on `project`, `portfolio`, `team`, and `goals` can be updated.  # noqa: E501
+        Returns the compact portfolio membership records for the portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_membership_with_http_info(membership_gid, async_req=True)
+        >>> thread = api.get_portfolio_memberships_for_portfolio_with_http_info(portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str membership_gid: Globally unique identifier for the membership. (required)
-        :param MembershipsMembershipGidBody body: The updated fields for the membership.
-        :return: MembershipResponseData
+        :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
+        :param str user: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user.
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
+        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
+        :return: PortfolioMembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['membership_gid', 'body']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_membership" % key
+                    " to method get_portfolio_memberships_for_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'membership_gid' is set
-        if ('membership_gid' not in params or
-                params['membership_gid'] is None):
-            raise ValueError("Missing the required parameter `membership_gid` when calling `update_membership`")  # noqa: E501
+        # verify the required parameter 'portfolio_gid' is set
+        if (portfolio_gid is None):
+            raise ValueError("Missing the required parameter `portfolio_gid` when calling `get_portfolio_memberships_for_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'membership_gid' in params:
-            path_params['membership_gid'] = params['membership_gid']  # noqa: E501
+        path_params['portfolio_gid'] = portfolio_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/memberships/{membership_gid}', 'PUT',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/portfolio_memberships', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/portfolios/{portfolio_gid}/portfolio_memberships',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/portfolios/{portfolio_gid}/portfolio_memberships', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='MembershipResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/organization_exports_api.py` & `asana_preview-1.2.40/asana_preview/api/organization_exports_api.py`

 * *Files 16% similar despite different names*

```diff
@@ -12,143 +12,173 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class OrganizationExportsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_organization_export(self, body, **kwargs):  # noqa: E501
+    def create_organization_export(self, body, opts, **kwargs):  # noqa: E501
         """Create an organization export request  # noqa: E501
 
         This method creates a request to export an Organization. Asana will complete the export at some point after you create the request.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_organization_export(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param OrganizationExportsBody body: The organization to export. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param dict body: The organization to export. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: OrganizationExportResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_organization_export_with_http_info(body, **kwargs)  # noqa: E501
+            return self.create_organization_export_with_http_info(body, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_organization_export_with_http_info(body, **kwargs)  # noqa: E501
+            (data) = self.create_organization_export_with_http_info(body, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_organization_export_with_http_info(self, body, **kwargs):  # noqa: E501
+    def create_organization_export_with_http_info(self, body, opts, **kwargs):  # noqa: E501
         """Create an organization export request  # noqa: E501
 
         This method creates a request to export an Organization. Asana will complete the export at some point after you create the request.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_organization_export_with_http_info(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param OrganizationExportsBody body: The organization to export. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param dict body: The organization to export. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: OrganizationExportResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_organization_export" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_organization_export`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/organization_exports', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/organization_exports', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/organization_exports', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='OrganizationExportResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_organization_export(self, organization_export_gid, **kwargs):  # noqa: E501
+    def get_organization_export(self, organization_export_gid, opts, **kwargs):  # noqa: E501
         """Get details on an org export request  # noqa: E501
 
         Returns details of a previously-requested Organization export.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_organization_export(organization_export_gid, async_req=True)
         >>> result = thread.get()
@@ -156,22 +186,22 @@
         :param async_req bool
         :param str organization_export_gid: Globally unique identifier for the organization export. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: OrganizationExportResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_organization_export_with_http_info(organization_export_gid, **kwargs)  # noqa: E501
+            return self.get_organization_export_with_http_info(organization_export_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_organization_export_with_http_info(organization_export_gid, **kwargs)  # noqa: E501
+            (data) = self.get_organization_export_with_http_info(organization_export_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_organization_export_with_http_info(self, organization_export_gid, **kwargs):  # noqa: E501
+    def get_organization_export_with_http_info(self, organization_export_gid, opts, **kwargs):  # noqa: E501
         """Get details on an org export request  # noqa: E501
 
         Returns details of a previously-requested Organization export.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_organization_export_with_http_info(organization_export_gid, async_req=True)
         >>> result = thread.get()
@@ -179,67 +209,106 @@
         :param async_req bool
         :param str organization_export_gid: Globally unique identifier for the organization export. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: OrganizationExportResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['organization_export_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_organization_export" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'organization_export_gid' is set
-        if ('organization_export_gid' not in params or
-                params['organization_export_gid'] is None):
+        if (organization_export_gid is None):
             raise ValueError("Missing the required parameter `organization_export_gid` when calling `get_organization_export`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'organization_export_gid' in params:
-            path_params['organization_export_gid'] = params['organization_export_gid']  # noqa: E501
+        path_params['organization_export_gid'] = organization_export_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/organization_exports/{organization_export_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/organization_exports/{organization_export_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/organization_exports/{organization_export_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='OrganizationExportResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/portfolios_api.py` & `asana_preview-1.2.40/asana_preview/api/portfolios_api.py`

 * *Files 21% similar despite different names*

```diff
@@ -12,17 +12,17 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class PortfoliosApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
@@ -38,21 +38,21 @@
         Custom fields are associated with portfolios by way of custom field settings.  This method creates a setting for the portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_custom_field_setting_for_portfolio(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidAddCustomFieldSettingBody body: Information about the custom field setting. (required)
+        :param dict body: Information about the custom field setting. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :return: CustomFieldSettingResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.add_custom_field_setting_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.add_custom_field_setting_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
             return data
 
     def add_custom_field_setting_for_portfolio_with_http_info(self, body, portfolio_gid, **kwargs):  # noqa: E501
@@ -61,81 +61,119 @@
         Custom fields are associated with portfolios by way of custom field settings.  This method creates a setting for the portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_custom_field_setting_for_portfolio_with_http_info(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidAddCustomFieldSettingBody body: Information about the custom field setting. (required)
+        :param dict body: Information about the custom field setting. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :return: CustomFieldSettingResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'portfolio_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_custom_field_setting_for_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `add_custom_field_setting_for_portfolio`")  # noqa: E501
         # verify the required parameter 'portfolio_gid' is set
-        if ('portfolio_gid' not in params or
-                params['portfolio_gid'] is None):
+        if (portfolio_gid is None):
             raise ValueError("Missing the required parameter `portfolio_gid` when calling `add_custom_field_setting_for_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'portfolio_gid' in params:
-            path_params['portfolio_gid'] = params['portfolio_gid']  # noqa: E501
+        path_params['portfolio_gid'] = portfolio_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/addCustomFieldSetting', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/addCustomFieldSetting', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/portfolios/{portfolio_gid}/addCustomFieldSetting', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='CustomFieldSettingResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -145,21 +183,21 @@
         Add an item to a portfolio. Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_item_for_portfolio(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidAddItemBody body: Information about the item being inserted. (required)
+        :param dict body: Information about the item being inserted. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.add_item_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.add_item_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
             return data
 
     def add_item_for_portfolio_with_http_info(self, body, portfolio_gid, **kwargs):  # noqa: E501
@@ -168,297 +206,409 @@
         Add an item to a portfolio. Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_item_for_portfolio_with_http_info(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidAddItemBody body: Information about the item being inserted. (required)
+        :param dict body: Information about the item being inserted. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'portfolio_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_item_for_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `add_item_for_portfolio`")  # noqa: E501
         # verify the required parameter 'portfolio_gid' is set
-        if ('portfolio_gid' not in params or
-                params['portfolio_gid'] is None):
+        if (portfolio_gid is None):
             raise ValueError("Missing the required parameter `portfolio_gid` when calling `add_item_for_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'portfolio_gid' in params:
-            path_params['portfolio_gid'] = params['portfolio_gid']  # noqa: E501
+        path_params['portfolio_gid'] = portfolio_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/addItem', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/addItem', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/portfolios/{portfolio_gid}/addItem', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def add_members_for_portfolio(self, body, portfolio_gid, **kwargs):  # noqa: E501
+    def add_members_for_portfolio(self, body, portfolio_gid, opts, **kwargs):  # noqa: E501
         """Add users to a portfolio  # noqa: E501
 
         Adds the specified list of users as members of the portfolio. Returns the updated portfolio record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_members_for_portfolio(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidAddMembersBody body: Information about the members being added. (required)
+        :param dict body: Information about the members being added. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.add_members_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
+            return self.add_members_for_portfolio_with_http_info(body, portfolio_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.add_members_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
+            (data) = self.add_members_for_portfolio_with_http_info(body, portfolio_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def add_members_for_portfolio_with_http_info(self, body, portfolio_gid, **kwargs):  # noqa: E501
+    def add_members_for_portfolio_with_http_info(self, body, portfolio_gid, opts, **kwargs):  # noqa: E501
         """Add users to a portfolio  # noqa: E501
 
         Adds the specified list of users as members of the portfolio. Returns the updated portfolio record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_members_for_portfolio_with_http_info(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidAddMembersBody body: Information about the members being added. (required)
+        :param dict body: Information about the members being added. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'portfolio_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_members_for_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `add_members_for_portfolio`")  # noqa: E501
         # verify the required parameter 'portfolio_gid' is set
-        if ('portfolio_gid' not in params or
-                params['portfolio_gid'] is None):
+        if (portfolio_gid is None):
             raise ValueError("Missing the required parameter `portfolio_gid` when calling `add_members_for_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'portfolio_gid' in params:
-            path_params['portfolio_gid'] = params['portfolio_gid']  # noqa: E501
+        path_params['portfolio_gid'] = portfolio_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/addMembers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/addMembers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/portfolios/{portfolio_gid}/addMembers', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PortfolioResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create_portfolio(self, body, **kwargs):  # noqa: E501
+    def create_portfolio(self, body, opts, **kwargs):  # noqa: E501
         """Create a portfolio  # noqa: E501
 
         Creates a new portfolio in the given workspace with the supplied name.  Note that portfolios created in the Asana UI may have some state (like the “Priority” custom field) which is automatically added to the portfolio when it is created. Portfolios created via our API will *not* be created with the same initial state to allow integrations to create their own starting state on a portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_portfolio(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfoliosBody body: The portfolio to create. (required)
+        :param dict body: The portfolio to create. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_portfolio_with_http_info(body, **kwargs)  # noqa: E501
+            return self.create_portfolio_with_http_info(body, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_portfolio_with_http_info(body, **kwargs)  # noqa: E501
+            (data) = self.create_portfolio_with_http_info(body, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_portfolio_with_http_info(self, body, **kwargs):  # noqa: E501
+    def create_portfolio_with_http_info(self, body, opts, **kwargs):  # noqa: E501
         """Create a portfolio  # noqa: E501
 
         Creates a new portfolio in the given workspace with the supplied name.  Note that portfolios created in the Asana UI may have some state (like the “Priority” custom field) which is automatically added to the portfolio when it is created. Portfolios created via our API will *not* be created with the same initial state to allow integrations to create their own starting state on a portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_portfolio_with_http_info(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfoliosBody body: The portfolio to create. (required)
+        :param dict body: The portfolio to create. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/portfolios', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/portfolios', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PortfolioResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -473,15 +623,15 @@
 
         :param async_req bool
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.delete_portfolio_with_http_info(portfolio_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_portfolio_with_http_info(portfolio_gid, **kwargs)  # noqa: E501
             return data
 
     def delete_portfolio_with_http_info(self, portfolio_gid, **kwargs):  # noqa: E501
@@ -495,73 +645,114 @@
 
         :param async_req bool
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['portfolio_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'portfolio_gid' is set
-        if ('portfolio_gid' not in params or
-                params['portfolio_gid'] is None):
+        if (portfolio_gid is None):
             raise ValueError("Missing the required parameter `portfolio_gid` when calling `delete_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'portfolio_gid' in params:
-            path_params['portfolio_gid'] = params['portfolio_gid']  # noqa: E501
+        path_params['portfolio_gid'] = portfolio_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios/{portfolio_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/portfolios/{portfolio_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/portfolios/{portfolio_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_items_for_portfolio(self, portfolio_gid, **kwargs):  # noqa: E501
+    def get_items_for_portfolio(self, portfolio_gid, opts, **kwargs):  # noqa: E501
         """Get portfolio items  # noqa: E501
 
         Get a list of the items in compact form in a portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_items_for_portfolio(portfolio_gid, async_req=True)
         >>> result = thread.get()
@@ -571,22 +762,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_items_for_portfolio_with_http_info(portfolio_gid, **kwargs)  # noqa: E501
+            return self.get_items_for_portfolio_with_http_info(portfolio_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_items_for_portfolio_with_http_info(portfolio_gid, **kwargs)  # noqa: E501
+            (data) = self.get_items_for_portfolio_with_http_info(portfolio_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_items_for_portfolio_with_http_info(self, portfolio_gid, **kwargs):  # noqa: E501
+    def get_items_for_portfolio_with_http_info(self, portfolio_gid, opts, **kwargs):  # noqa: E501
         """Get portfolio items  # noqa: E501
 
         Get a list of the items in compact form in a portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_items_for_portfolio_with_http_info(portfolio_gid, async_req=True)
         >>> result = thread.get()
@@ -596,80 +787,118 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['portfolio_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_items_for_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'portfolio_gid' is set
-        if ('portfolio_gid' not in params or
-                params['portfolio_gid'] is None):
+        if (portfolio_gid is None):
             raise ValueError("Missing the required parameter `portfolio_gid` when calling `get_items_for_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'portfolio_gid' in params:
-            path_params['portfolio_gid'] = params['portfolio_gid']  # noqa: E501
+        path_params['portfolio_gid'] = portfolio_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/items', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/portfolios/{portfolio_gid}/items',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/portfolios/{portfolio_gid}/items', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_portfolio(self, portfolio_gid, **kwargs):  # noqa: E501
+    def get_portfolio(self, portfolio_gid, opts, **kwargs):  # noqa: E501
         """Get a portfolio  # noqa: E501
 
         Returns the complete portfolio record for a single portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_portfolio(portfolio_gid, async_req=True)
         >>> result = thread.get()
@@ -677,22 +906,22 @@
         :param async_req bool
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_portfolio_with_http_info(portfolio_gid, **kwargs)  # noqa: E501
+            return self.get_portfolio_with_http_info(portfolio_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_portfolio_with_http_info(portfolio_gid, **kwargs)  # noqa: E501
+            (data) = self.get_portfolio_with_http_info(portfolio_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_portfolio_with_http_info(self, portfolio_gid, **kwargs):  # noqa: E501
+    def get_portfolio_with_http_info(self, portfolio_gid, opts, **kwargs):  # noqa: E501
         """Get a portfolio  # noqa: E501
 
         Returns the complete portfolio record for a single portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_portfolio_with_http_info(portfolio_gid, async_req=True)
         >>> result = thread.get()
@@ -700,180 +929,255 @@
         :param async_req bool
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['portfolio_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'portfolio_gid' is set
-        if ('portfolio_gid' not in params or
-                params['portfolio_gid'] is None):
+        if (portfolio_gid is None):
             raise ValueError("Missing the required parameter `portfolio_gid` when calling `get_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'portfolio_gid' in params:
-            path_params['portfolio_gid'] = params['portfolio_gid']  # noqa: E501
+        path_params['portfolio_gid'] = portfolio_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios/{portfolio_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/portfolios/{portfolio_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/portfolios/{portfolio_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PortfolioResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_portfolios(self, workspace, **kwargs):  # noqa: E501
+    def get_portfolios(self, workspace, opts, **kwargs):  # noqa: E501
         """Get multiple portfolios  # noqa: E501
 
         Returns a list of the portfolios in compact representation that are owned by the current API user.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_portfolios(workspace, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str workspace: The workspace or organization to filter portfolios on. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param str owner: The user who owns the portfolio. Currently, API users can  only get a list of portfolios that they themselves own, unless the request is made from a Service Account. In the case of a Service Account, if this parameter is specified, then all portfolios owned by this parameter are returned. Otherwise, all portfolios across the workspace are returned.
+        :param str owner: The user who owns the portfolio. Currently, API users can only get a list of portfolios that they themselves own, unless the request is made from a Service Account. In the case of a Service Account, if this parameter is specified, then all portfolios owned by this parameter are returned. Otherwise, all portfolios across the workspace are returned.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_portfolios_with_http_info(workspace, **kwargs)  # noqa: E501
+            return self.get_portfolios_with_http_info(workspace, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_portfolios_with_http_info(workspace, **kwargs)  # noqa: E501
+            (data) = self.get_portfolios_with_http_info(workspace, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_portfolios_with_http_info(self, workspace, **kwargs):  # noqa: E501
+    def get_portfolios_with_http_info(self, workspace, opts, **kwargs):  # noqa: E501
         """Get multiple portfolios  # noqa: E501
 
         Returns a list of the portfolios in compact representation that are owned by the current API user.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_portfolios_with_http_info(workspace, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str workspace: The workspace or organization to filter portfolios on. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param str owner: The user who owns the portfolio. Currently, API users can  only get a list of portfolios that they themselves own, unless the request is made from a Service Account. In the case of a Service Account, if this parameter is specified, then all portfolios owned by this parameter are returned. Otherwise, all portfolios across the workspace are returned.
+        :param str owner: The user who owns the portfolio. Currently, API users can only get a list of portfolios that they themselves own, unless the request is made from a Service Account. In the case of a Service Account, if this parameter is specified, then all portfolios owned by this parameter are returned. Otherwise, all portfolios across the workspace are returned.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace', 'limit', 'offset', 'owner', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_portfolios" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'workspace' is set
-        if ('workspace' not in params or
-                params['workspace'] is None):
+        if (workspace is None):
             raise ValueError("Missing the required parameter `workspace` when calling `get_portfolios`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'owner' in params:
-            query_params.append(('owner', params['owner']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+        query_params['workspace'] = workspace
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/portfolios',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/portfolios', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PortfolioResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -883,21 +1187,21 @@
         Removes a custom field setting from a portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_custom_field_setting_for_portfolio(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidRemoveCustomFieldSettingBody body: Information about the custom field setting being removed. (required)
+        :param dict body: Information about the custom field setting being removed. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.remove_custom_field_setting_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.remove_custom_field_setting_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
             return data
 
     def remove_custom_field_setting_for_portfolio_with_http_info(self, body, portfolio_gid, **kwargs):  # noqa: E501
@@ -906,81 +1210,119 @@
         Removes a custom field setting from a portfolio.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_custom_field_setting_for_portfolio_with_http_info(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidRemoveCustomFieldSettingBody body: Information about the custom field setting being removed. (required)
+        :param dict body: Information about the custom field setting being removed. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'portfolio_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_custom_field_setting_for_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `remove_custom_field_setting_for_portfolio`")  # noqa: E501
         # verify the required parameter 'portfolio_gid' is set
-        if ('portfolio_gid' not in params or
-                params['portfolio_gid'] is None):
+        if (portfolio_gid is None):
             raise ValueError("Missing the required parameter `portfolio_gid` when calling `remove_custom_field_setting_for_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'portfolio_gid' in params:
-            path_params['portfolio_gid'] = params['portfolio_gid']  # noqa: E501
+        path_params['portfolio_gid'] = portfolio_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/removeCustomFieldSetting', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/removeCustomFieldSetting', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/portfolios/{portfolio_gid}/removeCustomFieldSetting', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -990,21 +1332,21 @@
         Remove an item from a portfolio. Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_item_for_portfolio(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidRemoveItemBody body: Information about the item being removed. (required)
+        :param dict body: Information about the item being removed. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.remove_item_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.remove_item_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
             return data
 
     def remove_item_for_portfolio_with_http_info(self, body, portfolio_gid, **kwargs):  # noqa: E501
@@ -1013,304 +1355,414 @@
         Remove an item from a portfolio. Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_item_for_portfolio_with_http_info(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidRemoveItemBody body: Information about the item being removed. (required)
+        :param dict body: Information about the item being removed. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'portfolio_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_item_for_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `remove_item_for_portfolio`")  # noqa: E501
         # verify the required parameter 'portfolio_gid' is set
-        if ('portfolio_gid' not in params or
-                params['portfolio_gid'] is None):
+        if (portfolio_gid is None):
             raise ValueError("Missing the required parameter `portfolio_gid` when calling `remove_item_for_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'portfolio_gid' in params:
-            path_params['portfolio_gid'] = params['portfolio_gid']  # noqa: E501
+        path_params['portfolio_gid'] = portfolio_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/removeItem', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/removeItem', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/portfolios/{portfolio_gid}/removeItem', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def remove_members_for_portfolio(self, body, portfolio_gid, **kwargs):  # noqa: E501
+    def remove_members_for_portfolio(self, body, portfolio_gid, opts, **kwargs):  # noqa: E501
         """Remove users from a portfolio  # noqa: E501
 
         Removes the specified list of users from members of the portfolio. Returns the updated portfolio record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_members_for_portfolio(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidRemoveMembersBody body: Information about the members being removed. (required)
+        :param dict body: Information about the members being removed. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.remove_members_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
+            return self.remove_members_for_portfolio_with_http_info(body, portfolio_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.remove_members_for_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
+            (data) = self.remove_members_for_portfolio_with_http_info(body, portfolio_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def remove_members_for_portfolio_with_http_info(self, body, portfolio_gid, **kwargs):  # noqa: E501
+    def remove_members_for_portfolio_with_http_info(self, body, portfolio_gid, opts, **kwargs):  # noqa: E501
         """Remove users from a portfolio  # noqa: E501
 
         Removes the specified list of users from members of the portfolio. Returns the updated portfolio record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_members_for_portfolio_with_http_info(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfolioGidRemoveMembersBody body: Information about the members being removed. (required)
+        :param dict body: Information about the members being removed. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'portfolio_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_members_for_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `remove_members_for_portfolio`")  # noqa: E501
         # verify the required parameter 'portfolio_gid' is set
-        if ('portfolio_gid' not in params or
-                params['portfolio_gid'] is None):
+        if (portfolio_gid is None):
             raise ValueError("Missing the required parameter `portfolio_gid` when calling `remove_members_for_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'portfolio_gid' in params:
-            path_params['portfolio_gid'] = params['portfolio_gid']  # noqa: E501
+        path_params['portfolio_gid'] = portfolio_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/removeMembers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/portfolios/{portfolio_gid}/removeMembers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/portfolios/{portfolio_gid}/removeMembers', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PortfolioResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_portfolio(self, body, portfolio_gid, **kwargs):  # noqa: E501
+    def update_portfolio(self, body, portfolio_gid, opts, **kwargs):  # noqa: E501
         """Update a portfolio  # noqa: E501
 
         An existing portfolio can be updated by making a PUT request on the URL for that portfolio. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated portfolio record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_portfolio(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfoliosPortfolioGidBody body: The updated fields for the portfolio. (required)
+        :param dict body: The updated fields for the portfolio. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
+            return self.update_portfolio_with_http_info(body, portfolio_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_portfolio_with_http_info(body, portfolio_gid, **kwargs)  # noqa: E501
+            (data) = self.update_portfolio_with_http_info(body, portfolio_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_portfolio_with_http_info(self, body, portfolio_gid, **kwargs):  # noqa: E501
+    def update_portfolio_with_http_info(self, body, portfolio_gid, opts, **kwargs):  # noqa: E501
         """Update a portfolio  # noqa: E501
 
         An existing portfolio can be updated by making a PUT request on the URL for that portfolio. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated portfolio record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_portfolio_with_http_info(body, portfolio_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param PortfoliosPortfolioGidBody body: The updated fields for the portfolio. (required)
+        :param dict body: The updated fields for the portfolio. (required)
         :param str portfolio_gid: Globally unique identifier for the portfolio. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: PortfolioResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'portfolio_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_portfolio" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `update_portfolio`")  # noqa: E501
         # verify the required parameter 'portfolio_gid' is set
-        if ('portfolio_gid' not in params or
-                params['portfolio_gid'] is None):
+        if (portfolio_gid is None):
             raise ValueError("Missing the required parameter `portfolio_gid` when calling `update_portfolio`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'portfolio_gid' in params:
-            path_params['portfolio_gid'] = params['portfolio_gid']  # noqa: E501
+        path_params['portfolio_gid'] = portfolio_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/portfolios/{portfolio_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/portfolios/{portfolio_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/portfolios/{portfolio_gid}', 'PUT',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='PortfolioResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/project_briefs_api.py` & `asana_preview-1.2.40/asana_preview/api/project_briefs_api.py`

 * *Files 26% similar despite different names*

```diff
@@ -12,135 +12,171 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class ProjectBriefsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_project_brief(self, body, project_gid, **kwargs):  # noqa: E501
+    def create_project_brief(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Create a project brief  # noqa: E501
 
         Creates a new project brief.  Returns the full record of the newly created project brief.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_project_brief(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidProjectBriefsBody body: The project brief to create. (required)
+        :param dict body: The project brief to create. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectBriefResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_project_brief_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            return self.create_project_brief_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_project_brief_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            (data) = self.create_project_brief_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_project_brief_with_http_info(self, body, project_gid, **kwargs):  # noqa: E501
+    def create_project_brief_with_http_info(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Create a project brief  # noqa: E501
 
         Creates a new project brief.  Returns the full record of the newly created project brief.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_project_brief_with_http_info(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidProjectBriefsBody body: The project brief to create. (required)
+        :param dict body: The project brief to create. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectBriefResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'project_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_project_brief" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_project_brief`")  # noqa: E501
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `create_project_brief`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/project_briefs', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/project_briefs', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/project_briefs', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectBriefResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -155,15 +191,15 @@
 
         :param async_req bool
         :param str project_brief_gid: Globally unique identifier for the project brief. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.delete_project_brief_with_http_info(project_brief_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_project_brief_with_http_info(project_brief_gid, **kwargs)  # noqa: E501
             return data
 
     def delete_project_brief_with_http_info(self, project_brief_gid, **kwargs):  # noqa: E501
@@ -177,73 +213,114 @@
 
         :param async_req bool
         :param str project_brief_gid: Globally unique identifier for the project brief. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_brief_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_project_brief" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_brief_gid' is set
-        if ('project_brief_gid' not in params or
-                params['project_brief_gid'] is None):
+        if (project_brief_gid is None):
             raise ValueError("Missing the required parameter `project_brief_gid` when calling `delete_project_brief`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_brief_gid' in params:
-            path_params['project_brief_gid'] = params['project_brief_gid']  # noqa: E501
+        path_params['project_brief_gid'] = project_brief_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/project_briefs/{project_brief_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/project_briefs/{project_brief_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/project_briefs/{project_brief_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_project_brief(self, project_brief_gid, **kwargs):  # noqa: E501
+    def get_project_brief(self, project_brief_gid, opts, **kwargs):  # noqa: E501
         """Get a project brief  # noqa: E501
 
         Get the full record for a project brief.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project_brief(project_brief_gid, async_req=True)
         >>> result = thread.get()
@@ -251,22 +328,22 @@
         :param async_req bool
         :param str project_brief_gid: Globally unique identifier for the project brief. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectBriefResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_project_brief_with_http_info(project_brief_gid, **kwargs)  # noqa: E501
+            return self.get_project_brief_with_http_info(project_brief_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_project_brief_with_http_info(project_brief_gid, **kwargs)  # noqa: E501
+            (data) = self.get_project_brief_with_http_info(project_brief_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_project_brief_with_http_info(self, project_brief_gid, **kwargs):  # noqa: E501
+    def get_project_brief_with_http_info(self, project_brief_gid, opts, **kwargs):  # noqa: E501
         """Get a project brief  # noqa: E501
 
         Get the full record for a project brief.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project_brief_with_http_info(project_brief_gid, async_req=True)
         >>> result = thread.get()
@@ -274,179 +351,254 @@
         :param async_req bool
         :param str project_brief_gid: Globally unique identifier for the project brief. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectBriefResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_brief_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_project_brief" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_brief_gid' is set
-        if ('project_brief_gid' not in params or
-                params['project_brief_gid'] is None):
+        if (project_brief_gid is None):
             raise ValueError("Missing the required parameter `project_brief_gid` when calling `get_project_brief`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_brief_gid' in params:
-            path_params['project_brief_gid'] = params['project_brief_gid']  # noqa: E501
+        path_params['project_brief_gid'] = project_brief_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/project_briefs/{project_brief_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/project_briefs/{project_brief_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/project_briefs/{project_brief_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectBriefResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_project_brief(self, body, project_brief_gid, **kwargs):  # noqa: E501
+    def update_project_brief(self, body, project_brief_gid, opts, **kwargs):  # noqa: E501
         """Update a project brief  # noqa: E501
 
         An existing project brief can be updated by making a PUT request on the URL for that project brief. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated project brief record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_project_brief(body, project_brief_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectBriefsProjectBriefGidBody body: The updated fields for the project brief. (required)
+        :param dict body: The updated fields for the project brief. (required)
         :param str project_brief_gid: Globally unique identifier for the project brief. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectBriefResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_project_brief_with_http_info(body, project_brief_gid, **kwargs)  # noqa: E501
+            return self.update_project_brief_with_http_info(body, project_brief_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_project_brief_with_http_info(body, project_brief_gid, **kwargs)  # noqa: E501
+            (data) = self.update_project_brief_with_http_info(body, project_brief_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_project_brief_with_http_info(self, body, project_brief_gid, **kwargs):  # noqa: E501
+    def update_project_brief_with_http_info(self, body, project_brief_gid, opts, **kwargs):  # noqa: E501
         """Update a project brief  # noqa: E501
 
         An existing project brief can be updated by making a PUT request on the URL for that project brief. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated project brief record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_project_brief_with_http_info(body, project_brief_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectBriefsProjectBriefGidBody body: The updated fields for the project brief. (required)
+        :param dict body: The updated fields for the project brief. (required)
         :param str project_brief_gid: Globally unique identifier for the project brief. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectBriefResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'project_brief_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_project_brief" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `update_project_brief`")  # noqa: E501
         # verify the required parameter 'project_brief_gid' is set
-        if ('project_brief_gid' not in params or
-                params['project_brief_gid'] is None):
+        if (project_brief_gid is None):
             raise ValueError("Missing the required parameter `project_brief_gid` when calling `update_project_brief`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_brief_gid' in params:
-            path_params['project_brief_gid'] = params['project_brief_gid']  # noqa: E501
+        path_params['project_brief_gid'] = project_brief_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/project_briefs/{project_brief_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/project_briefs/{project_brief_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/project_briefs/{project_brief_gid}', 'PUT',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectBriefResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/project_templates_api.py` & `asana_preview-1.2.40/asana_preview/api/project_templates_api.py`

 * *Files 22% similar despite different names*

```diff
@@ -12,17 +12,17 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class ProjectTemplatesApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
@@ -43,15 +43,15 @@
 
         :param async_req bool
         :param str project_template_gid: Globally unique identifier for the project template. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.delete_project_template_with_http_info(project_template_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_project_template_with_http_info(project_template_gid, **kwargs)  # noqa: E501
             return data
 
     def delete_project_template_with_http_info(self, project_template_gid, **kwargs):  # noqa: E501
@@ -65,73 +65,114 @@
 
         :param async_req bool
         :param str project_template_gid: Globally unique identifier for the project template. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_template_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_project_template" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_template_gid' is set
-        if ('project_template_gid' not in params or
-                params['project_template_gid'] is None):
+        if (project_template_gid is None):
             raise ValueError("Missing the required parameter `project_template_gid` when calling `delete_project_template`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_template_gid' in params:
-            path_params['project_template_gid'] = params['project_template_gid']  # noqa: E501
+        path_params['project_template_gid'] = project_template_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/project_templates/{project_template_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/project_templates/{project_template_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/project_templates/{project_template_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_project_template(self, project_template_gid, **kwargs):  # noqa: E501
+    def get_project_template(self, project_template_gid, opts, **kwargs):  # noqa: E501
         """Get a project template  # noqa: E501
 
         Returns the complete project template record for a single project template.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project_template(project_template_gid, async_req=True)
         >>> result = thread.get()
@@ -139,22 +180,22 @@
         :param async_req bool
         :param str project_template_gid: Globally unique identifier for the project template. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectTemplateResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_project_template_with_http_info(project_template_gid, **kwargs)  # noqa: E501
+            return self.get_project_template_with_http_info(project_template_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_project_template_with_http_info(project_template_gid, **kwargs)  # noqa: E501
+            (data) = self.get_project_template_with_http_info(project_template_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_project_template_with_http_info(self, project_template_gid, **kwargs):  # noqa: E501
+    def get_project_template_with_http_info(self, project_template_gid, opts, **kwargs):  # noqa: E501
         """Get a project template  # noqa: E501
 
         Returns the complete project template record for a single project template.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project_template_with_http_info(project_template_gid, async_req=True)
         >>> result = thread.get()
@@ -162,76 +203,115 @@
         :param async_req bool
         :param str project_template_gid: Globally unique identifier for the project template. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectTemplateResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_template_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_project_template" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_template_gid' is set
-        if ('project_template_gid' not in params or
-                params['project_template_gid'] is None):
+        if (project_template_gid is None):
             raise ValueError("Missing the required parameter `project_template_gid` when calling `get_project_template`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_template_gid' in params:
-            path_params['project_template_gid'] = params['project_template_gid']  # noqa: E501
+        path_params['project_template_gid'] = project_template_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/project_templates/{project_template_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/project_templates/{project_template_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/project_templates/{project_template_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectTemplateResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_project_templates(self, **kwargs):  # noqa: E501
+    def get_project_templates(self, opts, **kwargs):  # noqa: E501
         """Get multiple project templates  # noqa: E501
 
         Returns the compact project template records for all project templates in the given team or workspace.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project_templates(async_req=True)
         >>> result = thread.get()
@@ -242,22 +322,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectTemplateResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_project_templates_with_http_info(**kwargs)  # noqa: E501
+            return self.get_project_templates_with_http_info(opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_project_templates_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_project_templates_with_http_info(opts, **kwargs)  # noqa: E501
             return data
 
-    def get_project_templates_with_http_info(self, **kwargs):  # noqa: E501
+    def get_project_templates_with_http_info(self, opts, **kwargs):  # noqa: E501
         """Get multiple project templates  # noqa: E501
 
         Returns the compact project template records for all project templates in the given team or workspace.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project_templates_with_http_info(async_req=True)
         >>> result = thread.get()
@@ -268,20 +348,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectTemplateResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace', 'team', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_project_templates" % key
@@ -289,57 +371,91 @@
             params[key] = val
         del params['kwargs']
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'team' in params:
-            query_params.append(('team', params['team']))  # noqa: E501
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/project_templates', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/project_templates',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/project_templates', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectTemplateResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_project_templates_for_team(self, team_gid, **kwargs):  # noqa: E501
+    def get_project_templates_for_team(self, team_gid, opts, **kwargs):  # noqa: E501
         """Get a team's project templates  # noqa: E501
 
         Returns the compact project template records for all project templates in the team.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project_templates_for_team(team_gid, async_req=True)
         >>> result = thread.get()
@@ -349,22 +465,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectTemplateResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_project_templates_for_team_with_http_info(team_gid, **kwargs)  # noqa: E501
+            return self.get_project_templates_for_team_with_http_info(team_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_project_templates_for_team_with_http_info(team_gid, **kwargs)  # noqa: E501
+            (data) = self.get_project_templates_for_team_with_http_info(team_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_project_templates_for_team_with_http_info(self, team_gid, **kwargs):  # noqa: E501
+    def get_project_templates_for_team_with_http_info(self, team_gid, opts, **kwargs):  # noqa: E501
         """Get a team's project templates  # noqa: E501
 
         Returns the compact project template records for all project templates in the team.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project_templates_for_team_with_http_info(team_gid, async_req=True)
         >>> result = thread.get()
@@ -374,179 +490,254 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectTemplateResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['team_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_project_templates_for_team" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'team_gid' is set
-        if ('team_gid' not in params or
-                params['team_gid'] is None):
+        if (team_gid is None):
             raise ValueError("Missing the required parameter `team_gid` when calling `get_project_templates_for_team`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'team_gid' in params:
-            path_params['team_gid'] = params['team_gid']  # noqa: E501
+        path_params['team_gid'] = team_gid  # noqa: E501
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/teams/{team_gid}/project_templates', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/teams/{team_gid}/project_templates',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/teams/{team_gid}/project_templates', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectTemplateResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def instantiate_project(self, project_template_gid, **kwargs):  # noqa: E501
+    def instantiate_project(self, project_template_gid, opts, **kwargs):  # noqa: E501
         """Instantiate a project from a project template  # noqa: E501
 
         Creates and returns a job that will asynchronously handle the project instantiation.  To form this request, it is recommended to first make a request to [get a project template](/reference/getprojecttemplate). Then, from the response, copy the `gid` from the object in the `requested_dates` array. This `gid` should be used in `requested_dates` to instantiate a project.  _Note: The body of this request will differ if your workspace is an organization. To determine if your workspace is an organization, use the [is_organization](/reference/workspaces) parameter._  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.instantiate_project(project_template_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_template_gid: Globally unique identifier for the project template. (required)
-        :param ProjectTemplateGidInstantiateProjectBody body: Describes the inputs used for instantiating a project, such as the resulting project's name, which team it should be created in, and values for date variables.
+        :param dict body: Describes the inputs used for instantiating a project, such as the resulting project's name, which team it should be created in, and values for date variables.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.instantiate_project_with_http_info(project_template_gid, **kwargs)  # noqa: E501
+            return self.instantiate_project_with_http_info(project_template_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.instantiate_project_with_http_info(project_template_gid, **kwargs)  # noqa: E501
+            (data) = self.instantiate_project_with_http_info(project_template_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def instantiate_project_with_http_info(self, project_template_gid, **kwargs):  # noqa: E501
+    def instantiate_project_with_http_info(self, project_template_gid, opts, **kwargs):  # noqa: E501
         """Instantiate a project from a project template  # noqa: E501
 
         Creates and returns a job that will asynchronously handle the project instantiation.  To form this request, it is recommended to first make a request to [get a project template](/reference/getprojecttemplate). Then, from the response, copy the `gid` from the object in the `requested_dates` array. This `gid` should be used in `requested_dates` to instantiate a project.  _Note: The body of this request will differ if your workspace is an organization. To determine if your workspace is an organization, use the [is_organization](/reference/workspaces) parameter._  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.instantiate_project_with_http_info(project_template_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_template_gid: Globally unique identifier for the project template. (required)
-        :param ProjectTemplateGidInstantiateProjectBody body: Describes the inputs used for instantiating a project, such as the resulting project's name, which team it should be created in, and values for date variables.
+        :param dict body: Describes the inputs used for instantiating a project, such as the resulting project's name, which team it should be created in, and values for date variables.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_template_gid', 'body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method instantiate_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_template_gid' is set
-        if ('project_template_gid' not in params or
-                params['project_template_gid'] is None):
+        if (project_template_gid is None):
             raise ValueError("Missing the required parameter `project_template_gid` when calling `instantiate_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_template_gid' in params:
-            path_params['project_template_gid'] = params['project_template_gid']  # noqa: E501
+        path_params['project_template_gid'] = project_template_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/project_templates/{project_template_gid}/instantiateProject', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/project_templates/{project_template_gid}/instantiateProject', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/project_templates/{project_template_gid}/instantiateProject', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='JobResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/projects_api.py` & `asana_preview-1.2.40/asana_preview/api/projects_api.py`

 * *Files 19% similar despite different names*

```diff
@@ -12,682 +12,905 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class ProjectsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def add_custom_field_setting_for_project(self, body, project_gid, **kwargs):  # noqa: E501
+    def add_custom_field_setting_for_project(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Add a custom field to a project  # noqa: E501
 
         Custom fields are associated with projects by way of custom field settings.  This method creates a setting for the project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_custom_field_setting_for_project(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidAddCustomFieldSettingBody body: Information about the custom field setting. (required)
+        :param dict body: Information about the custom field setting. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
+        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: CustomFieldSettingResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.add_custom_field_setting_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            return self.add_custom_field_setting_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.add_custom_field_setting_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            (data) = self.add_custom_field_setting_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def add_custom_field_setting_for_project_with_http_info(self, body, project_gid, **kwargs):  # noqa: E501
+    def add_custom_field_setting_for_project_with_http_info(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Add a custom field to a project  # noqa: E501
 
         Custom fields are associated with projects by way of custom field settings.  This method creates a setting for the project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_custom_field_setting_for_project_with_http_info(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidAddCustomFieldSettingBody body: Information about the custom field setting. (required)
+        :param dict body: Information about the custom field setting. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
+        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: CustomFieldSettingResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'project_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_custom_field_setting_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `add_custom_field_setting_for_project`")  # noqa: E501
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `add_custom_field_setting_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/addCustomFieldSetting', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/addCustomFieldSetting', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/addCustomFieldSetting', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='CustomFieldSettingResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def add_followers_for_project(self, body, project_gid, **kwargs):  # noqa: E501
+    def add_followers_for_project(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Add followers to a project  # noqa: E501
 
         Adds the specified list of users as followers to the project. Followers are a subset of members who have opted in to receive \"tasks added\" notifications for a project. Therefore, if the users are not already members of the project, they will also become members as a result of this operation. Returns the updated project record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_followers_for_project(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidAddFollowersBody body: Information about the followers being added. (required)
+        :param dict body: Information about the followers being added. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.add_followers_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            return self.add_followers_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.add_followers_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            (data) = self.add_followers_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def add_followers_for_project_with_http_info(self, body, project_gid, **kwargs):  # noqa: E501
+    def add_followers_for_project_with_http_info(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Add followers to a project  # noqa: E501
 
         Adds the specified list of users as followers to the project. Followers are a subset of members who have opted in to receive \"tasks added\" notifications for a project. Therefore, if the users are not already members of the project, they will also become members as a result of this operation. Returns the updated project record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_followers_for_project_with_http_info(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidAddFollowersBody body: Information about the followers being added. (required)
+        :param dict body: Information about the followers being added. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'project_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_followers_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `add_followers_for_project`")  # noqa: E501
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `add_followers_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/addFollowers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/addFollowers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/addFollowers', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def add_members_for_project(self, body, project_gid, **kwargs):  # noqa: E501
+    def add_members_for_project(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Add users to a project  # noqa: E501
 
         Adds the specified list of users as members of the project. Note that a user being added as a member may also be added as a *follower* as a result of this operation. This is because the user's default notification settings (i.e., in the \"Notifcations\" tab of \"My Profile Settings\") will override this endpoint's default behavior of setting \"Tasks added\" notifications to `false`. Returns the updated project record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_members_for_project(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidAddMembersBody body: Information about the members being added. (required)
+        :param dict body: Information about the members being added. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.add_members_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            return self.add_members_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.add_members_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            (data) = self.add_members_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def add_members_for_project_with_http_info(self, body, project_gid, **kwargs):  # noqa: E501
+    def add_members_for_project_with_http_info(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Add users to a project  # noqa: E501
 
         Adds the specified list of users as members of the project. Note that a user being added as a member may also be added as a *follower* as a result of this operation. This is because the user's default notification settings (i.e., in the \"Notifcations\" tab of \"My Profile Settings\") will override this endpoint's default behavior of setting \"Tasks added\" notifications to `false`. Returns the updated project record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_members_for_project_with_http_info(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidAddMembersBody body: Information about the members being added. (required)
+        :param dict body: Information about the members being added. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'project_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_members_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `add_members_for_project`")  # noqa: E501
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `add_members_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/addMembers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/addMembers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/addMembers', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create_project(self, body, **kwargs):  # noqa: E501
+    def create_project(self, body, opts, **kwargs):  # noqa: E501
         """Create a project  # noqa: E501
 
         Create a new project in a workspace or team.  Every project is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the `workspace` parameter regardless of whether or not it is an organization.  If the workspace for your project is an organization, you must also supply a `team` to share the project with.  Returns the full record of the newly created project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_project(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectsBody body: The project to create. (required)
+        :param dict body: The project to create. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_project_with_http_info(body, **kwargs)  # noqa: E501
+            return self.create_project_with_http_info(body, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_project_with_http_info(body, **kwargs)  # noqa: E501
+            (data) = self.create_project_with_http_info(body, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_project_with_http_info(self, body, **kwargs):  # noqa: E501
+    def create_project_with_http_info(self, body, opts, **kwargs):  # noqa: E501
         """Create a project  # noqa: E501
 
         Create a new project in a workspace or team.  Every project is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the `workspace` parameter regardless of whether or not it is an organization.  If the workspace for your project is an organization, you must also supply a `team` to share the project with.  Returns the full record of the newly created project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_project_with_http_info(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectsBody body: The project to create. (required)
+        :param dict body: The project to create. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create_project_for_team(self, body, team_gid, **kwargs):  # noqa: E501
+    def create_project_for_team(self, body, team_gid, opts, **kwargs):  # noqa: E501
         """Create a project in a team  # noqa: E501
 
         Creates a project shared with the given team.  Returns the full record of the newly created project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_project_for_team(body, team_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TeamGidProjectsBody body: The new project to create. (required)
+        :param dict body: The new project to create. (required)
         :param str team_gid: Globally unique identifier for the team. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_project_for_team_with_http_info(body, team_gid, **kwargs)  # noqa: E501
+            return self.create_project_for_team_with_http_info(body, team_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_project_for_team_with_http_info(body, team_gid, **kwargs)  # noqa: E501
+            (data) = self.create_project_for_team_with_http_info(body, team_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_project_for_team_with_http_info(self, body, team_gid, **kwargs):  # noqa: E501
+    def create_project_for_team_with_http_info(self, body, team_gid, opts, **kwargs):  # noqa: E501
         """Create a project in a team  # noqa: E501
 
         Creates a project shared with the given team.  Returns the full record of the newly created project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_project_for_team_with_http_info(body, team_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TeamGidProjectsBody body: The new project to create. (required)
+        :param dict body: The new project to create. (required)
         :param str team_gid: Globally unique identifier for the team. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'team_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_project_for_team" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_project_for_team`")  # noqa: E501
         # verify the required parameter 'team_gid' is set
-        if ('team_gid' not in params or
-                params['team_gid'] is None):
+        if (team_gid is None):
             raise ValueError("Missing the required parameter `team_gid` when calling `create_project_for_team`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'team_gid' in params:
-            path_params['team_gid'] = params['team_gid']  # noqa: E501
+        path_params['team_gid'] = team_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/teams/{team_gid}/projects', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/teams/{team_gid}/projects', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/teams/{team_gid}/projects', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create_project_for_workspace(self, body, workspace_gid, **kwargs):  # noqa: E501
+    def create_project_for_workspace(self, body, workspace_gid, opts, **kwargs):  # noqa: E501
         """Create a project in a workspace  # noqa: E501
 
         Creates a project in the workspace.  If the workspace for your project is an organization, you must also supply a team to share the project with.  Returns the full record of the newly created project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_project_for_workspace(body, workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param WorkspaceGidProjectsBody body: The new project to create. (required)
+        :param dict body: The new project to create. (required)
         :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_project_for_workspace_with_http_info(body, workspace_gid, **kwargs)  # noqa: E501
+            return self.create_project_for_workspace_with_http_info(body, workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_project_for_workspace_with_http_info(body, workspace_gid, **kwargs)  # noqa: E501
+            (data) = self.create_project_for_workspace_with_http_info(body, workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_project_for_workspace_with_http_info(self, body, workspace_gid, **kwargs):  # noqa: E501
+    def create_project_for_workspace_with_http_info(self, body, workspace_gid, opts, **kwargs):  # noqa: E501
         """Create a project in a workspace  # noqa: E501
 
         Creates a project in the workspace.  If the workspace for your project is an organization, you must also supply a team to share the project with.  Returns the full record of the newly created project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_project_for_workspace_with_http_info(body, workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param WorkspaceGidProjectsBody body: The new project to create. (required)
+        :param dict body: The new project to create. (required)
         :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'workspace_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_project_for_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_project_for_workspace`")  # noqa: E501
         # verify the required parameter 'workspace_gid' is set
-        if ('workspace_gid' not in params or
-                params['workspace_gid'] is None):
+        if (workspace_gid is None):
             raise ValueError("Missing the required parameter `workspace_gid` when calling `create_project_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'workspace_gid' in params:
-            path_params['workspace_gid'] = params['workspace_gid']  # noqa: E501
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/projects', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/workspaces/{workspace_gid}/projects', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/workspaces/{workspace_gid}/projects', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -702,15 +925,15 @@
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.delete_project_with_http_info(project_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_project_with_http_info(project_gid, **kwargs)  # noqa: E501
             return data
 
     def delete_project_with_http_info(self, project_gid, **kwargs):  # noqa: E501
@@ -724,181 +947,259 @@
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `delete_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def duplicate_project(self, project_gid, **kwargs):  # noqa: E501
+    def duplicate_project(self, project_gid, opts, **kwargs):  # noqa: E501
         """Duplicate a project  # noqa: E501
 
         Creates and returns a job that will asynchronously handle the duplication.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.duplicate_project(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
-        :param ProjectGidDuplicateBody body: Describes the duplicate's name and the elements that will be duplicated.
+        :param dict body: Describes the duplicate's name and the elements that will be duplicated.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.duplicate_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            return self.duplicate_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.duplicate_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            (data) = self.duplicate_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def duplicate_project_with_http_info(self, project_gid, **kwargs):  # noqa: E501
+    def duplicate_project_with_http_info(self, project_gid, opts, **kwargs):  # noqa: E501
         """Duplicate a project  # noqa: E501
 
         Creates and returns a job that will asynchronously handle the duplication.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.duplicate_project_with_http_info(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
-        :param ProjectGidDuplicateBody body: Describes the duplicate's name and the elements that will be duplicated.
+        :param dict body: Describes the duplicate's name and the elements that will be duplicated.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_gid', 'body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method duplicate_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `duplicate_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/duplicate', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/duplicate', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/duplicate', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='JobResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_project(self, project_gid, **kwargs):  # noqa: E501
+    def get_project(self, project_gid, opts, **kwargs):  # noqa: E501
         """Get a project  # noqa: E501
 
         Returns the complete project record for a single project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project(project_gid, async_req=True)
         >>> result = thread.get()
@@ -906,22 +1207,22 @@
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            return self.get_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            (data) = self.get_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_project_with_http_info(self, project_gid, **kwargs):  # noqa: E501
+    def get_project_with_http_info(self, project_gid, opts, **kwargs):  # noqa: E501
         """Get a project  # noqa: E501
 
         Returns the complete project record for a single project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_project_with_http_info(project_gid, async_req=True)
         >>> result = thread.get()
@@ -929,76 +1230,115 @@
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `get_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_projects(self, **kwargs):  # noqa: E501
+    def get_projects(self, opts, **kwargs):  # noqa: E501
         """Get multiple projects  # noqa: E501
 
         Returns the compact project records for some filtered set of projects. Use one or more of the parameters provided to filter the projects returned. *Note: This endpoint may timeout for large domains. Try filtering by team!*  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_projects(async_req=True)
         >>> result = thread.get()
@@ -1010,22 +1350,22 @@
         :param str team: The team to filter projects on.
         :param bool archived: Only return projects whose `archived` field takes on the value of this parameter.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_projects_with_http_info(**kwargs)  # noqa: E501
+            return self.get_projects_with_http_info(opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_projects_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_projects_with_http_info(opts, **kwargs)  # noqa: E501
             return data
 
-    def get_projects_with_http_info(self, **kwargs):  # noqa: E501
+    def get_projects_with_http_info(self, opts, **kwargs):  # noqa: E501
         """Get multiple projects  # noqa: E501
 
         Returns the compact project records for some filtered set of projects. Use one or more of the parameters provided to filter the projects returned. *Note: This endpoint may timeout for large domains. Try filtering by team!*  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_projects_with_http_info(async_req=True)
         >>> result = thread.get()
@@ -1037,20 +1377,22 @@
         :param str team: The team to filter projects on.
         :param bool archived: Only return projects whose `archived` field takes on the value of this parameter.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['limit', 'offset', 'workspace', 'team', 'archived', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_projects" % key
@@ -1058,59 +1400,91 @@
             params[key] = val
         del params['kwargs']
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'team' in params:
-            query_params.append(('team', params['team']))  # noqa: E501
-        if 'archived' in params:
-            query_params.append(('archived', params['archived']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/projects',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/projects', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_projects_for_task(self, task_gid, **kwargs):  # noqa: E501
+    def get_projects_for_task(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get projects a task is in  # noqa: E501
 
         Returns a compact representation of all of the projects the task is in.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_projects_for_task(task_gid, async_req=True)
         >>> result = thread.get()
@@ -1120,22 +1494,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_projects_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            return self.get_projects_for_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_projects_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            (data) = self.get_projects_for_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_projects_for_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
+    def get_projects_for_task_with_http_info(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get projects a task is in  # noqa: E501
 
         Returns a compact representation of all of the projects the task is in.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_projects_for_task_with_http_info(task_gid, async_req=True)
         >>> result = thread.get()
@@ -1145,80 +1519,118 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['task_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_projects_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `get_projects_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/projects', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/tasks/{task_gid}/projects',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/projects', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_projects_for_team(self, team_gid, **kwargs):  # noqa: E501
+    def get_projects_for_team(self, team_gid, opts, **kwargs):  # noqa: E501
         """Get a team's projects  # noqa: E501
 
         Returns the compact project records for all projects in the team.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_projects_for_team(team_gid, async_req=True)
         >>> result = thread.get()
@@ -1229,22 +1641,22 @@
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param bool archived: Only return projects whose `archived` field takes on the value of this parameter.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_projects_for_team_with_http_info(team_gid, **kwargs)  # noqa: E501
+            return self.get_projects_for_team_with_http_info(team_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_projects_for_team_with_http_info(team_gid, **kwargs)  # noqa: E501
+            (data) = self.get_projects_for_team_with_http_info(team_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_projects_for_team_with_http_info(self, team_gid, **kwargs):  # noqa: E501
+    def get_projects_for_team_with_http_info(self, team_gid, opts, **kwargs):  # noqa: E501
         """Get a team's projects  # noqa: E501
 
         Returns the compact project records for all projects in the team.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_projects_for_team_with_http_info(team_gid, async_req=True)
         >>> result = thread.get()
@@ -1255,82 +1667,118 @@
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param bool archived: Only return projects whose `archived` field takes on the value of this parameter.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['team_gid', 'limit', 'offset', 'archived', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_projects_for_team" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'team_gid' is set
-        if ('team_gid' not in params or
-                params['team_gid'] is None):
+        if (team_gid is None):
             raise ValueError("Missing the required parameter `team_gid` when calling `get_projects_for_team`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'team_gid' in params:
-            path_params['team_gid'] = params['team_gid']  # noqa: E501
+        path_params['team_gid'] = team_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'archived' in params:
-            query_params.append(('archived', params['archived']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/teams/{team_gid}/projects', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/teams/{team_gid}/projects',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/teams/{team_gid}/projects', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_projects_for_workspace(self, workspace_gid, **kwargs):  # noqa: E501
+    def get_projects_for_workspace(self, workspace_gid, opts, **kwargs):  # noqa: E501
         """Get all projects in a workspace  # noqa: E501
 
         Returns the compact project records for all projects in the workspace. *Note: This endpoint may timeout for large domains. Prefer the `/teams/{team_gid}/projects` endpoint.*  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_projects_for_workspace(workspace_gid, async_req=True)
         >>> result = thread.get()
@@ -1341,22 +1789,22 @@
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param bool archived: Only return projects whose `archived` field takes on the value of this parameter.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_projects_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            return self.get_projects_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_projects_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            (data) = self.get_projects_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_projects_for_workspace_with_http_info(self, workspace_gid, **kwargs):  # noqa: E501
+    def get_projects_for_workspace_with_http_info(self, workspace_gid, opts, **kwargs):  # noqa: E501
         """Get all projects in a workspace  # noqa: E501
 
         Returns the compact project records for all projects in the workspace. *Note: This endpoint may timeout for large domains. Prefer the `/teams/{team_gid}/projects` endpoint.*  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_projects_for_workspace_with_http_info(workspace_gid, async_req=True)
         >>> result = thread.get()
@@ -1367,294 +1815,397 @@
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param bool archived: Only return projects whose `archived` field takes on the value of this parameter.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace_gid', 'limit', 'offset', 'archived', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_projects_for_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'workspace_gid' is set
-        if ('workspace_gid' not in params or
-                params['workspace_gid'] is None):
+        if (workspace_gid is None):
             raise ValueError("Missing the required parameter `workspace_gid` when calling `get_projects_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'workspace_gid' in params:
-            path_params['workspace_gid'] = params['workspace_gid']  # noqa: E501
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'archived' in params:
-            query_params.append(('archived', params['archived']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/projects', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/workspaces/{workspace_gid}/projects',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/workspaces/{workspace_gid}/projects', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_task_counts_for_project(self, project_gid, **kwargs):  # noqa: E501
+    def get_task_counts_for_project(self, project_gid, opts, **kwargs):  # noqa: E501
         """Get task count of a project  # noqa: E501
 
         Get an object that holds task count fields. **All fields are excluded by default**. You must [opt in](/docs/inputoutput-options) using `opt_fields` to get any information from this endpoint.  This endpoint has an additional [rate limit](/docs/rate-limits) and each field counts especially high against our [cost limits](/docs/rate-limits#cost-limits).  Milestones are just tasks, so they are included in the `num_tasks`, `num_incomplete_tasks`, and `num_completed_tasks` counts.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_task_counts_for_project(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskCountResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_task_counts_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            return self.get_task_counts_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_task_counts_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            (data) = self.get_task_counts_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_task_counts_for_project_with_http_info(self, project_gid, **kwargs):  # noqa: E501
+    def get_task_counts_for_project_with_http_info(self, project_gid, opts, **kwargs):  # noqa: E501
         """Get task count of a project  # noqa: E501
 
         Get an object that holds task count fields. **All fields are excluded by default**. You must [opt in](/docs/inputoutput-options) using `opt_fields` to get any information from this endpoint.  This endpoint has an additional [rate limit](/docs/rate-limits) and each field counts especially high against our [cost limits](/docs/rate-limits#cost-limits).  Milestones are just tasks, so they are included in the `num_tasks`, `num_incomplete_tasks`, and `num_completed_tasks` counts.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_task_counts_for_project_with_http_info(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskCountResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_task_counts_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `get_task_counts_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/task_counts', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/task_counts', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/task_counts', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskCountResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def project_save_as_template(self, body, project_gid, **kwargs):  # noqa: E501
+    def project_save_as_template(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Create a project template from a project  # noqa: E501
 
         Creates and returns a job that will asynchronously handle the project template creation. Note that while the resulting project template can be accessed with the API, it won't be visible in the Asana UI until Project Templates 2.0 is launched in the app. See more in [this forum post](https://forum.asana.com/t/a-new-api-for-project-templates/156432).  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.project_save_as_template(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidSaveAsTemplateBody body: Describes the inputs used for creating a project template, such as the resulting project template's name, which team it should be created in. (required)
+        :param dict body: Describes the inputs used for creating a project template, such as the resulting project template's name, which team it should be created in. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.project_save_as_template_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            return self.project_save_as_template_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.project_save_as_template_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            (data) = self.project_save_as_template_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def project_save_as_template_with_http_info(self, body, project_gid, **kwargs):  # noqa: E501
+    def project_save_as_template_with_http_info(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Create a project template from a project  # noqa: E501
 
         Creates and returns a job that will asynchronously handle the project template creation. Note that while the resulting project template can be accessed with the API, it won't be visible in the Asana UI until Project Templates 2.0 is launched in the app. See more in [this forum post](https://forum.asana.com/t/a-new-api-for-project-templates/156432).  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.project_save_as_template_with_http_info(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidSaveAsTemplateBody body: Describes the inputs used for creating a project template, such as the resulting project template's name, which team it should be created in. (required)
+        :param dict body: Describes the inputs used for creating a project template, such as the resulting project template's name, which team it should be created in. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'project_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method project_save_as_template" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `project_save_as_template`")  # noqa: E501
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `project_save_as_template`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/saveAsTemplate', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/saveAsTemplate', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/saveAsTemplate', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='JobResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -1664,21 +2215,21 @@
         Removes a custom field setting from a project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_custom_field_setting_for_project(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidRemoveCustomFieldSettingBody body: Information about the custom field setting being removed. (required)
+        :param dict body: Information about the custom field setting being removed. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.remove_custom_field_setting_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.remove_custom_field_setting_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
             return data
 
     def remove_custom_field_setting_for_project_with_http_info(self, body, project_gid, **kwargs):  # noqa: E501
@@ -1687,416 +2238,562 @@
         Removes a custom field setting from a project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_custom_field_setting_for_project_with_http_info(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidRemoveCustomFieldSettingBody body: Information about the custom field setting being removed. (required)
+        :param dict body: Information about the custom field setting being removed. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'project_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_custom_field_setting_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `remove_custom_field_setting_for_project`")  # noqa: E501
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `remove_custom_field_setting_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/removeCustomFieldSetting', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/removeCustomFieldSetting', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/removeCustomFieldSetting', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def remove_followers_for_project(self, body, project_gid, **kwargs):  # noqa: E501
+    def remove_followers_for_project(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Remove followers from a project  # noqa: E501
 
         Removes the specified list of users from following the project, this will not affect project membership status. Returns the updated project record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_followers_for_project(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidRemoveFollowersBody body: Information about the followers being removed. (required)
+        :param dict body: Information about the followers being removed. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.remove_followers_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            return self.remove_followers_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.remove_followers_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            (data) = self.remove_followers_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def remove_followers_for_project_with_http_info(self, body, project_gid, **kwargs):  # noqa: E501
+    def remove_followers_for_project_with_http_info(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Remove followers from a project  # noqa: E501
 
         Removes the specified list of users from following the project, this will not affect project membership status. Returns the updated project record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_followers_for_project_with_http_info(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidRemoveFollowersBody body: Information about the followers being removed. (required)
+        :param dict body: Information about the followers being removed. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'project_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_followers_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `remove_followers_for_project`")  # noqa: E501
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `remove_followers_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/removeFollowers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/removeFollowers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/removeFollowers', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def remove_members_for_project(self, body, project_gid, **kwargs):  # noqa: E501
+    def remove_members_for_project(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Remove users from a project  # noqa: E501
 
         Removes the specified list of users from members of the project. Returns the updated project record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_members_for_project(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidRemoveMembersBody body: Information about the members being removed. (required)
+        :param dict body: Information about the members being removed. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.remove_members_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            return self.remove_members_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.remove_members_for_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            (data) = self.remove_members_for_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def remove_members_for_project_with_http_info(self, body, project_gid, **kwargs):  # noqa: E501
+    def remove_members_for_project_with_http_info(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Remove users from a project  # noqa: E501
 
         Removes the specified list of users from members of the project. Returns the updated project record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_members_for_project_with_http_info(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectGidRemoveMembersBody body: Information about the members being removed. (required)
+        :param dict body: Information about the members being removed. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'project_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_members_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `remove_members_for_project`")  # noqa: E501
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `remove_members_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/removeMembers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/removeMembers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/removeMembers', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_project(self, body, project_gid, **kwargs):  # noqa: E501
+    def update_project(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Update a project  # noqa: E501
 
         A specific, existing project can be updated by making a PUT request on the URL for that project. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated project record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_project(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectsProjectGidBody body: The updated fields for the project. (required)
+        :param dict body: The updated fields for the project. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            return self.update_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_project_with_http_info(body, project_gid, **kwargs)  # noqa: E501
+            (data) = self.update_project_with_http_info(body, project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_project_with_http_info(self, body, project_gid, **kwargs):  # noqa: E501
+    def update_project_with_http_info(self, body, project_gid, opts, **kwargs):  # noqa: E501
         """Update a project  # noqa: E501
 
         A specific, existing project can be updated by making a PUT request on the URL for that project. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated project record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_project_with_http_info(body, project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param ProjectsProjectGidBody body: The updated fields for the project. (required)
+        :param dict body: The updated fields for the project. (required)
         :param str project_gid: Globally unique identifier for the project. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: ProjectResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'project_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `update_project`")  # noqa: E501
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `update_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}', 'PUT',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='ProjectResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/sections_api.py` & `asana_preview-1.2.40/asana_preview/api/sections_api.py`

 * *Files 22% similar despite different names*

```diff
@@ -12,234 +12,311 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class SectionsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def add_task_for_section(self, section_gid, **kwargs):  # noqa: E501
+    def add_task_for_section(self, section_gid, opts, **kwargs):  # noqa: E501
         """Add task to section  # noqa: E501
 
         Add a task to a specific, existing section. This will remove the task from other sections of the project.  The task will be inserted at the top of a section unless an insert_before or insert_after parameter is declared.  This does not work for separators (tasks with the resource_subtype of section).  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_task_for_section(section_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str section_gid: The globally unique identifier for the section. (required)
-        :param SectionGidAddTaskBody body: The task and optionally the insert location.
+        :param dict body: The task and optionally the insert location.
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.add_task_for_section_with_http_info(section_gid, **kwargs)  # noqa: E501
+            return self.add_task_for_section_with_http_info(section_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.add_task_for_section_with_http_info(section_gid, **kwargs)  # noqa: E501
+            (data) = self.add_task_for_section_with_http_info(section_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def add_task_for_section_with_http_info(self, section_gid, **kwargs):  # noqa: E501
+    def add_task_for_section_with_http_info(self, section_gid, opts, **kwargs):  # noqa: E501
         """Add task to section  # noqa: E501
 
         Add a task to a specific, existing section. This will remove the task from other sections of the project.  The task will be inserted at the top of a section unless an insert_before or insert_after parameter is declared.  This does not work for separators (tasks with the resource_subtype of section).  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_task_for_section_with_http_info(section_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str section_gid: The globally unique identifier for the section. (required)
-        :param SectionGidAddTaskBody body: The task and optionally the insert location.
+        :param dict body: The task and optionally the insert location.
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['section_gid', 'body']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_task_for_section" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'section_gid' is set
-        if ('section_gid' not in params or
-                params['section_gid'] is None):
+        if (section_gid is None):
             raise ValueError("Missing the required parameter `section_gid` when calling `add_task_for_section`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'section_gid' in params:
-            path_params['section_gid'] = params['section_gid']  # noqa: E501
+        path_params['section_gid'] = section_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/sections/{section_gid}/addTask', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/sections/{section_gid}/addTask', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/sections/{section_gid}/addTask', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create_section_for_project(self, project_gid, **kwargs):  # noqa: E501
+    def create_section_for_project(self, project_gid, opts, **kwargs):  # noqa: E501
         """Create a section in a project  # noqa: E501
 
         Creates a new section in a project. Returns the full record of the newly created section.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_section_for_project(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
-        :param ProjectGidSectionsBody body: The section to create.
+        :param dict body: The section to create.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: SectionResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_section_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            return self.create_section_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_section_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            (data) = self.create_section_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_section_for_project_with_http_info(self, project_gid, **kwargs):  # noqa: E501
+    def create_section_for_project_with_http_info(self, project_gid, opts, **kwargs):  # noqa: E501
         """Create a section in a project  # noqa: E501
 
         Creates a new section in a project. Returns the full record of the newly created section.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_section_for_project_with_http_info(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
-        :param ProjectGidSectionsBody body: The section to create.
+        :param dict body: The section to create.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: SectionResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_gid', 'body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_section_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `create_section_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/sections', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/sections', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/sections', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SectionResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -254,15 +331,15 @@
 
         :param async_req bool
         :param str section_gid: The globally unique identifier for the section. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.delete_section_with_http_info(section_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_section_with_http_info(section_gid, **kwargs)  # noqa: E501
             return data
 
     def delete_section_with_http_info(self, section_gid, **kwargs):  # noqa: E501
@@ -276,73 +353,114 @@
 
         :param async_req bool
         :param str section_gid: The globally unique identifier for the section. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['section_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_section" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'section_gid' is set
-        if ('section_gid' not in params or
-                params['section_gid'] is None):
+        if (section_gid is None):
             raise ValueError("Missing the required parameter `section_gid` when calling `delete_section`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'section_gid' in params:
-            path_params['section_gid'] = params['section_gid']  # noqa: E501
+        path_params['section_gid'] = section_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/sections/{section_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/sections/{section_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/sections/{section_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_section(self, section_gid, **kwargs):  # noqa: E501
+    def get_section(self, section_gid, opts, **kwargs):  # noqa: E501
         """Get a section  # noqa: E501
 
         Returns the complete record for a single section.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_section(section_gid, async_req=True)
         >>> result = thread.get()
@@ -350,22 +468,22 @@
         :param async_req bool
         :param str section_gid: The globally unique identifier for the section. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: SectionResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_section_with_http_info(section_gid, **kwargs)  # noqa: E501
+            return self.get_section_with_http_info(section_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_section_with_http_info(section_gid, **kwargs)  # noqa: E501
+            (data) = self.get_section_with_http_info(section_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_section_with_http_info(self, section_gid, **kwargs):  # noqa: E501
+    def get_section_with_http_info(self, section_gid, opts, **kwargs):  # noqa: E501
         """Get a section  # noqa: E501
 
         Returns the complete record for a single section.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_section_with_http_info(section_gid, async_req=True)
         >>> result = thread.get()
@@ -373,76 +491,115 @@
         :param async_req bool
         :param str section_gid: The globally unique identifier for the section. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: SectionResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['section_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_section" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'section_gid' is set
-        if ('section_gid' not in params or
-                params['section_gid'] is None):
+        if (section_gid is None):
             raise ValueError("Missing the required parameter `section_gid` when calling `get_section`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'section_gid' in params:
-            path_params['section_gid'] = params['section_gid']  # noqa: E501
+        path_params['section_gid'] = section_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/sections/{section_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/sections/{section_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/sections/{section_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SectionResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_sections_for_project(self, project_gid, **kwargs):  # noqa: E501
+    def get_sections_for_project(self, project_gid, opts, **kwargs):  # noqa: E501
         """Get sections in a project  # noqa: E501
 
         Returns the compact records for all sections in the specified project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_sections_for_project(project_gid, async_req=True)
         >>> result = thread.get()
@@ -452,22 +609,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: SectionResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_sections_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            return self.get_sections_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_sections_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            (data) = self.get_sections_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_sections_for_project_with_http_info(self, project_gid, **kwargs):  # noqa: E501
+    def get_sections_for_project_with_http_info(self, project_gid, opts, **kwargs):  # noqa: E501
         """Get sections in a project  # noqa: E501
 
         Returns the compact records for all sections in the specified project.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_sections_for_project_with_http_info(project_gid, async_req=True)
         >>> result = thread.get()
@@ -477,282 +634,397 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: SectionResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_sections_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `get_sections_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/sections', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/projects/{project_gid}/sections',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/sections', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SectionResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def insert_section_for_project(self, project_gid, **kwargs):  # noqa: E501
+    def insert_section_for_project(self, project_gid, opts, **kwargs):  # noqa: E501
         """Move or Insert sections  # noqa: E501
 
         Move sections relative to each other. One of `before_section` or `after_section` is required.  Sections cannot be moved between projects.  Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.insert_section_for_project(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
-        :param SectionsInsertBody body: The section's move action.
+        :param dict body: The section's move action.
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.insert_section_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            return self.insert_section_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.insert_section_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            (data) = self.insert_section_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def insert_section_for_project_with_http_info(self, project_gid, **kwargs):  # noqa: E501
+    def insert_section_for_project_with_http_info(self, project_gid, opts, **kwargs):  # noqa: E501
         """Move or Insert sections  # noqa: E501
 
         Move sections relative to each other. One of `before_section` or `after_section` is required.  Sections cannot be moved between projects.  Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.insert_section_for_project_with_http_info(project_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str project_gid: Globally unique identifier for the project. (required)
-        :param SectionsInsertBody body: The section's move action.
+        :param dict body: The section's move action.
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_gid', 'body']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method insert_section_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `insert_section_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/sections/insert', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/projects/{project_gid}/sections/insert', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/sections/insert', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_section(self, section_gid, **kwargs):  # noqa: E501
+    def update_section(self, section_gid, opts, **kwargs):  # noqa: E501
         """Update a section  # noqa: E501
 
         A specific, existing section can be updated by making a PUT request on the URL for that project. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged. (note that at this time, the only field that can be updated is the `name` field.)  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated section record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_section(section_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str section_gid: The globally unique identifier for the section. (required)
-        :param SectionsSectionGidBody body: The section to create.
+        :param dict body: The section to create.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: SectionResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_section_with_http_info(section_gid, **kwargs)  # noqa: E501
+            return self.update_section_with_http_info(section_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_section_with_http_info(section_gid, **kwargs)  # noqa: E501
+            (data) = self.update_section_with_http_info(section_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_section_with_http_info(self, section_gid, **kwargs):  # noqa: E501
+    def update_section_with_http_info(self, section_gid, opts, **kwargs):  # noqa: E501
         """Update a section  # noqa: E501
 
         A specific, existing section can be updated by making a PUT request on the URL for that project. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged. (note that at this time, the only field that can be updated is the `name` field.)  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated section record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_section_with_http_info(section_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str section_gid: The globally unique identifier for the section. (required)
-        :param SectionsSectionGidBody body: The section to create.
+        :param dict body: The section to create.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: SectionResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['section_gid', 'body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_section" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'section_gid' is set
-        if ('section_gid' not in params or
-                params['section_gid'] is None):
+        if (section_gid is None):
             raise ValueError("Missing the required parameter `section_gid` when calling `update_section`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'section_gid' in params:
-            path_params['section_gid'] = params['section_gid']  # noqa: E501
+        path_params['section_gid'] = section_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/sections/{section_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/sections/{section_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/sections/{section_gid}', 'PUT',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='SectionResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/status_updates_api.py` & `asana_preview-1.2.40/asana_preview/api/status_updates_api.py`

 * *Files 24% similar despite different names*

```diff
@@ -12,135 +12,169 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class StatusUpdatesApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_status_for_object(self, body, **kwargs):  # noqa: E501
+    def create_status_for_object(self, body, opts, **kwargs):  # noqa: E501
         """Create a status update  # noqa: E501
 
         Creates a new status update on an object. Returns the full record of the newly created status update.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_status_for_object(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param StatusUpdatesBody body: The status update to create. (required)
+        :param dict body: The status update to create. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: StatusUpdateResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_status_for_object_with_http_info(body, **kwargs)  # noqa: E501
+            return self.create_status_for_object_with_http_info(body, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_status_for_object_with_http_info(body, **kwargs)  # noqa: E501
+            (data) = self.create_status_for_object_with_http_info(body, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_status_for_object_with_http_info(self, body, **kwargs):  # noqa: E501
+    def create_status_for_object_with_http_info(self, body, opts, **kwargs):  # noqa: E501
         """Create a status update  # noqa: E501
 
         Creates a new status update on an object. Returns the full record of the newly created status update.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_status_for_object_with_http_info(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param StatusUpdatesBody body: The status update to create. (required)
+        :param dict body: The status update to create. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: StatusUpdateResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_status_for_object" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_status_for_object`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/status_updates', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/status_updates', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/status_updates', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='StatusUpdateResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -155,15 +189,15 @@
 
         :param async_req bool
         :param str status_update_gid: The status update to get. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.delete_status_with_http_info(status_update_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_status_with_http_info(status_update_gid, **kwargs)  # noqa: E501
             return data
 
     def delete_status_with_http_info(self, status_update_gid, **kwargs):  # noqa: E501
@@ -177,73 +211,114 @@
 
         :param async_req bool
         :param str status_update_gid: The status update to get. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['status_update_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_status" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'status_update_gid' is set
-        if ('status_update_gid' not in params or
-                params['status_update_gid'] is None):
+        if (status_update_gid is None):
             raise ValueError("Missing the required parameter `status_update_gid` when calling `delete_status`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'status_update_gid' in params:
-            path_params['status_update_gid'] = params['status_update_gid']  # noqa: E501
+        path_params['status_update_gid'] = status_update_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/status_updates/{status_update_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/status_updates/{status_update_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/status_updates/{status_update_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_status(self, status_update_gid, **kwargs):  # noqa: E501
+    def get_status(self, status_update_gid, opts, **kwargs):  # noqa: E501
         """Get a status update  # noqa: E501
 
         Returns the complete record for a single status update.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_status(status_update_gid, async_req=True)
         >>> result = thread.get()
@@ -251,22 +326,22 @@
         :param async_req bool
         :param str status_update_gid: The status update to get. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: StatusUpdateResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_status_with_http_info(status_update_gid, **kwargs)  # noqa: E501
+            return self.get_status_with_http_info(status_update_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_status_with_http_info(status_update_gid, **kwargs)  # noqa: E501
+            (data) = self.get_status_with_http_info(status_update_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_status_with_http_info(self, status_update_gid, **kwargs):  # noqa: E501
+    def get_status_with_http_info(self, status_update_gid, opts, **kwargs):  # noqa: E501
         """Get a status update  # noqa: E501
 
         Returns the complete record for a single status update.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_status_with_http_info(status_update_gid, async_req=True)
         >>> result = thread.get()
@@ -274,76 +349,115 @@
         :param async_req bool
         :param str status_update_gid: The status update to get. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: StatusUpdateResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['status_update_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_status" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'status_update_gid' is set
-        if ('status_update_gid' not in params or
-                params['status_update_gid'] is None):
+        if (status_update_gid is None):
             raise ValueError("Missing the required parameter `status_update_gid` when calling `get_status`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'status_update_gid' in params:
-            path_params['status_update_gid'] = params['status_update_gid']  # noqa: E501
+        path_params['status_update_gid'] = status_update_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/status_updates/{status_update_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/status_updates/{status_update_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/status_updates/{status_update_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='StatusUpdateResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_statuses_for_object(self, parent, **kwargs):  # noqa: E501
+    def get_statuses_for_object(self, parent, opts, **kwargs):  # noqa: E501
         """Get status updates from an object  # noqa: E501
 
         Returns the compact status update records for all updates on the object.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_statuses_for_object(parent, async_req=True)
         >>> result = thread.get()
@@ -354,22 +468,22 @@
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param datetime created_since: Only return statuses that have been created since the given time.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: StatusUpdateResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_statuses_for_object_with_http_info(parent, **kwargs)  # noqa: E501
+            return self.get_statuses_for_object_with_http_info(parent, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_statuses_for_object_with_http_info(parent, **kwargs)  # noqa: E501
+            (data) = self.get_statuses_for_object_with_http_info(parent, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_statuses_for_object_with_http_info(self, parent, **kwargs):  # noqa: E501
+    def get_statuses_for_object_with_http_info(self, parent, opts, **kwargs):  # noqa: E501
         """Get status updates from an object  # noqa: E501
 
         Returns the compact status update records for all updates on the object.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_statuses_for_object_with_http_info(parent, async_req=True)
         >>> result = thread.get()
@@ -380,73 +494,109 @@
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param datetime created_since: Only return statuses that have been created since the given time.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: StatusUpdateResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['parent', 'limit', 'offset', 'created_since', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_statuses_for_object" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'parent' is set
-        if ('parent' not in params or
-                params['parent'] is None):
+        if (parent is None):
             raise ValueError("Missing the required parameter `parent` when calling `get_statuses_for_object`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'parent' in params:
-            query_params.append(('parent', params['parent']))  # noqa: E501
-        if 'created_since' in params:
-            query_params.append(('created_since', params['created_since']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+        query_params['parent'] = parent
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/status_updates', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/status_updates',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/status_updates', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='StatusUpdateResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/stories_api.py` & `asana_preview-1.2.40/asana_preview/api/workspace_memberships_api.py`

 * *Files 20% similar despite different names*

```diff
@@ -12,557 +12,455 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
-
-class StoriesApi(object):
+class WorkspaceMembershipsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_story_for_task(self, body, task_gid, **kwargs):  # noqa: E501
-        """Create a story on a task  # noqa: E501
+    def get_workspace_membership(self, workspace_membership_gid, opts, **kwargs):  # noqa: E501
+        """Get a workspace membership  # noqa: E501
 
-        Adds a story to a task. This endpoint currently only allows for comment stories to be created. The comment will be authored by the currently authenticated user, and timestamped when the server receives the request.  Returns the full record for the new story added to the task.  # noqa: E501
+        Returns the complete workspace record for a single workspace membership.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_story_for_task(body, task_gid, async_req=True)
+        >>> thread = api.get_workspace_membership(workspace_membership_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidStoriesBody body: The story to create. (required)
-        :param str task_gid: The task to operate on. (required)
+        :param str workspace_membership_gid: (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: StoryResponseData
+        :return: WorkspaceMembershipResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_story_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            return self.get_workspace_membership_with_http_info(workspace_membership_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_story_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            (data) = self.get_workspace_membership_with_http_info(workspace_membership_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_story_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
-        """Create a story on a task  # noqa: E501
+    def get_workspace_membership_with_http_info(self, workspace_membership_gid, opts, **kwargs):  # noqa: E501
+        """Get a workspace membership  # noqa: E501
 
-        Adds a story to a task. This endpoint currently only allows for comment stories to be created. The comment will be authored by the currently authenticated user, and timestamped when the server receives the request.  Returns the full record for the new story added to the task.  # noqa: E501
+        Returns the complete workspace record for a single workspace membership.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_story_for_task_with_http_info(body, task_gid, async_req=True)
+        >>> thread = api.get_workspace_membership_with_http_info(workspace_membership_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidStoriesBody body: The story to create. (required)
-        :param str task_gid: The task to operate on. (required)
+        :param str workspace_membership_gid: (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: StoryResponseData
+        :return: WorkspaceMembershipResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method create_story_for_task" % key
+                    " to method get_workspace_membership" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `create_story_for_task`")  # noqa: E501
-        # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
-            raise ValueError("Missing the required parameter `task_gid` when calling `create_story_for_task`")  # noqa: E501
+        # verify the required parameter 'workspace_membership_gid' is set
+        if (workspace_membership_gid is None):
+            raise ValueError("Missing the required parameter `workspace_membership_gid` when calling `get_workspace_membership`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
-
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/tasks/{task_gid}/stories', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='StoryResponseData',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def delete_story(self, story_gid, **kwargs):  # noqa: E501
-        """Delete a story  # noqa: E501
-
-        Deletes a story. A user can only delete stories they have created.  Returns an empty data record.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_story(story_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str story_gid: Globally unique identifier for the story. (required)
-        :return: EmptyResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.delete_story_with_http_info(story_gid, **kwargs)  # noqa: E501
-        else:
-            (data) = self.delete_story_with_http_info(story_gid, **kwargs)  # noqa: E501
-            return data
+        path_params['workspace_membership_gid'] = workspace_membership_gid  # noqa: E501
 
-    def delete_story_with_http_info(self, story_gid, **kwargs):  # noqa: E501
-        """Delete a story  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        Deletes a story. A user can only delete stories they have created.  Returns an empty data record.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.delete_story_with_http_info(story_gid, async_req=True)
-        >>> result = thread.get()
 
-        :param async_req bool
-        :param str story_gid: Globally unique identifier for the story. (required)
-        :return: EmptyResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['story_gid']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method delete_story" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'story_gid' is set
-        if ('story_gid' not in params or
-                params['story_gid'] is None):
-            raise ValueError("Missing the required parameter `story_gid` when calling `delete_story`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'story_gid' in params:
-            path_params['story_gid'] = params['story_gid']  # noqa: E501
-
-        query_params = []
-
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/stories/{story_gid}', 'DELETE',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspace_memberships/{workspace_membership_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/workspace_memberships/{workspace_membership_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/workspace_memberships/{workspace_membership_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_stories_for_task(self, task_gid, **kwargs):  # noqa: E501
-        """Get stories from a task  # noqa: E501
+    def get_workspace_memberships_for_user(self, user_gid, opts, **kwargs):  # noqa: E501
+        """Get workspace memberships for a user  # noqa: E501
 
-        Returns the compact records for all stories on the task.  # noqa: E501
+        Returns the compact workspace membership records for the user.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_stories_for_task(task_gid, async_req=True)
+        >>> thread = api.get_workspace_memberships_for_user(user_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str task_gid: The task to operate on. (required)
+        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: StoryResponseArray
+        :return: WorkspaceMembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_stories_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            return self.get_workspace_memberships_for_user_with_http_info(user_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_stories_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            (data) = self.get_workspace_memberships_for_user_with_http_info(user_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_stories_for_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
-        """Get stories from a task  # noqa: E501
+    def get_workspace_memberships_for_user_with_http_info(self, user_gid, opts, **kwargs):  # noqa: E501
+        """Get workspace memberships for a user  # noqa: E501
 
-        Returns the compact records for all stories on the task.  # noqa: E501
+        Returns the compact workspace membership records for the user.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_stories_for_task_with_http_info(task_gid, async_req=True)
+        >>> thread = api.get_workspace_memberships_for_user_with_http_info(user_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str task_gid: The task to operate on. (required)
+        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: StoryResponseArray
+        :return: WorkspaceMembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['task_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_stories_for_task" % key
+                    " to method get_workspace_memberships_for_user" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
-            raise ValueError("Missing the required parameter `task_gid` when calling `get_stories_for_task`")  # noqa: E501
+        # verify the required parameter 'user_gid' is set
+        if (user_gid is None):
+            raise ValueError("Missing the required parameter `user_gid` when calling `get_workspace_memberships_for_user`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['user_gid'] = user_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/tasks/{task_gid}/stories', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/users/{user_gid}/workspace_memberships', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/users/{user_gid}/workspace_memberships',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/users/{user_gid}/workspace_memberships', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='StoryResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_story(self, story_gid, **kwargs):  # noqa: E501
-        """Get a story  # noqa: E501
+    def get_workspace_memberships_for_workspace(self, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Get the workspace memberships for a workspace  # noqa: E501
 
-        Returns the full record for a single story.  # noqa: E501
+        Returns the compact workspace membership records for the workspace.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_story(story_gid, async_req=True)
+        >>> thread = api.get_workspace_memberships_for_workspace(workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str story_gid: Globally unique identifier for the story. (required)
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
+        :param str user: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user.
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: StoryResponseData
+        :return: WorkspaceMembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_story_with_http_info(story_gid, **kwargs)  # noqa: E501
+            return self.get_workspace_memberships_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_story_with_http_info(story_gid, **kwargs)  # noqa: E501
+            (data) = self.get_workspace_memberships_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_story_with_http_info(self, story_gid, **kwargs):  # noqa: E501
-        """Get a story  # noqa: E501
+    def get_workspace_memberships_for_workspace_with_http_info(self, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Get the workspace memberships for a workspace  # noqa: E501
 
-        Returns the full record for a single story.  # noqa: E501
+        Returns the compact workspace membership records for the workspace.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_story_with_http_info(story_gid, async_req=True)
+        >>> thread = api.get_workspace_memberships_for_workspace_with_http_info(workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str story_gid: Globally unique identifier for the story. (required)
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
+        :param str user: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user.
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: StoryResponseData
+        :return: WorkspaceMembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['story_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_story" % key
+                    " to method get_workspace_memberships_for_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'story_gid' is set
-        if ('story_gid' not in params or
-                params['story_gid'] is None):
-            raise ValueError("Missing the required parameter `story_gid` when calling `get_story`")  # noqa: E501
+        # verify the required parameter 'workspace_gid' is set
+        if (workspace_gid is None):
+            raise ValueError("Missing the required parameter `workspace_gid` when calling `get_workspace_memberships_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'story_gid' in params:
-            path_params['story_gid'] = params['story_gid']  # noqa: E501
-
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/stories/{story_gid}', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='StoryResponseData',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def update_story(self, body, story_gid, **kwargs):  # noqa: E501
-        """Update a story  # noqa: E501
-
-        Updates the story and returns the full record for the updated story. Only comment stories can have their text updated, and only comment stories and attachment stories can be pinned. Only one of `text` and `html_text` can be specified.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_story(body, story_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param StoriesStoryGidBody body: The comment story to update. (required)
-        :param str story_gid: Globally unique identifier for the story. (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: StoryResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.update_story_with_http_info(body, story_gid, **kwargs)  # noqa: E501
-        else:
-            (data) = self.update_story_with_http_info(body, story_gid, **kwargs)  # noqa: E501
-            return data
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
 
-    def update_story_with_http_info(self, body, story_gid, **kwargs):  # noqa: E501
-        """Update a story  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        Updates the story and returns the full record for the updated story. Only comment stories can have their text updated, and only comment stories and attachment stories can be pinned. Only one of `text` and `html_text` can be specified.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_story_with_http_info(body, story_gid, async_req=True)
-        >>> result = thread.get()
 
-        :param async_req bool
-        :param StoriesStoryGidBody body: The comment story to update. (required)
-        :param str story_gid: Globally unique identifier for the story. (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: StoryResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body', 'story_gid', 'opt_fields']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method update_story" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_story`")  # noqa: E501
-        # verify the required parameter 'story_gid' is set
-        if ('story_gid' not in params or
-                params['story_gid'] is None):
-            raise ValueError("Missing the required parameter `story_gid` when calling `update_story`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'story_gid' in params:
-            path_params['story_gid'] = params['story_gid']  # noqa: E501
-
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
-        if 'body' in params:
-            body_params = params['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/stories/{story_gid}', 'PUT',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/workspace_memberships', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/workspaces/{workspace_gid}/workspace_memberships',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/workspaces/{workspace_gid}/workspace_memberships', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='StoryResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/tags_api.py` & `asana_preview-1.2.40/asana_preview/api/tags_api.py`

 * *Files 18% similar despite different names*

```diff
@@ -12,239 +12,313 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class TagsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_tag(self, body, **kwargs):  # noqa: E501
+    def create_tag(self, body, opts, **kwargs):  # noqa: E501
         """Create a tag  # noqa: E501
 
         Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_tag(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TagsBody body: The tag to create. (required)
+        :param dict body: The tag to create. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_tag_with_http_info(body, **kwargs)  # noqa: E501
+            return self.create_tag_with_http_info(body, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_tag_with_http_info(body, **kwargs)  # noqa: E501
+            (data) = self.create_tag_with_http_info(body, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_tag_with_http_info(self, body, **kwargs):  # noqa: E501
+    def create_tag_with_http_info(self, body, opts, **kwargs):  # noqa: E501
         """Create a tag  # noqa: E501
 
         Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_tag_with_http_info(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TagsBody body: The tag to create. (required)
+        :param dict body: The tag to create. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_tag" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_tag`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tags', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tags', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tags', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TagResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create_tag_for_workspace(self, body, workspace_gid, **kwargs):  # noqa: E501
+    def create_tag_for_workspace(self, body, workspace_gid, opts, **kwargs):  # noqa: E501
         """Create a tag in a workspace  # noqa: E501
 
         Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_tag_for_workspace(body, workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param WorkspaceGidTagsBody body: The tag to create. (required)
+        :param dict body: The tag to create. (required)
         :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_tag_for_workspace_with_http_info(body, workspace_gid, **kwargs)  # noqa: E501
+            return self.create_tag_for_workspace_with_http_info(body, workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_tag_for_workspace_with_http_info(body, workspace_gid, **kwargs)  # noqa: E501
+            (data) = self.create_tag_for_workspace_with_http_info(body, workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_tag_for_workspace_with_http_info(self, body, workspace_gid, **kwargs):  # noqa: E501
+    def create_tag_for_workspace_with_http_info(self, body, workspace_gid, opts, **kwargs):  # noqa: E501
         """Create a tag in a workspace  # noqa: E501
 
         Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_tag_for_workspace_with_http_info(body, workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param WorkspaceGidTagsBody body: The tag to create. (required)
+        :param dict body: The tag to create. (required)
         :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'workspace_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_tag_for_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_tag_for_workspace`")  # noqa: E501
         # verify the required parameter 'workspace_gid' is set
-        if ('workspace_gid' not in params or
-                params['workspace_gid'] is None):
+        if (workspace_gid is None):
             raise ValueError("Missing the required parameter `workspace_gid` when calling `create_tag_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'workspace_gid' in params:
-            path_params['workspace_gid'] = params['workspace_gid']  # noqa: E501
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/tags', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/workspaces/{workspace_gid}/tags', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/workspaces/{workspace_gid}/tags', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TagResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -255,21 +329,19 @@
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_tag(tag_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str tag_gid: Globally unique identifier for the tag. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.delete_tag_with_http_info(tag_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_tag_with_http_info(tag_gid, **kwargs)  # noqa: E501
             return data
 
     def delete_tag_with_http_info(self, tag_gid, **kwargs):  # noqa: E501
@@ -279,191 +351,257 @@
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.delete_tag_with_http_info(tag_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str tag_gid: Globally unique identifier for the tag. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['tag_gid', 'limit', 'offset']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_tag" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'tag_gid' is set
-        if ('tag_gid' not in params or
-                params['tag_gid'] is None):
+        if (tag_gid is None):
             raise ValueError("Missing the required parameter `tag_gid` when calling `delete_tag`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'tag_gid' in params:
-            path_params['tag_gid'] = params['tag_gid']  # noqa: E501
+        path_params['tag_gid'] = tag_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tags/{tag_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tags/{tag_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tags/{tag_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_tag(self, tag_gid, **kwargs):  # noqa: E501
+    def get_tag(self, tag_gid, opts, **kwargs):  # noqa: E501
         """Get a tag  # noqa: E501
 
         Returns the complete tag record for a single tag.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tag(tag_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str tag_gid: Globally unique identifier for the tag. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_tag_with_http_info(tag_gid, **kwargs)  # noqa: E501
+            return self.get_tag_with_http_info(tag_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_tag_with_http_info(tag_gid, **kwargs)  # noqa: E501
+            (data) = self.get_tag_with_http_info(tag_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_tag_with_http_info(self, tag_gid, **kwargs):  # noqa: E501
+    def get_tag_with_http_info(self, tag_gid, opts, **kwargs):  # noqa: E501
         """Get a tag  # noqa: E501
 
         Returns the complete tag record for a single tag.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tag_with_http_info(tag_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str tag_gid: Globally unique identifier for the tag. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['tag_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_tag" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'tag_gid' is set
-        if ('tag_gid' not in params or
-                params['tag_gid'] is None):
+        if (tag_gid is None):
             raise ValueError("Missing the required parameter `tag_gid` when calling `get_tag`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'tag_gid' in params:
-            path_params['tag_gid'] = params['tag_gid']  # noqa: E501
+        path_params['tag_gid'] = tag_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tags/{tag_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tags/{tag_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tags/{tag_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TagResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_tags(self, **kwargs):  # noqa: E501
+    def get_tags(self, opts, **kwargs):  # noqa: E501
         """Get multiple tags  # noqa: E501
 
         Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tags(async_req=True)
         >>> result = thread.get()
@@ -473,22 +611,22 @@
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param str workspace: The workspace to filter tags on.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_tags_with_http_info(**kwargs)  # noqa: E501
+            return self.get_tags_with_http_info(opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_tags_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_tags_with_http_info(opts, **kwargs)  # noqa: E501
             return data
 
-    def get_tags_with_http_info(self, **kwargs):  # noqa: E501
+    def get_tags_with_http_info(self, opts, **kwargs):  # noqa: E501
         """Get multiple tags  # noqa: E501
 
         Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tags_with_http_info(async_req=True)
         >>> result = thread.get()
@@ -498,20 +636,22 @@
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param str workspace: The workspace to filter tags on.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['limit', 'offset', 'workspace', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_tags" % key
@@ -519,55 +659,91 @@
             params[key] = val
         del params['kwargs']
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tags', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/tags',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/tags', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TagResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_tags_for_task(self, task_gid, **kwargs):  # noqa: E501
+    def get_tags_for_task(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get a task's tags  # noqa: E501
 
         Get a compact representation of all of the tags the task has.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tags_for_task(task_gid, async_req=True)
         >>> result = thread.get()
@@ -577,22 +753,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_tags_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            return self.get_tags_for_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_tags_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            (data) = self.get_tags_for_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_tags_for_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
+    def get_tags_for_task_with_http_info(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get a task's tags  # noqa: E501
 
         Get a compact representation of all of the tags the task has.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tags_for_task_with_http_info(task_gid, async_req=True)
         >>> result = thread.get()
@@ -602,80 +778,118 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['task_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_tags_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `get_tags_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/tags', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/tasks/{task_gid}/tags',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/tags', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TagResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_tags_for_workspace(self, workspace_gid, **kwargs):  # noqa: E501
+    def get_tags_for_workspace(self, workspace_gid, opts, **kwargs):  # noqa: E501
         """Get tags in a workspace  # noqa: E501
 
         Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tags_for_workspace(workspace_gid, async_req=True)
         >>> result = thread.get()
@@ -685,22 +899,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_tags_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            return self.get_tags_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_tags_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            (data) = self.get_tags_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_tags_for_workspace_with_http_info(self, workspace_gid, **kwargs):  # noqa: E501
+    def get_tags_for_workspace_with_http_info(self, workspace_gid, opts, **kwargs):  # noqa: E501
         """Get tags in a workspace  # noqa: E501
 
         Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tags_for_workspace_with_http_info(workspace_gid, async_req=True)
         >>> result = thread.get()
@@ -710,179 +924,248 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_tags_for_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'workspace_gid' is set
-        if ('workspace_gid' not in params or
-                params['workspace_gid'] is None):
+        if (workspace_gid is None):
             raise ValueError("Missing the required parameter `workspace_gid` when calling `get_tags_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'workspace_gid' in params:
-            path_params['workspace_gid'] = params['workspace_gid']  # noqa: E501
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/tags', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/workspaces/{workspace_gid}/tags',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/workspaces/{workspace_gid}/tags', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TagResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_tag(self, tag_gid, **kwargs):  # noqa: E501
+    def update_tag(self, tag_gid, opts, **kwargs):  # noqa: E501
         """Update a tag  # noqa: E501
 
         Updates the properties of a tag. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the tag.  Returns the complete updated tag record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_tag(tag_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str tag_gid: Globally unique identifier for the tag. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_tag_with_http_info(tag_gid, **kwargs)  # noqa: E501
+            return self.update_tag_with_http_info(tag_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_tag_with_http_info(tag_gid, **kwargs)  # noqa: E501
+            (data) = self.update_tag_with_http_info(tag_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_tag_with_http_info(self, tag_gid, **kwargs):  # noqa: E501
+    def update_tag_with_http_info(self, tag_gid, opts, **kwargs):  # noqa: E501
         """Update a tag  # noqa: E501
 
         Updates the properties of a tag. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the tag.  Returns the complete updated tag record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_tag_with_http_info(tag_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str tag_gid: Globally unique identifier for the tag. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TagResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['tag_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_tag" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'tag_gid' is set
-        if ('tag_gid' not in params or
-                params['tag_gid'] is None):
+        if (tag_gid is None):
             raise ValueError("Missing the required parameter `tag_gid` when calling `update_tag`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'tag_gid' in params:
-            path_params['tag_gid'] = params['tag_gid']  # noqa: E501
+        path_params['tag_gid'] = tag_gid  # noqa: E501
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tags/{tag_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tags/{tag_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tags/{tag_gid}', 'PUT',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TagResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/tasks_api.py` & `asana_preview-1.2.40/asana_preview/api/tasks_api.py`

 * *Files 20% similar despite different names*

```diff
@@ -12,17 +12,17 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class TasksApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
@@ -38,21 +38,21 @@
         Marks a set of tasks as dependencies of this task, if they are not already dependencies. *A task can have at most 30 dependents and dependencies combined*.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_dependencies_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidAddDependenciesBody body: The list of tasks to set as dependencies. (required)
+        :param dict body: The list of tasks to set as dependencies. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.add_dependencies_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.add_dependencies_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
             return data
 
     def add_dependencies_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
@@ -61,81 +61,119 @@
         Marks a set of tasks as dependencies of this task, if they are not already dependencies. *A task can have at most 30 dependents and dependencies combined*.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_dependencies_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidAddDependenciesBody body: The list of tasks to set as dependencies. (required)
+        :param dict body: The list of tasks to set as dependencies. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_dependencies_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `add_dependencies_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `add_dependencies_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/addDependencies', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/addDependencies', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/addDependencies', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -145,21 +183,21 @@
         Marks a set of tasks as dependents of this task, if they are not already dependents. *A task can have at most 30 dependents and dependencies combined*.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_dependents_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidAddDependentsBody body: The list of tasks to add as dependents. (required)
+        :param dict body: The list of tasks to add as dependents. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.add_dependents_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.add_dependents_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
             return data
 
     def add_dependents_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
@@ -168,193 +206,267 @@
         Marks a set of tasks as dependents of this task, if they are not already dependents. *A task can have at most 30 dependents and dependencies combined*.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_dependents_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidAddDependentsBody body: The list of tasks to add as dependents. (required)
+        :param dict body: The list of tasks to add as dependents. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_dependents_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `add_dependents_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `add_dependents_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/addDependents', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/addDependents', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/addDependents', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def add_followers_for_task(self, body, task_gid, **kwargs):  # noqa: E501
+    def add_followers_for_task(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Add followers to a task  # noqa: E501
 
         Adds followers to a task. Returns an empty data block. Each task can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated task record, described above.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_followers_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidAddFollowersBody body: The followers to add to the task. (required)
+        :param dict body: The followers to add to the task. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.add_followers_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            return self.add_followers_for_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.add_followers_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            (data) = self.add_followers_for_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def add_followers_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
+    def add_followers_for_task_with_http_info(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Add followers to a task  # noqa: E501
 
         Adds followers to a task. Returns an empty data block. Each task can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated task record, described above.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_followers_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidAddFollowersBody body: The followers to add to the task. (required)
+        :param dict body: The followers to add to the task. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_followers_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `add_followers_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `add_followers_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/addFollowers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/addFollowers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/addFollowers', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -364,21 +476,21 @@
         Adds the task to the specified project, in the optional location specified. If no location arguments are given, the task will be added to the end of the project.  `addProject` can also be used to reorder a task within a project or section that already contains it.  At most one of `insert_before`, `insert_after`, or `section` should be specified. Inserting into a section in an non-order-dependent way can be done by specifying section, otherwise, to insert within a section in a particular place, specify `insert_before` or `insert_after` and a task within the section to anchor the position of this task.  Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_project_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidAddProjectBody body: The project to add the task to. (required)
+        :param dict body: The project to add the task to. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.add_project_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.add_project_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
             return data
 
     def add_project_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
@@ -387,81 +499,119 @@
         Adds the task to the specified project, in the optional location specified. If no location arguments are given, the task will be added to the end of the project.  `addProject` can also be used to reorder a task within a project or section that already contains it.  At most one of `insert_before`, `insert_after`, or `section` should be specified. Inserting into a section in an non-order-dependent way can be done by specifying section, otherwise, to insert within a section in a particular place, specify `insert_before` or `insert_after` and a task within the section to anchor the position of this task.  Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_project_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidAddProjectBody body: The project to add the task to. (required)
+        :param dict body: The project to add the task to. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_project_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `add_project_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `add_project_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/addProject', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/addProject', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/addProject', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -471,21 +621,21 @@
         Adds a tag to a task. Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_tag_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidAddTagBody body: The tag to add to the task. (required)
+        :param dict body: The tag to add to the task. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.add_tag_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.add_tag_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
             return data
 
     def add_tag_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
@@ -494,297 +644,409 @@
         Adds a tag to a task. Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.add_tag_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidAddTagBody body: The tag to add to the task. (required)
+        :param dict body: The tag to add to the task. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method add_tag_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `add_tag_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `add_tag_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/addTag', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/addTag', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/addTag', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create_subtask_for_task(self, body, task_gid, **kwargs):  # noqa: E501
+    def create_subtask_for_task(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Create a subtask  # noqa: E501
 
         Creates a new subtask and adds it to the parent task. Returns the full record for the newly created subtask.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_subtask_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidSubtasksBody body: The new subtask to create. (required)
+        :param dict body: The new subtask to create. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_subtask_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            return self.create_subtask_for_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_subtask_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            (data) = self.create_subtask_for_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_subtask_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
+    def create_subtask_for_task_with_http_info(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Create a subtask  # noqa: E501
 
         Creates a new subtask and adds it to the parent task. Returns the full record for the newly created subtask.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_subtask_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidSubtasksBody body: The new subtask to create. (required)
+        :param dict body: The new subtask to create. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_subtask_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_subtask_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `create_subtask_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/subtasks', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/subtasks', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/subtasks', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def create_task(self, body, **kwargs):  # noqa: E501
+    def create_task(self, body, opts, **kwargs):  # noqa: E501
         """Create a task  # noqa: E501
 
         Creating a new task is as easy as POSTing to the `/tasks` endpoint with a data block containing the fields you’d like to set on the task. Any unspecified fields will take on default values.  Every task is required to be created in a specific workspace, and this workspace cannot be changed once set. The workspace need not be set explicitly if you specify `projects` or a `parent` task instead.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_task(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TasksBody body: The task to create. (required)
+        :param dict body: The task to create. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_task_with_http_info(body, **kwargs)  # noqa: E501
+            return self.create_task_with_http_info(body, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_task_with_http_info(body, **kwargs)  # noqa: E501
+            (data) = self.create_task_with_http_info(body, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_task_with_http_info(self, body, **kwargs):  # noqa: E501
+    def create_task_with_http_info(self, body, opts, **kwargs):  # noqa: E501
         """Create a task  # noqa: E501
 
         Creating a new task is as easy as POSTing to the `/tasks` endpoint with a data block containing the fields you’d like to set on the task. Any unspecified fields will take on default values.  Every task is required to be created in a specific workspace, and this workspace cannot be changed once set. The workspace need not be set explicitly if you specify `projects` or a `parent` task instead.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_task_with_http_info(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TasksBody body: The task to create. (required)
+        :param dict body: The task to create. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -799,15 +1061,15 @@
 
         :param async_req bool
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.delete_task_with_http_info(task_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_task_with_http_info(task_gid, **kwargs)  # noqa: E501
             return data
 
     def delete_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
@@ -821,185 +1083,262 @@
 
         :param async_req bool
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['task_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `delete_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def duplicate_task(self, body, task_gid, **kwargs):  # noqa: E501
+    def duplicate_task(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Duplicate a task  # noqa: E501
 
         Creates and returns a job that will asynchronously handle the duplication.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.duplicate_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidDuplicateBody body: Describes the duplicate's name and the fields that will be duplicated. (required)
+        :param dict body: Describes the duplicate's name and the fields that will be duplicated. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.duplicate_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            return self.duplicate_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.duplicate_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            (data) = self.duplicate_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def duplicate_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
+    def duplicate_task_with_http_info(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Duplicate a task  # noqa: E501
 
         Creates and returns a job that will asynchronously handle the duplication.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.duplicate_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidDuplicateBody body: Describes the duplicate's name and the fields that will be duplicated. (required)
+        :param dict body: Describes the duplicate's name and the fields that will be duplicated. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: JobResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method duplicate_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `duplicate_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `duplicate_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/duplicate', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/duplicate', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/duplicate', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='JobResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_dependencies_for_task(self, task_gid, **kwargs):  # noqa: E501
+    def get_dependencies_for_task(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get dependencies from a task  # noqa: E501
 
         Returns the compact representations of all of the dependencies of a task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_dependencies_for_task(task_gid, async_req=True)
         >>> result = thread.get()
@@ -1009,22 +1348,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_dependencies_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            return self.get_dependencies_for_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_dependencies_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            (data) = self.get_dependencies_for_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_dependencies_for_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
+    def get_dependencies_for_task_with_http_info(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get dependencies from a task  # noqa: E501
 
         Returns the compact representations of all of the dependencies of a task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_dependencies_for_task_with_http_info(task_gid, async_req=True)
         >>> result = thread.get()
@@ -1034,80 +1373,118 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['task_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_dependencies_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `get_dependencies_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/dependencies', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/tasks/{task_gid}/dependencies',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/dependencies', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_dependents_for_task(self, task_gid, **kwargs):  # noqa: E501
+    def get_dependents_for_task(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get dependents from a task  # noqa: E501
 
         Returns the compact representations of all of the dependents of a task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_dependents_for_task(task_gid, async_req=True)
         >>> result = thread.get()
@@ -1117,22 +1494,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_dependents_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            return self.get_dependents_for_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_dependents_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            (data) = self.get_dependents_for_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_dependents_for_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
+    def get_dependents_for_task_with_http_info(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get dependents from a task  # noqa: E501
 
         Returns the compact representations of all of the dependents of a task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_dependents_for_task_with_http_info(task_gid, async_req=True)
         >>> result = thread.get()
@@ -1142,80 +1519,118 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['task_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_dependents_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `get_dependents_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/dependents', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/tasks/{task_gid}/dependents',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/dependents', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_subtasks_for_task(self, task_gid, **kwargs):  # noqa: E501
+    def get_subtasks_for_task(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get subtasks from a task  # noqa: E501
 
         Returns a compact representation of all of the subtasks of a task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_subtasks_for_task(task_gid, async_req=True)
         >>> result = thread.get()
@@ -1225,22 +1640,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_subtasks_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            return self.get_subtasks_for_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_subtasks_for_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            (data) = self.get_subtasks_for_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_subtasks_for_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
+    def get_subtasks_for_task_with_http_info(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get subtasks from a task  # noqa: E501
 
         Returns a compact representation of all of the subtasks of a task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_subtasks_for_task_with_http_info(task_gid, async_req=True)
         >>> result = thread.get()
@@ -1250,80 +1665,118 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['task_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_subtasks_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `get_subtasks_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/subtasks', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/tasks/{task_gid}/subtasks',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/subtasks', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_task(self, task_gid, **kwargs):  # noqa: E501
+    def get_task(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get a task  # noqa: E501
 
         Returns the complete task record for a single task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_task(task_gid, async_req=True)
         >>> result = thread.get()
@@ -1331,22 +1784,22 @@
         :param async_req bool
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            return self.get_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_task_with_http_info(task_gid, **kwargs)  # noqa: E501
+            (data) = self.get_task_with_http_info(task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_task_with_http_info(self, task_gid, **kwargs):  # noqa: E501
+    def get_task_with_http_info(self, task_gid, opts, **kwargs):  # noqa: E501
         """Get a task  # noqa: E501
 
         Returns the complete task record for a single task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_task_with_http_info(task_gid, async_req=True)
         >>> result = thread.get()
@@ -1354,76 +1807,257 @@
         :param async_req bool
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['task_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `get_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_tasks(self, **kwargs):  # noqa: E501
+    def get_task_for_custom_id(self, workspace_gid, custom_id, **kwargs):  # noqa: E501
+        """Get a task for a given custom ID  # noqa: E501
+
+        Returns a task given a custom ID shortcode.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.get_task_for_custom_id(workspace_gid, custom_id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
+        :param str custom_id: Generated custom ID for a task. (required)
+        :return: TaskResponseData
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
+        if kwargs.get('async_req'):
+            return self.get_task_for_custom_id_with_http_info(workspace_gid, custom_id, **kwargs)  # noqa: E501
+        else:
+            (data) = self.get_task_for_custom_id_with_http_info(workspace_gid, custom_id, **kwargs)  # noqa: E501
+            return data
+
+    def get_task_for_custom_id_with_http_info(self, workspace_gid, custom_id, **kwargs):  # noqa: E501
+        """Get a task for a given custom ID  # noqa: E501
+
+        Returns a task given a custom ID shortcode.  # noqa: E501
+        This method makes a synchronous HTTP request by default. To make an
+        asynchronous HTTP request, please pass async_req=True
+        >>> thread = api.get_task_for_custom_id_with_http_info(workspace_gid, custom_id, async_req=True)
+        >>> result = thread.get()
+
+        :param async_req bool
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
+        :param str custom_id: Generated custom ID for a task. (required)
+        :return: TaskResponseData
+                 If the method is called asynchronously,
+                 returns the request thread.
+        """
+        all_params = []
+        all_params.append('async_req')
+        all_params.append('header_params')
+        all_params.append('_return_http_data_only')
+        all_params.append('_preload_content')
+        all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
+
+        params = locals()
+        for key, val in six.iteritems(params['kwargs']):
+            if key not in all_params:
+                raise TypeError(
+                    "Got an unexpected keyword argument '%s'"
+                    " to method get_task_for_custom_id" % key
+                )
+            params[key] = val
+        del params['kwargs']
+        # verify the required parameter 'workspace_gid' is set
+        if (workspace_gid is None):
+            raise ValueError("Missing the required parameter `workspace_gid` when calling `get_task_for_custom_id`")  # noqa: E501
+        # verify the required parameter 'custom_id' is set
+        if (custom_id is None):
+            raise ValueError("Missing the required parameter `custom_id` when calling `get_task_for_custom_id`")  # noqa: E501
+
+        collection_formats = {}
+
+        path_params = {}
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
+        path_params['custom_id'] = custom_id  # noqa: E501
+
+        query_params = {}
+
+
+        header_params = kwargs.get("header_params", {})
+
+        form_params = []
+        local_var_files = {}
+
+        body_params = None
+
+        # HTTP header `Accept`
+        header_params['Accept'] = self.api_client.select_header_accept(
+            ['application/json; charset=UTF-8'])  # noqa: E501
+
+        # Authentication setting
+        auth_settings = ['personalAccessToken']  # noqa: E501
+
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/tasks/custom_id/{custom_id}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/workspaces/{workspace_gid}/tasks/custom_id/{custom_id}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/workspaces/{workspace_gid}/tasks/custom_id/{custom_id}', 'GET',
+            path_params,
+            query_params,
+            header_params,
+            body=body_params,
+            post_params=form_params,
+            files=local_var_files,
+            response_type=object,  # noqa: E501
+            auth_settings=auth_settings,
+            async_req=params.get('async_req'),
+            _return_http_data_only=params.get('_return_http_data_only'),
+            _preload_content=params.get('_preload_content', True),
+            _request_timeout=params.get('_request_timeout'),
+            collection_formats=collection_formats)
+
+    def get_tasks(self, opts, **kwargs):  # noqa: E501
         """Get multiple tasks  # noqa: E501
 
         Returns the compact task records for some filtered set of tasks. Use one or more of the parameters provided to filter the tasks returned. You must specify a `project` or `tag` if you do not specify `assignee` and `workspace`.  For more complex task retrieval, use [workspaces/{workspace_gid}/tasks/search](/reference/searchtasksforworkspace).  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tasks(async_req=True)
         >>> result = thread.get()
@@ -1438,22 +2072,22 @@
         :param datetime completed_since: Only return tasks that are either incomplete or that have been completed since this time.
         :param datetime modified_since: Only return tasks that have been modified since the given time.  *Note: A task is considered “modified” if any of its properties change, or associations between it and other objects are modified (e.g.  a task being added to a project). A task is not considered modified just because another object it is associated with (e.g. a subtask) is modified. Actions that count as modifying the task include assigning, renaming, completing, and adding stories.*
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_tasks_with_http_info(**kwargs)  # noqa: E501
+            return self.get_tasks_with_http_info(opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_tasks_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.get_tasks_with_http_info(opts, **kwargs)  # noqa: E501
             return data
 
-    def get_tasks_with_http_info(self, **kwargs):  # noqa: E501
+    def get_tasks_with_http_info(self, opts, **kwargs):  # noqa: E501
         """Get multiple tasks  # noqa: E501
 
         Returns the compact task records for some filtered set of tasks. Use one or more of the parameters provided to filter the tasks returned. You must specify a `project` or `tag` if you do not specify `assignee` and `workspace`.  For more complex task retrieval, use [workspaces/{workspace_gid}/tasks/search](/reference/searchtasksforworkspace).  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tasks_with_http_info(async_req=True)
         >>> result = thread.get()
@@ -1468,20 +2102,22 @@
         :param datetime completed_since: Only return tasks that are either incomplete or that have been completed since this time.
         :param datetime modified_since: Only return tasks that have been modified since the given time.  *Note: A task is considered “modified” if any of its properties change, or associations between it and other objects are modified (e.g.  a task being added to a project). A task is not considered modified just because another object it is associated with (e.g. a subtask) is modified. Actions that count as modifying the task include assigning, renaming, completing, and adding stories.*
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['limit', 'offset', 'assignee', 'project', 'section', 'workspace', 'completed_since', 'modified_since', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_tasks" % key
@@ -1489,65 +2125,91 @@
             params[key] = val
         del params['kwargs']
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'assignee' in params:
-            query_params.append(('assignee', params['assignee']))  # noqa: E501
-        if 'project' in params:
-            query_params.append(('project', params['project']))  # noqa: E501
-        if 'section' in params:
-            query_params.append(('section', params['section']))  # noqa: E501
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'completed_since' in params:
-            query_params.append(('completed_since', params['completed_since']))  # noqa: E501
-        if 'modified_since' in params:
-            query_params.append(('modified_since', params['modified_since']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
+        auth_settings = ['personalAccessToken']  # noqa: E501
+
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/tasks',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/tasks', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_tasks_for_project(self, project_gid, **kwargs):  # noqa: E501
+    def get_tasks_for_project(self, project_gid, opts, **kwargs):  # noqa: E501
         """Get tasks from a project  # noqa: E501
 
         Returns the compact task records for all tasks within the given project, ordered by their priority within the project. Tasks can exist in more than one project at a time.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tasks_for_project(project_gid, async_req=True)
         >>> result = thread.get()
@@ -1558,22 +2220,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_tasks_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            return self.get_tasks_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_tasks_for_project_with_http_info(project_gid, **kwargs)  # noqa: E501
+            (data) = self.get_tasks_for_project_with_http_info(project_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_tasks_for_project_with_http_info(self, project_gid, **kwargs):  # noqa: E501
+    def get_tasks_for_project_with_http_info(self, project_gid, opts, **kwargs):  # noqa: E501
         """Get tasks from a project  # noqa: E501
 
         Returns the compact task records for all tasks within the given project, ordered by their priority within the project. Tasks can exist in more than one project at a time.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tasks_for_project_with_http_info(project_gid, async_req=True)
         >>> result = thread.get()
@@ -1584,190 +2246,266 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['project_gid', 'completed_since', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_tasks_for_project" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'project_gid' is set
-        if ('project_gid' not in params or
-                params['project_gid'] is None):
+        if (project_gid is None):
             raise ValueError("Missing the required parameter `project_gid` when calling `get_tasks_for_project`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'project_gid' in params:
-            path_params['project_gid'] = params['project_gid']  # noqa: E501
+        path_params['project_gid'] = project_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'completed_since' in params:
-            query_params.append(('completed_since', params['completed_since']))  # noqa: E501
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/projects/{project_gid}/tasks', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/projects/{project_gid}/tasks',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/projects/{project_gid}/tasks', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_tasks_for_section(self, section_gid, **kwargs):  # noqa: E501
+    def get_tasks_for_section(self, section_gid, opts, **kwargs):  # noqa: E501
         """Get tasks from a section  # noqa: E501
 
         *Board view only*: Returns the compact section records for all tasks within the given section.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tasks_for_section(section_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str section_gid: The globally unique identifier for the section. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str completed_since: Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_tasks_for_section_with_http_info(section_gid, **kwargs)  # noqa: E501
+            return self.get_tasks_for_section_with_http_info(section_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_tasks_for_section_with_http_info(section_gid, **kwargs)  # noqa: E501
+            (data) = self.get_tasks_for_section_with_http_info(section_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_tasks_for_section_with_http_info(self, section_gid, **kwargs):  # noqa: E501
+    def get_tasks_for_section_with_http_info(self, section_gid, opts, **kwargs):  # noqa: E501
         """Get tasks from a section  # noqa: E501
 
         *Board view only*: Returns the compact section records for all tasks within the given section.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tasks_for_section_with_http_info(section_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str section_gid: The globally unique identifier for the section. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str completed_since: Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['section_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_tasks_for_section" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'section_gid' is set
-        if ('section_gid' not in params or
-                params['section_gid'] is None):
+        if (section_gid is None):
             raise ValueError("Missing the required parameter `section_gid` when calling `get_tasks_for_section`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'section_gid' in params:
-            path_params['section_gid'] = params['section_gid']  # noqa: E501
+        path_params['section_gid'] = section_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/sections/{section_gid}/tasks', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/sections/{section_gid}/tasks',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/sections/{section_gid}/tasks', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_tasks_for_tag(self, tag_gid, **kwargs):  # noqa: E501
+    def get_tasks_for_tag(self, tag_gid, opts, **kwargs):  # noqa: E501
         """Get tasks from a tag  # noqa: E501
 
         Returns the compact task records for all tasks with the given tag. Tasks can have more than one tag at a time.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tasks_for_tag(tag_gid, async_req=True)
         >>> result = thread.get()
@@ -1777,22 +2515,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_tasks_for_tag_with_http_info(tag_gid, **kwargs)  # noqa: E501
+            return self.get_tasks_for_tag_with_http_info(tag_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_tasks_for_tag_with_http_info(tag_gid, **kwargs)  # noqa: E501
+            (data) = self.get_tasks_for_tag_with_http_info(tag_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_tasks_for_tag_with_http_info(self, tag_gid, **kwargs):  # noqa: E501
+    def get_tasks_for_tag_with_http_info(self, tag_gid, opts, **kwargs):  # noqa: E501
         """Get tasks from a tag  # noqa: E501
 
         Returns the compact task records for all tasks with the given tag. Tasks can have more than one tag at a time.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tasks_for_tag_with_http_info(tag_gid, async_req=True)
         >>> result = thread.get()
@@ -1802,80 +2540,118 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['tag_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_tasks_for_tag" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'tag_gid' is set
-        if ('tag_gid' not in params or
-                params['tag_gid'] is None):
+        if (tag_gid is None):
             raise ValueError("Missing the required parameter `tag_gid` when calling `get_tasks_for_tag`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'tag_gid' in params:
-            path_params['tag_gid'] = params['tag_gid']  # noqa: E501
+        path_params['tag_gid'] = tag_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tags/{tag_gid}/tasks', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/tags/{tag_gid}/tasks',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/tags/{tag_gid}/tasks', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_tasks_for_user_task_list(self, user_task_list_gid, **kwargs):  # noqa: E501
+    def get_tasks_for_user_task_list(self, user_task_list_gid, opts, **kwargs):  # noqa: E501
         """Get tasks from a user task list  # noqa: E501
 
         Returns the compact list of tasks in a user’s My Tasks list. *Note: Access control is enforced for this endpoint as with all Asana API endpoints, meaning a user’s private tasks will be filtered out if the API-authenticated user does not have access to them.* *Note: Both complete and incomplete tasks are returned by default unless they are filtered out (for example, setting `completed_since=now` will return only incomplete tasks, which is the default view for “My Tasks” in Asana.)*  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tasks_for_user_task_list(user_task_list_gid, async_req=True)
         >>> result = thread.get()
@@ -1886,22 +2662,22 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_tasks_for_user_task_list_with_http_info(user_task_list_gid, **kwargs)  # noqa: E501
+            return self.get_tasks_for_user_task_list_with_http_info(user_task_list_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_tasks_for_user_task_list_with_http_info(user_task_list_gid, **kwargs)  # noqa: E501
+            (data) = self.get_tasks_for_user_task_list_with_http_info(user_task_list_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_tasks_for_user_task_list_with_http_info(self, user_task_list_gid, **kwargs):  # noqa: E501
+    def get_tasks_for_user_task_list_with_http_info(self, user_task_list_gid, opts, **kwargs):  # noqa: E501
         """Get tasks from a user task list  # noqa: E501
 
         Returns the compact list of tasks in a user’s My Tasks list. *Note: Access control is enforced for this endpoint as with all Asana API endpoints, meaning a user’s private tasks will be filtered out if the API-authenticated user does not have access to them.* *Note: Both complete and incomplete tasks are returned by default unless they are filtered out (for example, setting `completed_since=now` will return only incomplete tasks, which is the default view for “My Tasks” in Asana.)*  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_tasks_for_user_task_list_with_http_info(user_task_list_gid, async_req=True)
         >>> result = thread.get()
@@ -1912,74 +2688,110 @@
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['user_task_list_gid', 'completed_since', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_tasks_for_user_task_list" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'user_task_list_gid' is set
-        if ('user_task_list_gid' not in params or
-                params['user_task_list_gid'] is None):
+        if (user_task_list_gid is None):
             raise ValueError("Missing the required parameter `user_task_list_gid` when calling `get_tasks_for_user_task_list`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'user_task_list_gid' in params:
-            path_params['user_task_list_gid'] = params['user_task_list_gid']  # noqa: E501
+        path_params['user_task_list_gid'] = user_task_list_gid  # noqa: E501
 
-        query_params = []
-        if 'completed_since' in params:
-            query_params.append(('completed_since', params['completed_since']))  # noqa: E501
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/user_task_lists/{user_task_list_gid}/tasks', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/user_task_lists/{user_task_list_gid}/tasks',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/user_task_lists/{user_task_list_gid}/tasks', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -1989,21 +2801,21 @@
         Unlinks a set of dependencies from this task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_dependencies_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidRemoveDependenciesBody body: The list of tasks to unlink as dependencies. (required)
+        :param dict body: The list of tasks to unlink as dependencies. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.remove_dependencies_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.remove_dependencies_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
             return data
 
     def remove_dependencies_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
@@ -2012,81 +2824,119 @@
         Unlinks a set of dependencies from this task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_dependencies_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidRemoveDependenciesBody body: The list of tasks to unlink as dependencies. (required)
+        :param dict body: The list of tasks to unlink as dependencies. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_dependencies_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `remove_dependencies_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `remove_dependencies_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/removeDependencies', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/removeDependencies', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/removeDependencies', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -2096,21 +2946,21 @@
         Unlinks a set of dependents from this task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_dependents_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidRemoveDependentsBody body: The list of tasks to remove as dependents. (required)
+        :param dict body: The list of tasks to remove as dependents. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.remove_dependents_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.remove_dependents_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
             return data
 
     def remove_dependents_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
@@ -2119,193 +2969,267 @@
         Unlinks a set of dependents from this task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_dependents_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidRemoveDependentsBody body: The list of tasks to remove as dependents. (required)
+        :param dict body: The list of tasks to remove as dependents. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_dependents_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `remove_dependents_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `remove_dependents_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/removeDependents', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/removeDependents', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/removeDependents', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def remove_follower_for_task(self, body, task_gid, **kwargs):  # noqa: E501
+    def remove_follower_for_task(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Remove followers from a task  # noqa: E501
 
         Removes each of the specified followers from the task if they are following. Returns the complete, updated record for the affected task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_follower_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidRemoveFollowersBody body: The followers to remove from the task. (required)
+        :param dict body: The followers to remove from the task. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.remove_follower_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            return self.remove_follower_for_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.remove_follower_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            (data) = self.remove_follower_for_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def remove_follower_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
+    def remove_follower_for_task_with_http_info(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Remove followers from a task  # noqa: E501
 
         Removes each of the specified followers from the task if they are following. Returns the complete, updated record for the affected task.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_follower_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidRemoveFollowersBody body: The followers to remove from the task. (required)
+        :param dict body: The followers to remove from the task. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_follower_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `remove_follower_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `remove_follower_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/removeFollowers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/removeFollowers', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/removeFollowers', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -2315,21 +3239,21 @@
         Removes the task from the specified project. The task will still exist in the system, but it will not be in the project anymore.  Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_project_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidRemoveProjectBody body: The project to remove the task from. (required)
+        :param dict body: The project to remove the task from. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.remove_project_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.remove_project_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
             return data
 
     def remove_project_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
@@ -2338,81 +3262,119 @@
         Removes the task from the specified project. The task will still exist in the system, but it will not be in the project anymore.  Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_project_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidRemoveProjectBody body: The project to remove the task from. (required)
+        :param dict body: The project to remove the task from. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_project_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `remove_project_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `remove_project_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/removeProject', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/removeProject', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/removeProject', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -2422,21 +3384,21 @@
         Removes a tag from a task. Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_tag_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidRemoveTagBody body: The tag to remove from the task. (required)
+        :param dict body: The tag to remove from the task. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.remove_tag_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.remove_tag_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
             return data
 
     def remove_tag_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
@@ -2445,612 +3407,672 @@
         Removes a tag from a task. Returns an empty data block.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.remove_tag_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidRemoveTagBody body: The tag to remove from the task. (required)
+        :param dict body: The tag to remove from the task. (required)
         :param str task_gid: The task to operate on. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method remove_tag_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `remove_tag_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `remove_tag_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
 
-        query_params = []
+        query_params = {}
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/removeTag', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/removeTag', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/removeTag', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def search_tasks_for_workspace(self, workspace_gid, **kwargs):  # noqa: E501
+    def search_tasks_for_workspace(self, workspace_gid, opts, **kwargs):  # noqa: E501
         """Search tasks in a workspace  # noqa: E501
 
         To mirror the functionality of the Asana web app's advanced search feature, the Asana API has a task search endpoint that allows you to build complex filters to find and retrieve the exact data you need. #### Premium access Like the Asana web product's advance search feature, this search endpoint will only be available to premium Asana users. A user is premium if any of the following is true:  - The workspace in which the search is being performed is a premium workspace - The user is a member of a premium team inside the workspace  Even if a user is only a member of a premium team inside a non-premium workspace, search will allow them to find data anywhere in the workspace, not just inside the premium team. Making a search request using credentials of a non-premium user will result in a `402 Payment Required` error. #### Pagination Search results are not stable; repeating the same query multiple times may return the data in a different order, even if the data do not change. Because of this, the traditional [pagination](https://developers.asana.com/docs/#pagination) available elsewhere in the Asana API is not available here. However, you can paginate manually by sorting the search results by their creation time and then modifying each subsequent query to exclude data you have already seen. Page sizes are limited to a maximum of 100 items, and can be specified by the `limit` query parameter. #### Eventual consistency Changes in Asana (regardless of whether they’re made though the web product or the API) are forwarded to our search infrastructure to be indexed. This process can take between 10 and 60 seconds to complete under normal operation, and longer during some production incidents. Making a change to a task that would alter its presence in a particular search query will not be reflected immediately. This is also true of the advanced search feature in the web product. #### Rate limits You may receive a `429 Too Many Requests` response if you hit any of our [rate limits](https://developers.asana.com/docs/#rate-limits). #### Custom field parameters | Parameter name | Custom field type | Accepted type | |---|---|---| | custom_fields.{gid}.is_set | All | Boolean | | custom_fields.{gid}.value | Text | String | | custom_fields.{gid}.value | Number | Number | | custom_fields.{gid}.value | Enum | Enum option ID | | custom_fields.{gid}.starts_with | Text only | String | | custom_fields.{gid}.ends_with | Text only | String | | custom_fields.{gid}.contains | Text only | String | | custom_fields.{gid}.less_than | Number only | Number | | custom_fields.{gid}.greater_than | Number only | Number |   For example, if the gid of the custom field is 12345, these query parameter to find tasks where it is set would be `custom_fields.12345.is_set=true`. To match an exact value for an enum custom field, use the gid of the desired enum option and not the name of the enum option: `custom_fields.12345.value=67890`.  **Not Supported**: searching for multiple exact matches of a custom field, searching for multi-enum custom field  *Note: If you specify `projects.any` and `sections.any`, you will receive tasks for the project **and** tasks for the section. If you're looking for only tasks in a section, omit the `projects.any` from the request.*  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_tasks_for_workspace(workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param str text: Performs full-text search on both task name and description
         :param str resource_subtype: Filters results by the task's resource_subtype
-        :param str assignee_any: Comma-separated list of user identifiers
-        :param str assignee_not: Comma-separated list of user identifiers
-        :param str portfolios_any: Comma-separated list of portfolio IDs
-        :param str projects_any: Comma-separated list of project IDs
-        :param str projects_not: Comma-separated list of project IDs
-        :param str projects_all: Comma-separated list of project IDs
-        :param str sections_any: Comma-separated list of section or column IDs
-        :param str sections_not: Comma-separated list of section or column IDs
-        :param str sections_all: Comma-separated list of section or column IDs
-        :param str tags_any: Comma-separated list of tag IDs
-        :param str tags_not: Comma-separated list of tag IDs
-        :param str tags_all: Comma-separated list of tag IDs
-        :param str teams_any: Comma-separated list of team IDs
-        :param str followers_not: Comma-separated list of user identifiers
-        :param str created_by_any: Comma-separated list of user identifiers
-        :param str created_by_not: Comma-separated list of user identifiers
-        :param str assigned_by_any: Comma-separated list of user identifiers
-        :param str assigned_by_not: Comma-separated list of user identifiers
-        :param str liked_by_not: Comma-separated list of user identifiers
-        :param str commented_on_by_not: Comma-separated list of user identifiers
-        :param date due_on_before: ISO 8601 date string
-        :param date due_on_after: ISO 8601 date string
+        :param str assignee.any: Comma-separated list of user identifiers
+        :param str assignee.not: Comma-separated list of user identifiers
+        :param str portfolios.any: Comma-separated list of portfolio IDs
+        :param str projects.any: Comma-separated list of project IDs
+        :param str projects.not: Comma-separated list of project IDs
+        :param str projects.all: Comma-separated list of project IDs
+        :param str sections.any: Comma-separated list of section or column IDs
+        :param str sections.not: Comma-separated list of section or column IDs
+        :param str sections.all: Comma-separated list of section or column IDs
+        :param str tags.any: Comma-separated list of tag IDs
+        :param str tags.not: Comma-separated list of tag IDs
+        :param str tags.all: Comma-separated list of tag IDs
+        :param str teams.any: Comma-separated list of team IDs
+        :param str followers.not: Comma-separated list of user identifiers
+        :param str created_by.any: Comma-separated list of user identifiers
+        :param str created_by.not: Comma-separated list of user identifiers
+        :param str assigned_by.any: Comma-separated list of user identifiers
+        :param str assigned_by.not: Comma-separated list of user identifiers
+        :param str liked_by.not: Comma-separated list of user identifiers
+        :param str commented_on_by.not: Comma-separated list of user identifiers
+        :param date due_on.before: ISO 8601 date string
+        :param date due_on.after: ISO 8601 date string
         :param date due_on: ISO 8601 date string or `null`
-        :param datetime due_at_before: ISO 8601 datetime string
-        :param datetime due_at_after: ISO 8601 datetime string
-        :param date start_on_before: ISO 8601 date string
-        :param date start_on_after: ISO 8601 date string
+        :param datetime due_at.before: ISO 8601 datetime string
+        :param datetime due_at.after: ISO 8601 datetime string
+        :param date start_on.before: ISO 8601 date string
+        :param date start_on.after: ISO 8601 date string
         :param date start_on: ISO 8601 date string or `null`
-        :param date created_on_before: ISO 8601 date string
-        :param date created_on_after: ISO 8601 date string
+        :param date created_on.before: ISO 8601 date string
+        :param date created_on.after: ISO 8601 date string
         :param date created_on: ISO 8601 date string or `null`
-        :param datetime created_at_before: ISO 8601 datetime string
-        :param datetime created_at_after: ISO 8601 datetime string
-        :param date completed_on_before: ISO 8601 date string
-        :param date completed_on_after: ISO 8601 date string
+        :param datetime created_at.before: ISO 8601 datetime string
+        :param datetime created_at.after: ISO 8601 datetime string
+        :param date completed_on.before: ISO 8601 date string
+        :param date completed_on.after: ISO 8601 date string
         :param date completed_on: ISO 8601 date string or `null`
-        :param datetime completed_at_before: ISO 8601 datetime string
-        :param datetime completed_at_after: ISO 8601 datetime string
-        :param date modified_on_before: ISO 8601 date string
-        :param date modified_on_after: ISO 8601 date string
+        :param datetime completed_at.before: ISO 8601 datetime string
+        :param datetime completed_at.after: ISO 8601 datetime string
+        :param date modified_on.before: ISO 8601 date string
+        :param date modified_on.after: ISO 8601 date string
         :param date modified_on: ISO 8601 date string or `null`
-        :param datetime modified_at_before: ISO 8601 datetime string
-        :param datetime modified_at_after: ISO 8601 datetime string
+        :param datetime modified_at.before: ISO 8601 datetime string
+        :param datetime modified_at.after: ISO 8601 datetime string
         :param bool is_blocking: Filter to incomplete tasks with dependents
         :param bool is_blocked: Filter to tasks with incomplete dependencies
         :param bool has_attachment: Filter to tasks with attachments
         :param bool completed: Filter to completed tasks
         :param bool is_subtask: Filter to subtasks
         :param str sort_by: One of `due_date`, `created_at`, `completed_at`, `likes`, or `modified_at`, defaults to `modified_at`
         :param bool sort_ascending: Default `false`
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.search_tasks_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            return self.search_tasks_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.search_tasks_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            (data) = self.search_tasks_for_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def search_tasks_for_workspace_with_http_info(self, workspace_gid, **kwargs):  # noqa: E501
+    def search_tasks_for_workspace_with_http_info(self, workspace_gid, opts, **kwargs):  # noqa: E501
         """Search tasks in a workspace  # noqa: E501
 
         To mirror the functionality of the Asana web app's advanced search feature, the Asana API has a task search endpoint that allows you to build complex filters to find and retrieve the exact data you need. #### Premium access Like the Asana web product's advance search feature, this search endpoint will only be available to premium Asana users. A user is premium if any of the following is true:  - The workspace in which the search is being performed is a premium workspace - The user is a member of a premium team inside the workspace  Even if a user is only a member of a premium team inside a non-premium workspace, search will allow them to find data anywhere in the workspace, not just inside the premium team. Making a search request using credentials of a non-premium user will result in a `402 Payment Required` error. #### Pagination Search results are not stable; repeating the same query multiple times may return the data in a different order, even if the data do not change. Because of this, the traditional [pagination](https://developers.asana.com/docs/#pagination) available elsewhere in the Asana API is not available here. However, you can paginate manually by sorting the search results by their creation time and then modifying each subsequent query to exclude data you have already seen. Page sizes are limited to a maximum of 100 items, and can be specified by the `limit` query parameter. #### Eventual consistency Changes in Asana (regardless of whether they’re made though the web product or the API) are forwarded to our search infrastructure to be indexed. This process can take between 10 and 60 seconds to complete under normal operation, and longer during some production incidents. Making a change to a task that would alter its presence in a particular search query will not be reflected immediately. This is also true of the advanced search feature in the web product. #### Rate limits You may receive a `429 Too Many Requests` response if you hit any of our [rate limits](https://developers.asana.com/docs/#rate-limits). #### Custom field parameters | Parameter name | Custom field type | Accepted type | |---|---|---| | custom_fields.{gid}.is_set | All | Boolean | | custom_fields.{gid}.value | Text | String | | custom_fields.{gid}.value | Number | Number | | custom_fields.{gid}.value | Enum | Enum option ID | | custom_fields.{gid}.starts_with | Text only | String | | custom_fields.{gid}.ends_with | Text only | String | | custom_fields.{gid}.contains | Text only | String | | custom_fields.{gid}.less_than | Number only | Number | | custom_fields.{gid}.greater_than | Number only | Number |   For example, if the gid of the custom field is 12345, these query parameter to find tasks where it is set would be `custom_fields.12345.is_set=true`. To match an exact value for an enum custom field, use the gid of the desired enum option and not the name of the enum option: `custom_fields.12345.value=67890`.  **Not Supported**: searching for multiple exact matches of a custom field, searching for multi-enum custom field  *Note: If you specify `projects.any` and `sections.any`, you will receive tasks for the project **and** tasks for the section. If you're looking for only tasks in a section, omit the `projects.any` from the request.*  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.search_tasks_for_workspace_with_http_info(workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param str text: Performs full-text search on both task name and description
         :param str resource_subtype: Filters results by the task's resource_subtype
-        :param str assignee_any: Comma-separated list of user identifiers
-        :param str assignee_not: Comma-separated list of user identifiers
-        :param str portfolios_any: Comma-separated list of portfolio IDs
-        :param str projects_any: Comma-separated list of project IDs
-        :param str projects_not: Comma-separated list of project IDs
-        :param str projects_all: Comma-separated list of project IDs
-        :param str sections_any: Comma-separated list of section or column IDs
-        :param str sections_not: Comma-separated list of section or column IDs
-        :param str sections_all: Comma-separated list of section or column IDs
-        :param str tags_any: Comma-separated list of tag IDs
-        :param str tags_not: Comma-separated list of tag IDs
-        :param str tags_all: Comma-separated list of tag IDs
-        :param str teams_any: Comma-separated list of team IDs
-        :param str followers_not: Comma-separated list of user identifiers
-        :param str created_by_any: Comma-separated list of user identifiers
-        :param str created_by_not: Comma-separated list of user identifiers
-        :param str assigned_by_any: Comma-separated list of user identifiers
-        :param str assigned_by_not: Comma-separated list of user identifiers
-        :param str liked_by_not: Comma-separated list of user identifiers
-        :param str commented_on_by_not: Comma-separated list of user identifiers
-        :param date due_on_before: ISO 8601 date string
-        :param date due_on_after: ISO 8601 date string
+        :param str assignee.any: Comma-separated list of user identifiers
+        :param str assignee.not: Comma-separated list of user identifiers
+        :param str portfolios.any: Comma-separated list of portfolio IDs
+        :param str projects.any: Comma-separated list of project IDs
+        :param str projects.not: Comma-separated list of project IDs
+        :param str projects.all: Comma-separated list of project IDs
+        :param str sections.any: Comma-separated list of section or column IDs
+        :param str sections.not: Comma-separated list of section or column IDs
+        :param str sections.all: Comma-separated list of section or column IDs
+        :param str tags.any: Comma-separated list of tag IDs
+        :param str tags.not: Comma-separated list of tag IDs
+        :param str tags.all: Comma-separated list of tag IDs
+        :param str teams.any: Comma-separated list of team IDs
+        :param str followers.not: Comma-separated list of user identifiers
+        :param str created_by.any: Comma-separated list of user identifiers
+        :param str created_by.not: Comma-separated list of user identifiers
+        :param str assigned_by.any: Comma-separated list of user identifiers
+        :param str assigned_by.not: Comma-separated list of user identifiers
+        :param str liked_by.not: Comma-separated list of user identifiers
+        :param str commented_on_by.not: Comma-separated list of user identifiers
+        :param date due_on.before: ISO 8601 date string
+        :param date due_on.after: ISO 8601 date string
         :param date due_on: ISO 8601 date string or `null`
-        :param datetime due_at_before: ISO 8601 datetime string
-        :param datetime due_at_after: ISO 8601 datetime string
-        :param date start_on_before: ISO 8601 date string
-        :param date start_on_after: ISO 8601 date string
+        :param datetime due_at.before: ISO 8601 datetime string
+        :param datetime due_at.after: ISO 8601 datetime string
+        :param date start_on.before: ISO 8601 date string
+        :param date start_on.after: ISO 8601 date string
         :param date start_on: ISO 8601 date string or `null`
-        :param date created_on_before: ISO 8601 date string
-        :param date created_on_after: ISO 8601 date string
+        :param date created_on.before: ISO 8601 date string
+        :param date created_on.after: ISO 8601 date string
         :param date created_on: ISO 8601 date string or `null`
-        :param datetime created_at_before: ISO 8601 datetime string
-        :param datetime created_at_after: ISO 8601 datetime string
-        :param date completed_on_before: ISO 8601 date string
-        :param date completed_on_after: ISO 8601 date string
+        :param datetime created_at.before: ISO 8601 datetime string
+        :param datetime created_at.after: ISO 8601 datetime string
+        :param date completed_on.before: ISO 8601 date string
+        :param date completed_on.after: ISO 8601 date string
         :param date completed_on: ISO 8601 date string or `null`
-        :param datetime completed_at_before: ISO 8601 datetime string
-        :param datetime completed_at_after: ISO 8601 datetime string
-        :param date modified_on_before: ISO 8601 date string
-        :param date modified_on_after: ISO 8601 date string
+        :param datetime completed_at.before: ISO 8601 datetime string
+        :param datetime completed_at.after: ISO 8601 datetime string
+        :param date modified_on.before: ISO 8601 date string
+        :param date modified_on.after: ISO 8601 date string
         :param date modified_on: ISO 8601 date string or `null`
-        :param datetime modified_at_before: ISO 8601 datetime string
-        :param datetime modified_at_after: ISO 8601 datetime string
+        :param datetime modified_at.before: ISO 8601 datetime string
+        :param datetime modified_at.after: ISO 8601 datetime string
         :param bool is_blocking: Filter to incomplete tasks with dependents
         :param bool is_blocked: Filter to tasks with incomplete dependencies
         :param bool has_attachment: Filter to tasks with attachments
         :param bool completed: Filter to completed tasks
         :param bool is_subtask: Filter to subtasks
         :param str sort_by: One of `due_date`, `created_at`, `completed_at`, `likes`, or `modified_at`, defaults to `modified_at`
         :param bool sort_ascending: Default `false`
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace_gid', 'text', 'resource_subtype', 'assignee_any', 'assignee_not', 'portfolios_any', 'projects_any', 'projects_not', 'projects_all', 'sections_any', 'sections_not', 'sections_all', 'tags_any', 'tags_not', 'tags_all', 'teams_any', 'followers_not', 'created_by_any', 'created_by_not', 'assigned_by_any', 'assigned_by_not', 'liked_by_not', 'commented_on_by_not', 'due_on_before', 'due_on_after', 'due_on', 'due_at_before', 'due_at_after', 'start_on_before', 'start_on_after', 'start_on', 'created_on_before', 'created_on_after', 'created_on', 'created_at_before', 'created_at_after', 'completed_on_before', 'completed_on_after', 'completed_on', 'completed_at_before', 'completed_at_after', 'modified_on_before', 'modified_on_after', 'modified_on', 'modified_at_before', 'modified_at_after', 'is_blocking', 'is_blocked', 'has_attachment', 'completed', 'is_subtask', 'sort_by', 'sort_ascending', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
+        matchSnakeCase = '^custom_fields_(.*?)_.*$'
+        custom_fields_query_param_keys = []
         for key, val in six.iteritems(params['kwargs']):
+            # Do not throw an error if the user provides custom field query parameters
+            if (re.match(matchSnakeCase, key)):
+                custom_field_gid = re.search(matchSnakeCase, key).group(1)
+                custom_field_query_param_key = key.replace(f'custom_fields_{custom_field_gid}_', f'custom_fields.{custom_field_gid}.')
+                params[custom_field_query_param_key] = val
+                custom_fields_query_param_keys.append(custom_field_query_param_key)
+                continue
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method search_tasks_for_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'workspace_gid' is set
-        if ('workspace_gid' not in params or
-                params['workspace_gid'] is None):
+        if (workspace_gid is None):
             raise ValueError("Missing the required parameter `workspace_gid` when calling `search_tasks_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'workspace_gid' in params:
-            path_params['workspace_gid'] = params['workspace_gid']  # noqa: E501
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
 
-        query_params = []
-        if 'text' in params:
-            query_params.append(('text', params['text']))  # noqa: E501
-        if 'resource_subtype' in params:
-            query_params.append(('resource_subtype', params['resource_subtype']))  # noqa: E501
-        if 'assignee_any' in params:
-            query_params.append(('assignee.any', params['assignee_any']))  # noqa: E501
-        if 'assignee_not' in params:
-            query_params.append(('assignee.not', params['assignee_not']))  # noqa: E501
-        if 'portfolios_any' in params:
-            query_params.append(('portfolios.any', params['portfolios_any']))  # noqa: E501
-        if 'projects_any' in params:
-            query_params.append(('projects.any', params['projects_any']))  # noqa: E501
-        if 'projects_not' in params:
-            query_params.append(('projects.not', params['projects_not']))  # noqa: E501
-        if 'projects_all' in params:
-            query_params.append(('projects.all', params['projects_all']))  # noqa: E501
-        if 'sections_any' in params:
-            query_params.append(('sections.any', params['sections_any']))  # noqa: E501
-        if 'sections_not' in params:
-            query_params.append(('sections.not', params['sections_not']))  # noqa: E501
-        if 'sections_all' in params:
-            query_params.append(('sections.all', params['sections_all']))  # noqa: E501
-        if 'tags_any' in params:
-            query_params.append(('tags.any', params['tags_any']))  # noqa: E501
-        if 'tags_not' in params:
-            query_params.append(('tags.not', params['tags_not']))  # noqa: E501
-        if 'tags_all' in params:
-            query_params.append(('tags.all', params['tags_all']))  # noqa: E501
-        if 'teams_any' in params:
-            query_params.append(('teams.any', params['teams_any']))  # noqa: E501
-        if 'followers_not' in params:
-            query_params.append(('followers.not', params['followers_not']))  # noqa: E501
-        if 'created_by_any' in params:
-            query_params.append(('created_by.any', params['created_by_any']))  # noqa: E501
-        if 'created_by_not' in params:
-            query_params.append(('created_by.not', params['created_by_not']))  # noqa: E501
-        if 'assigned_by_any' in params:
-            query_params.append(('assigned_by.any', params['assigned_by_any']))  # noqa: E501
-        if 'assigned_by_not' in params:
-            query_params.append(('assigned_by.not', params['assigned_by_not']))  # noqa: E501
-        if 'liked_by_not' in params:
-            query_params.append(('liked_by.not', params['liked_by_not']))  # noqa: E501
-        if 'commented_on_by_not' in params:
-            query_params.append(('commented_on_by.not', params['commented_on_by_not']))  # noqa: E501
-        if 'due_on_before' in params:
-            query_params.append(('due_on.before', params['due_on_before']))  # noqa: E501
-        if 'due_on_after' in params:
-            query_params.append(('due_on.after', params['due_on_after']))  # noqa: E501
-        if 'due_on' in params:
-            query_params.append(('due_on', params['due_on']))  # noqa: E501
-        if 'due_at_before' in params:
-            query_params.append(('due_at.before', params['due_at_before']))  # noqa: E501
-        if 'due_at_after' in params:
-            query_params.append(('due_at.after', params['due_at_after']))  # noqa: E501
-        if 'start_on_before' in params:
-            query_params.append(('start_on.before', params['start_on_before']))  # noqa: E501
-        if 'start_on_after' in params:
-            query_params.append(('start_on.after', params['start_on_after']))  # noqa: E501
-        if 'start_on' in params:
-            query_params.append(('start_on', params['start_on']))  # noqa: E501
-        if 'created_on_before' in params:
-            query_params.append(('created_on.before', params['created_on_before']))  # noqa: E501
-        if 'created_on_after' in params:
-            query_params.append(('created_on.after', params['created_on_after']))  # noqa: E501
-        if 'created_on' in params:
-            query_params.append(('created_on', params['created_on']))  # noqa: E501
-        if 'created_at_before' in params:
-            query_params.append(('created_at.before', params['created_at_before']))  # noqa: E501
-        if 'created_at_after' in params:
-            query_params.append(('created_at.after', params['created_at_after']))  # noqa: E501
-        if 'completed_on_before' in params:
-            query_params.append(('completed_on.before', params['completed_on_before']))  # noqa: E501
-        if 'completed_on_after' in params:
-            query_params.append(('completed_on.after', params['completed_on_after']))  # noqa: E501
-        if 'completed_on' in params:
-            query_params.append(('completed_on', params['completed_on']))  # noqa: E501
-        if 'completed_at_before' in params:
-            query_params.append(('completed_at.before', params['completed_at_before']))  # noqa: E501
-        if 'completed_at_after' in params:
-            query_params.append(('completed_at.after', params['completed_at_after']))  # noqa: E501
-        if 'modified_on_before' in params:
-            query_params.append(('modified_on.before', params['modified_on_before']))  # noqa: E501
-        if 'modified_on_after' in params:
-            query_params.append(('modified_on.after', params['modified_on_after']))  # noqa: E501
-        if 'modified_on' in params:
-            query_params.append(('modified_on', params['modified_on']))  # noqa: E501
-        if 'modified_at_before' in params:
-            query_params.append(('modified_at.before', params['modified_at_before']))  # noqa: E501
-        if 'modified_at_after' in params:
-            query_params.append(('modified_at.after', params['modified_at_after']))  # noqa: E501
-        if 'is_blocking' in params:
-            query_params.append(('is_blocking', params['is_blocking']))  # noqa: E501
-        if 'is_blocked' in params:
-            query_params.append(('is_blocked', params['is_blocked']))  # noqa: E501
-        if 'has_attachment' in params:
-            query_params.append(('has_attachment', params['has_attachment']))  # noqa: E501
-        if 'completed' in params:
-            query_params.append(('completed', params['completed']))  # noqa: E501
-        if 'is_subtask' in params:
-            query_params.append(('is_subtask', params['is_subtask']))  # noqa: E501
-        if 'sort_by' in params:
-            query_params.append(('sort_by', params['sort_by']))  # noqa: E501
-        if 'sort_ascending' in params:
-            query_params.append(('sort_ascending', params['sort_ascending']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+        # Checks if the user provided custom field query parameters and adds it to the request
+        for key in custom_fields_query_param_keys:
+            query_params[key] = params[key]  # noqa: E501
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
+        auth_settings = ['personalAccessToken']  # noqa: E501
+
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/tasks/search', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/workspaces/{workspace_gid}/tasks/search',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/workspaces/{workspace_gid}/tasks/search', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def set_parent_for_task(self, body, task_gid, **kwargs):  # noqa: E501
+    def set_parent_for_task(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Set the parent of a task  # noqa: E501
 
         parent, or no parent task at all. Returns an empty data block. When using `insert_before` and `insert_after`, at most one of those two options can be specified, and they must already be subtasks of the parent.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.set_parent_for_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidSetParentBody body: The new parent of the subtask. (required)
+        :param dict body: The new parent of the subtask. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.set_parent_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            return self.set_parent_for_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.set_parent_for_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            (data) = self.set_parent_for_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def set_parent_for_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
+    def set_parent_for_task_with_http_info(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Set the parent of a task  # noqa: E501
 
         parent, or no parent task at all. Returns an empty data block. When using `insert_before` and `insert_after`, at most one of those two options can be specified, and they must already be subtasks of the parent.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.set_parent_for_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TaskGidSetParentBody body: The new parent of the subtask. (required)
+        :param dict body: The new parent of the subtask. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method set_parent_for_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `set_parent_for_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `set_parent_for_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}/setParent', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}/setParent', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}/setParent', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_task(self, body, task_gid, **kwargs):  # noqa: E501
+    def update_task(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Update a task  # noqa: E501
 
         A specific, existing task can be updated by making a PUT request on the URL for that task. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated task record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_task(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TasksTaskGidBody body: The task to update. (required)
+        :param dict body: The task to update. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            return self.update_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_task_with_http_info(body, task_gid, **kwargs)  # noqa: E501
+            (data) = self.update_task_with_http_info(body, task_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_task_with_http_info(self, body, task_gid, **kwargs):  # noqa: E501
+    def update_task_with_http_info(self, body, task_gid, opts, **kwargs):  # noqa: E501
         """Update a task  # noqa: E501
 
         A specific, existing task can be updated by making a PUT request on the URL for that task. Only the fields provided in the `data` block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated task record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_task_with_http_info(body, task_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TasksTaskGidBody body: The task to update. (required)
+        :param dict body: The task to update. (required)
         :param str task_gid: The task to operate on. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: TaskResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'task_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_task" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `update_task`")  # noqa: E501
         # verify the required parameter 'task_gid' is set
-        if ('task_gid' not in params or
-                params['task_gid'] is None):
+        if (task_gid is None):
             raise ValueError("Missing the required parameter `task_gid` when calling `update_task`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'task_gid' in params:
-            path_params['task_gid'] = params['task_gid']  # noqa: E501
+        path_params['task_gid'] = task_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/tasks/{task_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/tasks/{task_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/tasks/{task_gid}', 'PUT',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TaskResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/team_memberships_api.py` & `asana_preview-1.2.40/asana_preview/api/memberships_api.py`

 * *Files 20% similar despite different names*

```diff
@@ -12,458 +12,581 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
-
-class TeamMembershipsApi(object):
+class MembershipsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def get_team_membership(self, team_membership_gid, **kwargs):  # noqa: E501
-        """Get a team membership  # noqa: E501
+    def create_membership(self, opts, **kwargs):  # noqa: E501
+        """Create a membership  # noqa: E501
 
-        Returns the complete team membership record for a single team membership.  # noqa: E501
+        Creates a new membership in a `goal` or `project`. `Teams` or `users` can be a member of `goals` or `projects`.  Returns the full record of the newly created membership.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_team_membership(team_membership_gid, async_req=True)
+        >>> thread = api.create_membership(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str team_membership_gid: (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamMembershipResponseData
+        :param dict body: The updated fields for the membership.
+        :return: MembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_team_membership_with_http_info(team_membership_gid, **kwargs)  # noqa: E501
+            return self.create_membership_with_http_info(opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_team_membership_with_http_info(team_membership_gid, **kwargs)  # noqa: E501
+            (data) = self.create_membership_with_http_info(opts, **kwargs)  # noqa: E501
             return data
 
-    def get_team_membership_with_http_info(self, team_membership_gid, **kwargs):  # noqa: E501
-        """Get a team membership  # noqa: E501
+    def create_membership_with_http_info(self, opts, **kwargs):  # noqa: E501
+        """Create a membership  # noqa: E501
 
-        Returns the complete team membership record for a single team membership.  # noqa: E501
+        Creates a new membership in a `goal` or `project`. `Teams` or `users` can be a member of `goals` or `projects`.  Returns the full record of the newly created membership.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_team_membership_with_http_info(team_membership_gid, async_req=True)
+        >>> thread = api.create_membership_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str team_membership_gid: (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamMembershipResponseData
+        :param dict body: The updated fields for the membership.
+        :return: MembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['team_membership_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_team_membership" % key
+                    " to method create_membership" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'team_membership_gid' is set
-        if ('team_membership_gid' not in params or
-                params['team_membership_gid'] is None):
-            raise ValueError("Missing the required parameter `team_membership_gid` when calling `get_team_membership`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'team_membership_gid' in params:
-            path_params['team_membership_gid'] = params['team_membership_gid']  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
+        body_params = opts['body']
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['application/json; charset=UTF-8'])  # noqa: E501
+
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/team_memberships/{team_membership_gid}', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/memberships', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/memberships',
+                    "method": 'POST',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/memberships', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TeamMembershipResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_team_memberships(self, **kwargs):  # noqa: E501
-        """Get team memberships  # noqa: E501
+    def delete_membership(self, membership_gid, **kwargs):  # noqa: E501
+        """Delete a membership  # noqa: E501
 
-        Returns compact team membership records.  # noqa: E501
+        A specific, existing membership for a `goal` or `project` can be deleted by making a `DELETE` request on the URL for that membership.  Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_team_memberships(async_req=True)
+        >>> thread = api.delete_membership(membership_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param str team: Globally unique identifier for the team.
-        :param str user: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. This parameter must be used with the workspace parameter.
-        :param str workspace: Globally unique identifier for the workspace. This parameter must be used with the user parameter.
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamMembershipResponseArray
+        :param str membership_gid: Globally unique identifier for the membership. (required)
+        :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_team_memberships_with_http_info(**kwargs)  # noqa: E501
+            return self.delete_membership_with_http_info(membership_gid, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_team_memberships_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.delete_membership_with_http_info(membership_gid, **kwargs)  # noqa: E501
             return data
 
-    def get_team_memberships_with_http_info(self, **kwargs):  # noqa: E501
-        """Get team memberships  # noqa: E501
+    def delete_membership_with_http_info(self, membership_gid, **kwargs):  # noqa: E501
+        """Delete a membership  # noqa: E501
 
-        Returns compact team membership records.  # noqa: E501
+        A specific, existing membership for a `goal` or `project` can be deleted by making a `DELETE` request on the URL for that membership.  Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_team_memberships_with_http_info(async_req=True)
+        >>> thread = api.delete_membership_with_http_info(membership_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param str team: Globally unique identifier for the team.
-        :param str user: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. This parameter must be used with the workspace parameter.
-        :param str workspace: Globally unique identifier for the workspace. This parameter must be used with the user parameter.
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamMembershipResponseArray
+        :param str membership_gid: Globally unique identifier for the membership. (required)
+        :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['limit', 'offset', 'team', 'user', 'workspace', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_team_memberships" % key
+                    " to method delete_membership" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'membership_gid' is set
+        if (membership_gid is None):
+            raise ValueError("Missing the required parameter `membership_gid` when calling `delete_membership`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        path_params['membership_gid'] = membership_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'team' in params:
-            query_params.append(('team', params['team']))  # noqa: E501
-        if 'user' in params:
-            query_params.append(('user', params['user']))  # noqa: E501
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/team_memberships', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/memberships/{membership_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/memberships/{membership_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/memberships/{membership_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TeamMembershipResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_team_memberships_for_team(self, team_gid, **kwargs):  # noqa: E501
-        """Get memberships from a team  # noqa: E501
+    def get_membership(self, membership_gid, opts, **kwargs):  # noqa: E501
+        """Get a membership  # noqa: E501
 
-        Returns the compact team memberships for the team.  # noqa: E501
+        Returns compact `project_membership` record for a single membership. `GET` only supports project memberships currently  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_team_memberships_for_team(team_gid, async_req=True)
+        >>> thread = api.get_membership(membership_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str team_gid: Globally unique identifier for the team. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str membership_gid: Globally unique identifier for the membership. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamMembershipResponseArray
+        :return: ProjectMembershipCompactResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_team_memberships_for_team_with_http_info(team_gid, **kwargs)  # noqa: E501
+            return self.get_membership_with_http_info(membership_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_team_memberships_for_team_with_http_info(team_gid, **kwargs)  # noqa: E501
+            (data) = self.get_membership_with_http_info(membership_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_team_memberships_for_team_with_http_info(self, team_gid, **kwargs):  # noqa: E501
-        """Get memberships from a team  # noqa: E501
+    def get_membership_with_http_info(self, membership_gid, opts, **kwargs):  # noqa: E501
+        """Get a membership  # noqa: E501
 
-        Returns the compact team memberships for the team.  # noqa: E501
+        Returns compact `project_membership` record for a single membership. `GET` only supports project memberships currently  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_team_memberships_for_team_with_http_info(team_gid, async_req=True)
+        >>> thread = api.get_membership_with_http_info(membership_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str team_gid: Globally unique identifier for the team. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str membership_gid: Globally unique identifier for the membership. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamMembershipResponseArray
+        :return: ProjectMembershipCompactResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['team_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_team_memberships_for_team" % key
+                    " to method get_membership" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'team_gid' is set
-        if ('team_gid' not in params or
-                params['team_gid'] is None):
-            raise ValueError("Missing the required parameter `team_gid` when calling `get_team_memberships_for_team`")  # noqa: E501
+        # verify the required parameter 'membership_gid' is set
+        if (membership_gid is None):
+            raise ValueError("Missing the required parameter `membership_gid` when calling `get_membership`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'team_gid' in params:
-            path_params['team_gid'] = params['team_gid']  # noqa: E501
+        path_params['membership_gid'] = membership_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/teams/{team_gid}/team_memberships', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/memberships/{membership_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/memberships/{membership_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/memberships/{membership_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TeamMembershipResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_team_memberships_for_user(self, user_gid, workspace, **kwargs):  # noqa: E501
-        """Get memberships from a user  # noqa: E501
+    def get_memberships(self, opts, **kwargs):  # noqa: E501
+        """Get multiple memberships  # noqa: E501
 
-        Returns the compact team membership records for the user.  # noqa: E501
+        Returns compact `goal_membership` or `project_membership` records. The possible types for `parent` in this request are `goal` or `project`. An additional member (user GID or team GID) can be passed in to filter to a specific membership.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_team_memberships_for_user(user_gid, workspace, async_req=True)
+        >>> thread = api.get_memberships(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
-        :param str workspace: Globally unique identifier for the workspace. (required)
+        :param str parent: Globally unique identifier for `goal` or `project`.
+        :param str member: Globally unique identifier for `team` or `user`.
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamMembershipResponseArray
+        :return: MembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_team_memberships_for_user_with_http_info(user_gid, workspace, **kwargs)  # noqa: E501
+            return self.get_memberships_with_http_info(opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_team_memberships_for_user_with_http_info(user_gid, workspace, **kwargs)  # noqa: E501
+            (data) = self.get_memberships_with_http_info(opts, **kwargs)  # noqa: E501
             return data
 
-    def get_team_memberships_for_user_with_http_info(self, user_gid, workspace, **kwargs):  # noqa: E501
-        """Get memberships from a user  # noqa: E501
+    def get_memberships_with_http_info(self, opts, **kwargs):  # noqa: E501
+        """Get multiple memberships  # noqa: E501
 
-        Returns the compact team membership records for the user.  # noqa: E501
+        Returns compact `goal_membership` or `project_membership` records. The possible types for `parent` in this request are `goal` or `project`. An additional member (user GID or team GID) can be passed in to filter to a specific membership.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_team_memberships_for_user_with_http_info(user_gid, workspace, async_req=True)
+        >>> thread = api.get_memberships_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
-        :param str workspace: Globally unique identifier for the workspace. (required)
+        :param str parent: Globally unique identifier for `goal` or `project`.
+        :param str member: Globally unique identifier for `team` or `user`.
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamMembershipResponseArray
+        :return: MembershipResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['user_gid', 'workspace', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_team_memberships_for_user" % key
+                    " to method get_memberships" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'user_gid' is set
-        if ('user_gid' not in params or
-                params['user_gid'] is None):
-            raise ValueError("Missing the required parameter `user_gid` when calling `get_team_memberships_for_user`")  # noqa: E501
-        # verify the required parameter 'workspace' is set
-        if ('workspace' not in params or
-                params['workspace'] is None):
-            raise ValueError("Missing the required parameter `workspace` when calling `get_team_memberships_for_user`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'user_gid' in params:
-            path_params['user_gid'] = params['user_gid']  # noqa: E501
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/users/{user_gid}/team_memberships', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/memberships', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/memberships',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/memberships', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TeamMembershipResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/teams_api.py` & `asana_preview-1.2.40/asana_preview/api/workspaces_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -12,797 +12,742 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
-
-class TeamsApi(object):
+class WorkspacesApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def add_user_for_team(self, body, team_gid, **kwargs):  # noqa: E501
-        """Add a user to a team  # noqa: E501
+    def add_user_for_workspace(self, body, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Add a user to a workspace or organization  # noqa: E501
 
-        The user making this call must be a member of the team in order to add others. The user being added must exist in the same organization as the team.  Returns the complete team membership record for the newly added user.  # noqa: E501
+        Add a user to a workspace or organization. The user can be referenced by their globally unique user ID or their email address. Returns the full user record for the invited user.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.add_user_for_team(body, team_gid, async_req=True)
+        >>> thread = api.add_user_for_workspace(body, workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TeamGidAddUserBody body: The user to add to the team. (required)
-        :param str team_gid: Globally unique identifier for the team. (required)
+        :param dict body: The user to add to the workspace. (required)
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamMembershipResponseData
+        :return: UserBaseResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.add_user_for_team_with_http_info(body, team_gid, **kwargs)  # noqa: E501
+            return self.add_user_for_workspace_with_http_info(body, workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.add_user_for_team_with_http_info(body, team_gid, **kwargs)  # noqa: E501
+            (data) = self.add_user_for_workspace_with_http_info(body, workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def add_user_for_team_with_http_info(self, body, team_gid, **kwargs):  # noqa: E501
-        """Add a user to a team  # noqa: E501
+    def add_user_for_workspace_with_http_info(self, body, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Add a user to a workspace or organization  # noqa: E501
 
-        The user making this call must be a member of the team in order to add others. The user being added must exist in the same organization as the team.  Returns the complete team membership record for the newly added user.  # noqa: E501
+        Add a user to a workspace or organization. The user can be referenced by their globally unique user ID or their email address. Returns the full user record for the invited user.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.add_user_for_team_with_http_info(body, team_gid, async_req=True)
+        >>> thread = api.add_user_for_workspace_with_http_info(body, workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TeamGidAddUserBody body: The user to add to the team. (required)
-        :param str team_gid: Globally unique identifier for the team. (required)
+        :param dict body: The user to add to the workspace. (required)
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamMembershipResponseData
+        :return: UserBaseResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'team_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method add_user_for_team" % key
+                    " to method add_user_for_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `add_user_for_team`")  # noqa: E501
-        # verify the required parameter 'team_gid' is set
-        if ('team_gid' not in params or
-                params['team_gid'] is None):
-            raise ValueError("Missing the required parameter `team_gid` when calling `add_user_for_team`")  # noqa: E501
+        if (body is None):
+            raise ValueError("Missing the required parameter `body` when calling `add_user_for_workspace`")  # noqa: E501
+        # verify the required parameter 'workspace_gid' is set
+        if (workspace_gid is None):
+            raise ValueError("Missing the required parameter `workspace_gid` when calling `add_user_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'team_gid' in params:
-            path_params['team_gid'] = params['team_gid']  # noqa: E501
-
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
 
-        header_params = {}
+        query_params = {}
+        query_params = opts
 
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # HTTP header `Content-Type`
-        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/teams/{team_gid}/addUser', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='TeamMembershipResponseData',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def create_team(self, body, **kwargs):  # noqa: E501
-        """Create a team  # noqa: E501
-
-        Creates a team within the current workspace.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_team(body, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param TeamsBody1 body: The team to create. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.create_team_with_http_info(body, **kwargs)  # noqa: E501
-        else:
-            (data) = self.create_team_with_http_info(body, **kwargs)  # noqa: E501
-            return data
 
-    def create_team_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Create a team  # noqa: E501
-
-        Creates a team within the current workspace.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.create_team_with_http_info(body, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param TeamsBody1 body: The team to create. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['body', 'limit', 'offset', 'opt_fields']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method create_team" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `create_team`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/teams', 'POST',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='TeamResponseData',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-    def get_team(self, team_gid, **kwargs):  # noqa: E501
-        """Get a team  # noqa: E501
-
-        Returns the full record for a single team.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_team(team_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str team_gid: Globally unique identifier for the team. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_team_with_http_info(team_gid, **kwargs)  # noqa: E501
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/addUser', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/workspaces/{workspace_gid}/addUser', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
         else:
-            (data) = self.get_team_with_http_info(team_gid, **kwargs)  # noqa: E501
-            return data
-
-    def get_team_with_http_info(self, team_gid, **kwargs):  # noqa: E501
-        """Get a team  # noqa: E501
-
-        Returns the full record for a single team.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_team_with_http_info(team_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str team_gid: Globally unique identifier for the team. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['team_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_team" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'team_gid' is set
-        if ('team_gid' not in params or
-                params['team_gid'] is None):
-            raise ValueError("Missing the required parameter `team_gid` when calling `get_team`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'team_gid' in params:
-            path_params['team_gid'] = params['team_gid']  # noqa: E501
-
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
-
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/teams/{team_gid}', 'GET',
+            return self.api_client.call_api(
+            '/workspaces/{workspace_gid}/addUser', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TeamResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_teams_for_user(self, user_gid, organization, **kwargs):  # noqa: E501
-        """Get teams for a user  # noqa: E501
+    def get_workspace(self, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Get a workspace  # noqa: E501
 
-        Returns the compact records for all teams to which the given user is assigned.  # noqa: E501
+        Returns the full workspace record for a single workspace.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_teams_for_user(user_gid, organization, async_req=True)
+        >>> thread = api.get_workspace(workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
-        :param str organization: The workspace or organization to filter teams on. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamResponseArray
+        :return: WorkspaceResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_teams_for_user_with_http_info(user_gid, organization, **kwargs)  # noqa: E501
+            return self.get_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_teams_for_user_with_http_info(user_gid, organization, **kwargs)  # noqa: E501
+            (data) = self.get_workspace_with_http_info(workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_teams_for_user_with_http_info(self, user_gid, organization, **kwargs):  # noqa: E501
-        """Get teams for a user  # noqa: E501
+    def get_workspace_with_http_info(self, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Get a workspace  # noqa: E501
 
-        Returns the compact records for all teams to which the given user is assigned.  # noqa: E501
+        Returns the full workspace record for a single workspace.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_teams_for_user_with_http_info(user_gid, organization, async_req=True)
+        >>> thread = api.get_workspace_with_http_info(workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
-        :param str organization: The workspace or organization to filter teams on. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamResponseArray
+        :return: WorkspaceResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['user_gid', 'organization', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_teams_for_user" % key
+                    " to method get_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'user_gid' is set
-        if ('user_gid' not in params or
-                params['user_gid'] is None):
-            raise ValueError("Missing the required parameter `user_gid` when calling `get_teams_for_user`")  # noqa: E501
-        # verify the required parameter 'organization' is set
-        if ('organization' not in params or
-                params['organization'] is None):
-            raise ValueError("Missing the required parameter `organization` when calling `get_teams_for_user`")  # noqa: E501
+        # verify the required parameter 'workspace_gid' is set
+        if (workspace_gid is None):
+            raise ValueError("Missing the required parameter `workspace_gid` when calling `get_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'user_gid' in params:
-            path_params['user_gid'] = params['user_gid']  # noqa: E501
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'organization' in params:
-            query_params.append(('organization', params['organization']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/users/{user_gid}/teams', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/workspaces/{workspace_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/workspaces/{workspace_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TeamResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_teams_for_workspace(self, workspace_gid, **kwargs):  # noqa: E501
-        """Get teams in a workspace  # noqa: E501
+    def get_workspaces(self, opts, **kwargs):  # noqa: E501
+        """Get multiple workspaces  # noqa: E501
 
-        Returns the compact records for all teams in the workspace visible to the authorized user.  # noqa: E501
+        Returns the compact records for all workspaces visible to the authorized user.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_teams_for_workspace(workspace_gid, async_req=True)
+        >>> thread = api.get_workspaces(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamResponseArray
+        :return: WorkspaceResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_teams_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            return self.get_workspaces_with_http_info(opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_teams_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            (data) = self.get_workspaces_with_http_info(opts, **kwargs)  # noqa: E501
             return data
 
-    def get_teams_for_workspace_with_http_info(self, workspace_gid, **kwargs):  # noqa: E501
-        """Get teams in a workspace  # noqa: E501
+    def get_workspaces_with_http_info(self, opts, **kwargs):  # noqa: E501
+        """Get multiple workspaces  # noqa: E501
 
-        Returns the compact records for all teams in the workspace visible to the authorized user.  # noqa: E501
+        Returns the compact records for all workspaces visible to the authorized user.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_teams_for_workspace_with_http_info(workspace_gid, async_req=True)
+        >>> thread = api.get_workspaces_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamResponseArray
+        :return: WorkspaceResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace_gid', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_teams_for_workspace" % key
+                    " to method get_workspaces" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'workspace_gid' is set
-        if ('workspace_gid' not in params or
-                params['workspace_gid'] is None):
-            raise ValueError("Missing the required parameter `workspace_gid` when calling `get_teams_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'workspace_gid' in params:
-            path_params['workspace_gid'] = params['workspace_gid']  # noqa: E501
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/workspaces/{workspace_gid}/teams', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/workspaces',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/workspaces', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TeamResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def remove_user_for_team(self, body, team_gid, **kwargs):  # noqa: E501
-        """Remove a user from a team  # noqa: E501
+    def remove_user_for_workspace(self, body, workspace_gid, **kwargs):  # noqa: E501
+        """Remove a user from a workspace or organization  # noqa: E501
 
-        The user making this call must be a member of the team in order to remove themselves or others.  # noqa: E501
+        Remove a user from a workspace or organization. The user making this call must be an admin in the workspace. The user can be referenced by their globally unique user ID or their email address. Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.remove_user_for_team(body, team_gid, async_req=True)
+        >>> thread = api.remove_user_for_workspace(body, workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TeamGidRemoveUserBody body: The user to remove from the team. (required)
-        :param str team_gid: Globally unique identifier for the team. (required)
+        :param dict body: The user to remove from the workspace. (required)
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.remove_user_for_team_with_http_info(body, team_gid, **kwargs)  # noqa: E501
+            return self.remove_user_for_workspace_with_http_info(body, workspace_gid, **kwargs)  # noqa: E501
         else:
-            (data) = self.remove_user_for_team_with_http_info(body, team_gid, **kwargs)  # noqa: E501
+            (data) = self.remove_user_for_workspace_with_http_info(body, workspace_gid, **kwargs)  # noqa: E501
             return data
 
-    def remove_user_for_team_with_http_info(self, body, team_gid, **kwargs):  # noqa: E501
-        """Remove a user from a team  # noqa: E501
+    def remove_user_for_workspace_with_http_info(self, body, workspace_gid, **kwargs):  # noqa: E501
+        """Remove a user from a workspace or organization  # noqa: E501
 
-        The user making this call must be a member of the team in order to remove themselves or others.  # noqa: E501
+        Remove a user from a workspace or organization. The user making this call must be an admin in the workspace. The user can be referenced by their globally unique user ID or their email address. Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.remove_user_for_team_with_http_info(body, team_gid, async_req=True)
+        >>> thread = api.remove_user_for_workspace_with_http_info(body, workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TeamGidRemoveUserBody body: The user to remove from the team. (required)
-        :param str team_gid: Globally unique identifier for the team. (required)
+        :param dict body: The user to remove from the workspace. (required)
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'team_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method remove_user_for_team" % key
+                    " to method remove_user_for_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `remove_user_for_team`")  # noqa: E501
-        # verify the required parameter 'team_gid' is set
-        if ('team_gid' not in params or
-                params['team_gid'] is None):
-            raise ValueError("Missing the required parameter `team_gid` when calling `remove_user_for_team`")  # noqa: E501
+        if (body is None):
+            raise ValueError("Missing the required parameter `body` when calling `remove_user_for_workspace`")  # noqa: E501
+        # verify the required parameter 'workspace_gid' is set
+        if (workspace_gid is None):
+            raise ValueError("Missing the required parameter `workspace_gid` when calling `remove_user_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'team_gid' in params:
-            path_params['team_gid'] = params['team_gid']  # noqa: E501
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/teams/{team_gid}/removeUser', 'POST',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/removeUser', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/workspaces/{workspace_gid}/removeUser', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/workspaces/{workspace_gid}/removeUser', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_team(self, body, **kwargs):  # noqa: E501
-        """Update a team  # noqa: E501
+    def update_workspace(self, body, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Update a workspace  # noqa: E501
 
-        Updates a team within the current workspace.  # noqa: E501
+        A specific, existing workspace can be updated by making a PUT request on the URL for that workspace. Only the fields provided in the data block will be updated; any unspecified fields will remain unchanged. Currently the only field that can be modified for a workspace is its name. Returns the complete, updated workspace record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_team(body, async_req=True)
+        >>> thread = api.update_workspace(body, workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TeamsBody body: The team to update. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param dict body: The workspace object with all updated properties. (required)
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamResponseData
+        :return: WorkspaceResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_team_with_http_info(body, **kwargs)  # noqa: E501
+            return self.update_workspace_with_http_info(body, workspace_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_team_with_http_info(body, **kwargs)  # noqa: E501
+            (data) = self.update_workspace_with_http_info(body, workspace_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_team_with_http_info(self, body, **kwargs):  # noqa: E501
-        """Update a team  # noqa: E501
+    def update_workspace_with_http_info(self, body, workspace_gid, opts, **kwargs):  # noqa: E501
+        """Update a workspace  # noqa: E501
 
-        Updates a team within the current workspace.  # noqa: E501
+        A specific, existing workspace can be updated by making a PUT request on the URL for that workspace. Only the fields provided in the data block will be updated; any unspecified fields will remain unchanged. Currently the only field that can be modified for a workspace is its name. Returns the complete, updated workspace record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.update_team_with_http_info(body, async_req=True)
+        >>> thread = api.update_workspace_with_http_info(body, workspace_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param TeamsBody body: The team to update. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param dict body: The workspace object with all updated properties. (required)
+        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TeamResponseData
+        :return: WorkspaceResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method update_team" % key
+                    " to method update_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
-            raise ValueError("Missing the required parameter `body` when calling `update_team`")  # noqa: E501
+        if (body is None):
+            raise ValueError("Missing the required parameter `body` when calling `update_workspace`")  # noqa: E501
+        # verify the required parameter 'workspace_gid' is set
+        if (workspace_gid is None):
+            raise ValueError("Missing the required parameter `workspace_gid` when calling `update_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/teams', 'PUT',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/workspaces/{workspace_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/workspaces/{workspace_gid}', 'PUT',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TeamResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/time_periods_api.py` & `asana_preview-1.2.40/asana_preview/api/user_task_lists_api.py`

 * *Files 25% similar despite different names*

```diff
@@ -12,238 +12,306 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
-
-class TimePeriodsApi(object):
+class UserTaskListsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def get_time_period(self, time_period_gid, **kwargs):  # noqa: E501
-        """Get a time period  # noqa: E501
+    def get_user_task_list(self, user_task_list_gid, opts, **kwargs):  # noqa: E501
+        """Get a user task list  # noqa: E501
 
-        Returns the full record for a single time period.  # noqa: E501
+        Returns the full record for a user task list.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_time_period(time_period_gid, async_req=True)
+        >>> thread = api.get_user_task_list(user_task_list_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str time_period_gid: Globally unique identifier for the time period. (required)
+        :param str user_task_list_gid: Globally unique identifier for the user task list. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TimePeriodResponseData
+        :return: UserTaskListResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_time_period_with_http_info(time_period_gid, **kwargs)  # noqa: E501
+            return self.get_user_task_list_with_http_info(user_task_list_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_time_period_with_http_info(time_period_gid, **kwargs)  # noqa: E501
+            (data) = self.get_user_task_list_with_http_info(user_task_list_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_time_period_with_http_info(self, time_period_gid, **kwargs):  # noqa: E501
-        """Get a time period  # noqa: E501
+    def get_user_task_list_with_http_info(self, user_task_list_gid, opts, **kwargs):  # noqa: E501
+        """Get a user task list  # noqa: E501
 
-        Returns the full record for a single time period.  # noqa: E501
+        Returns the full record for a user task list.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_time_period_with_http_info(time_period_gid, async_req=True)
+        >>> thread = api.get_user_task_list_with_http_info(user_task_list_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str time_period_gid: Globally unique identifier for the time period. (required)
+        :param str user_task_list_gid: Globally unique identifier for the user task list. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TimePeriodResponseData
+        :return: UserTaskListResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['time_period_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_time_period" % key
+                    " to method get_user_task_list" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'time_period_gid' is set
-        if ('time_period_gid' not in params or
-                params['time_period_gid'] is None):
-            raise ValueError("Missing the required parameter `time_period_gid` when calling `get_time_period`")  # noqa: E501
+        # verify the required parameter 'user_task_list_gid' is set
+        if (user_task_list_gid is None):
+            raise ValueError("Missing the required parameter `user_task_list_gid` when calling `get_user_task_list`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'time_period_gid' in params:
-            path_params['time_period_gid'] = params['time_period_gid']  # noqa: E501
+        path_params['user_task_list_gid'] = user_task_list_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/time_periods/{time_period_gid}', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/user_task_lists/{user_task_list_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/user_task_lists/{user_task_list_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/user_task_lists/{user_task_list_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TimePeriodResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_time_periods(self, workspace, **kwargs):  # noqa: E501
-        """Get time periods  # noqa: E501
+    def get_user_task_list_for_user(self, user_gid, workspace, opts, **kwargs):  # noqa: E501
+        """Get a user's task list  # noqa: E501
 
-        Returns compact time period records.  # noqa: E501
+        Returns the full record for a user's task list.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_time_periods(workspace, async_req=True)
+        >>> thread = api.get_user_task_list_for_user(user_gid, workspace, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str workspace: Globally unique identifier for the workspace. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param date start_on: ISO 8601 date string
-        :param date end_on: ISO 8601 date string
+        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
+        :param str workspace: The workspace in which to get the user task list. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TimePeriodResponseArray
+        :return: UserTaskListResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_time_periods_with_http_info(workspace, **kwargs)  # noqa: E501
+            return self.get_user_task_list_for_user_with_http_info(user_gid, workspace, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_time_periods_with_http_info(workspace, **kwargs)  # noqa: E501
+            (data) = self.get_user_task_list_for_user_with_http_info(user_gid, workspace, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_time_periods_with_http_info(self, workspace, **kwargs):  # noqa: E501
-        """Get time periods  # noqa: E501
+    def get_user_task_list_for_user_with_http_info(self, user_gid, workspace, opts, **kwargs):  # noqa: E501
+        """Get a user's task list  # noqa: E501
 
-        Returns compact time period records.  # noqa: E501
+        Returns the full record for a user's task list.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_time_periods_with_http_info(workspace, async_req=True)
+        >>> thread = api.get_user_task_list_for_user_with_http_info(user_gid, workspace, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str workspace: Globally unique identifier for the workspace. (required)
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param date start_on: ISO 8601 date string
-        :param date end_on: ISO 8601 date string
+        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
+        :param str workspace: The workspace in which to get the user task list. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: TimePeriodResponseArray
+        :return: UserTaskListResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace', 'limit', 'offset', 'start_on', 'end_on', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_time_periods" % key
+                    " to method get_user_task_list_for_user" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'user_gid' is set
+        if (user_gid is None):
+            raise ValueError("Missing the required parameter `user_gid` when calling `get_user_task_list_for_user`")  # noqa: E501
         # verify the required parameter 'workspace' is set
-        if ('workspace' not in params or
-                params['workspace'] is None):
-            raise ValueError("Missing the required parameter `workspace` when calling `get_time_periods`")  # noqa: E501
+        if (workspace is None):
+            raise ValueError("Missing the required parameter `workspace` when calling `get_user_task_list_for_user`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        path_params['user_gid'] = user_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
+        query_params['workspace'] = workspace
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'start_on' in params:
-            query_params.append(('start_on', params['start_on']))  # noqa: E501
-        if 'end_on' in params:
-            query_params.append(('end_on', params['end_on']))  # noqa: E501
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/time_periods', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/users/{user_gid}/user_task_list', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/users/{user_gid}/user_task_list', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/users/{user_gid}/user_task_list', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='TimePeriodResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/typeahead_api.py` & `asana_preview-1.2.40/asana_preview/api/typeahead_api.py`

 * *Files 12% similar despite different names*

```diff
@@ -12,142 +12,176 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class TypeaheadApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def typeahead_for_workspace(self, workspace_gid, resource_type, **kwargs):  # noqa: E501
+    def typeahead_for_workspace(self, workspace_gid, resource_type, opts, **kwargs):  # noqa: E501
         """Get objects via typeahead  # noqa: E501
 
         Retrieves objects in the workspace based via an auto-completion/typeahead search algorithm. This feature is meant to provide results quickly, so do not rely on this API to provide extremely accurate search results. The result set is limited to a single page of results with a maximum size, so you won’t be able to fetch large numbers of results.  The typeahead search API provides search for objects from a single workspace. This endpoint should be used to query for objects when creating an auto-completion/typeahead search feature. This API is meant to provide results quickly and should not be relied upon for accurate or exhaustive search results. The results sets are limited in size and cannot be paginated.  Queries return a compact representation of each object which is typically the gid and name fields. Interested in a specific set of fields or all of the fields?! Of course you are. Use field selectors to manipulate what data is included in a response.  Resources with type `user` are returned in order of most contacted to least contacted. This is determined by task assignments, adding the user to projects, and adding the user as a follower to tasks, messages, etc.  Resources with type `project` are returned in order of recency. This is determined when the user visits the project, is added to the project, and completes tasks in the project.  Resources with type `task` are returned with priority placed on tasks the user is following, but no guarantee on the order of those tasks.  Resources with type `project_template` are returned with priority placed on favorited project templates.  Leaving the `query` string empty or omitted will give you results, still following the resource ordering above. This could be used to list users or projects that are relevant for the requesting user's api token.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.typeahead_for_workspace(workspace_gid, resource_type, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
-        :param str resource_type: The type of values the typeahead should return. You can choose from one of the following: `custom_field`, `project`, `project_template`, `portfolio`, `tag`, `task`, and `user`. Note that unlike in the names of endpoints, the types listed here are in singular form (e.g. `task`). Using multiple types is not yet supported. (required)
+        :param str resource_type: The type of values the typeahead should return. You can choose from one of the following: `custom_field`, `goal`, `project`, `project_template`, `portfolio`, `tag`, `task`, `team`, and `user`. Note that unlike in the names of endpoints, the types listed here are in singular form (e.g. `task`). Using multiple types is not yet supported. (required)
         :param str type: *Deprecated: new integrations should prefer the resource_type field.*
         :param str query: The string that will be used to search for relevant objects. If an empty string is passed in, the API will return results.
         :param int count: The number of results to return. The default is 20 if this parameter is omitted, with a minimum of 1 and a maximum of 100. If there are fewer results found than requested, all will be returned.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: AsanaNamedResourceArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.typeahead_for_workspace_with_http_info(workspace_gid, resource_type, **kwargs)  # noqa: E501
+            return self.typeahead_for_workspace_with_http_info(workspace_gid, resource_type, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.typeahead_for_workspace_with_http_info(workspace_gid, resource_type, **kwargs)  # noqa: E501
+            (data) = self.typeahead_for_workspace_with_http_info(workspace_gid, resource_type, opts, **kwargs)  # noqa: E501
             return data
 
-    def typeahead_for_workspace_with_http_info(self, workspace_gid, resource_type, **kwargs):  # noqa: E501
+    def typeahead_for_workspace_with_http_info(self, workspace_gid, resource_type, opts, **kwargs):  # noqa: E501
         """Get objects via typeahead  # noqa: E501
 
         Retrieves objects in the workspace based via an auto-completion/typeahead search algorithm. This feature is meant to provide results quickly, so do not rely on this API to provide extremely accurate search results. The result set is limited to a single page of results with a maximum size, so you won’t be able to fetch large numbers of results.  The typeahead search API provides search for objects from a single workspace. This endpoint should be used to query for objects when creating an auto-completion/typeahead search feature. This API is meant to provide results quickly and should not be relied upon for accurate or exhaustive search results. The results sets are limited in size and cannot be paginated.  Queries return a compact representation of each object which is typically the gid and name fields. Interested in a specific set of fields or all of the fields?! Of course you are. Use field selectors to manipulate what data is included in a response.  Resources with type `user` are returned in order of most contacted to least contacted. This is determined by task assignments, adding the user to projects, and adding the user as a follower to tasks, messages, etc.  Resources with type `project` are returned in order of recency. This is determined when the user visits the project, is added to the project, and completes tasks in the project.  Resources with type `task` are returned with priority placed on tasks the user is following, but no guarantee on the order of those tasks.  Resources with type `project_template` are returned with priority placed on favorited project templates.  Leaving the `query` string empty or omitted will give you results, still following the resource ordering above. This could be used to list users or projects that are relevant for the requesting user's api token.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.typeahead_for_workspace_with_http_info(workspace_gid, resource_type, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
         :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
-        :param str resource_type: The type of values the typeahead should return. You can choose from one of the following: `custom_field`, `project`, `project_template`, `portfolio`, `tag`, `task`, and `user`. Note that unlike in the names of endpoints, the types listed here are in singular form (e.g. `task`). Using multiple types is not yet supported. (required)
+        :param str resource_type: The type of values the typeahead should return. You can choose from one of the following: `custom_field`, `goal`, `project`, `project_template`, `portfolio`, `tag`, `task`, `team`, and `user`. Note that unlike in the names of endpoints, the types listed here are in singular form (e.g. `task`). Using multiple types is not yet supported. (required)
         :param str type: *Deprecated: new integrations should prefer the resource_type field.*
         :param str query: The string that will be used to search for relevant objects. If an empty string is passed in, the API will return results.
         :param int count: The number of results to return. The default is 20 if this parameter is omitted, with a minimum of 1 and a maximum of 100. If there are fewer results found than requested, all will be returned.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: AsanaNamedResourceArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace_gid', 'resource_type', 'type', 'query', 'count', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method typeahead_for_workspace" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'workspace_gid' is set
-        if ('workspace_gid' not in params or
-                params['workspace_gid'] is None):
+        if (workspace_gid is None):
             raise ValueError("Missing the required parameter `workspace_gid` when calling `typeahead_for_workspace`")  # noqa: E501
         # verify the required parameter 'resource_type' is set
-        if ('resource_type' not in params or
-                params['resource_type'] is None):
+        if (resource_type is None):
             raise ValueError("Missing the required parameter `resource_type` when calling `typeahead_for_workspace`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'workspace_gid' in params:
-            path_params['workspace_gid'] = params['workspace_gid']  # noqa: E501
+        path_params['workspace_gid'] = workspace_gid  # noqa: E501
 
-        query_params = []
-        if 'resource_type' in params:
-            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
-        if 'type' in params:
-            query_params.append(('type', params['type']))  # noqa: E501
-        if 'query' in params:
-            query_params.append(('query', params['query']))  # noqa: E501
-        if 'count' in params:
-            query_params.append(('count', params['count']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+        query_params['resource_type'] = resource_type
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/workspaces/{workspace_gid}/typeahead', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/workspaces/{workspace_gid}/typeahead',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/workspaces/{workspace_gid}/typeahead', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='AsanaNamedResourceArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/users_api.py` & `asana_preview-1.2.40/asana_preview/api/attachments_api.py`

 * *Files 14% similar despite different names*

```diff
@@ -12,554 +12,622 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
-
-class UsersApi(object):
+class AttachmentsApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def get_favorites_for_user(self, user_gid, resource_type, workspace, **kwargs):  # noqa: E501
-        """Get a user's favorites  # noqa: E501
+    def create_attachment_for_object(self, opts, **kwargs):  # noqa: E501
+        """Upload an attachment  # noqa: E501
 
-        Returns all of a user's favorites in the given workspace, of the given type. Results are given in order (The same order as Asana's sidebar).  # noqa: E501
+        Upload an attachment.  This method uploads an attachment on an object and returns the compact record for the created attachment object. This is possible by either:  - Providing the URL of the external resource being attached, or - Downloading the file content first and then uploading it as any other attachment. Note that it is not possible to attach files from third party services such as Dropbox, Box, Vimeo & Google Drive via the API  The 100MB size limit on attachments in Asana is enforced on this endpoint.  This endpoint expects a multipart/form-data encoded request containing the full contents of the file to be uploaded.  Requests made should follow the HTTP/1.1 specification that line terminators are of the form `CRLF` or `\\r\\n` outlined [here](http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01#Basic-Rules) in order for the server to reliably and properly handle the request.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_favorites_for_user(user_gid, resource_type, workspace, async_req=True)
+        >>> thread = api.create_attachment_for_object(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
-        :param str resource_type: The resource type of favorites to be returned. (required)
-        :param str workspace: The workspace in which to get favorites. (required)
+        :param str resource_subtype:
+        :param str file:
+        :param str parent:
+        :param str url:
+        :param str name:
+        :param bool connect_to_app:
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: AsanaNamedResourceArray
+        :return: AttachmentResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_favorites_for_user_with_http_info(user_gid, resource_type, workspace, **kwargs)  # noqa: E501
+            return self.create_attachment_for_object_with_http_info(opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_favorites_for_user_with_http_info(user_gid, resource_type, workspace, **kwargs)  # noqa: E501
+            (data) = self.create_attachment_for_object_with_http_info(opts, **kwargs)  # noqa: E501
             return data
 
-    def get_favorites_for_user_with_http_info(self, user_gid, resource_type, workspace, **kwargs):  # noqa: E501
-        """Get a user's favorites  # noqa: E501
+    def create_attachment_for_object_with_http_info(self, opts, **kwargs):  # noqa: E501
+        """Upload an attachment  # noqa: E501
 
-        Returns all of a user's favorites in the given workspace, of the given type. Results are given in order (The same order as Asana's sidebar).  # noqa: E501
+        Upload an attachment.  This method uploads an attachment on an object and returns the compact record for the created attachment object. This is possible by either:  - Providing the URL of the external resource being attached, or - Downloading the file content first and then uploading it as any other attachment. Note that it is not possible to attach files from third party services such as Dropbox, Box, Vimeo & Google Drive via the API  The 100MB size limit on attachments in Asana is enforced on this endpoint.  This endpoint expects a multipart/form-data encoded request containing the full contents of the file to be uploaded.  Requests made should follow the HTTP/1.1 specification that line terminators are of the form `CRLF` or `\\r\\n` outlined [here](http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01#Basic-Rules) in order for the server to reliably and properly handle the request.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_favorites_for_user_with_http_info(user_gid, resource_type, workspace, async_req=True)
+        >>> thread = api.create_attachment_for_object_with_http_info(async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
-        :param str resource_type: The resource type of favorites to be returned. (required)
-        :param str workspace: The workspace in which to get favorites. (required)
+        :param str resource_subtype:
+        :param str file:
+        :param str parent:
+        :param str url:
+        :param str name:
+        :param bool connect_to_app:
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: AsanaNamedResourceArray
+        :return: AttachmentResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['user_gid', 'resource_type', 'workspace', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_favorites_for_user" % key
+                    " to method create_attachment_for_object" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'user_gid' is set
-        if ('user_gid' not in params or
-                params['user_gid'] is None):
-            raise ValueError("Missing the required parameter `user_gid` when calling `get_favorites_for_user`")  # noqa: E501
-        # verify the required parameter 'resource_type' is set
-        if ('resource_type' not in params or
-                params['resource_type'] is None):
-            raise ValueError("Missing the required parameter `resource_type` when calling `get_favorites_for_user`")  # noqa: E501
-        # verify the required parameter 'workspace' is set
-        if ('workspace' not in params or
-                params['workspace'] is None):
-            raise ValueError("Missing the required parameter `workspace` when calling `get_favorites_for_user`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'user_gid' in params:
-            path_params['user_gid'] = params['user_gid']  # noqa: E501
 
-        query_params = []
-        if 'resource_type' in params:
-            query_params.append(('resource_type', params['resource_type']))  # noqa: E501
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
+        if 'resource_subtype' in opts:
+            form_params.append(('resource_subtype', opts['resource_subtype']))  # noqa: E501
 
-        body_params = None
-        # HTTP header `Accept`
-        header_params['Accept'] = self.api_client.select_header_accept(
-            ['application/json; charset=UTF-8'])  # noqa: E501
-
-        # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
-
-        return self.api_client.call_api(
-            '/users/{user_gid}/favorites', 'GET',
-            path_params,
-            query_params,
-            header_params,
-            body=body_params,
-            post_params=form_params,
-            files=local_var_files,
-            response_type='AsanaNamedResourceArray',  # noqa: E501
-            auth_settings=auth_settings,
-            async_req=params.get('async_req'),
-            _return_http_data_only=params.get('_return_http_data_only'),
-            _preload_content=params.get('_preload_content', True),
-            _request_timeout=params.get('_request_timeout'),
-            collection_formats=collection_formats)
-
-    def get_user(self, user_gid, **kwargs):  # noqa: E501
-        """Get a user  # noqa: E501
+            # Because form params and query params are both provided in the opts method parameter we need to remove the form params from the query params
+            query_params.pop('resource_subtype')
+        if 'file' in opts:
+            local_var_files['file'] = opts['file']  # noqa: E501
+
+            # Because form params and query params are both provided in the opts method parameter we need to remove the form params from the query params
+            query_params.pop('file')
+        if 'parent' in opts:
+            form_params.append(('parent', opts['parent']))  # noqa: E501
+
+            # Because form params and query params are both provided in the opts method parameter we need to remove the form params from the query params
+            query_params.pop('parent')
+        if 'url' in opts:
+            form_params.append(('url', opts['url']))  # noqa: E501
+
+            # Because form params and query params are both provided in the opts method parameter we need to remove the form params from the query params
+            query_params.pop('url')
+        if 'name' in opts:
+            form_params.append(('name', opts['name']))  # noqa: E501
+
+            # Because form params and query params are both provided in the opts method parameter we need to remove the form params from the query params
+            query_params.pop('name')
+        if 'connect_to_app' in opts:
+            form_params.append(('connect_to_app', opts['connect_to_app']))  # noqa: E501
 
-        Returns the full user record for the single user with the provided ID.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_user(user_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: UserResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-        kwargs['_return_http_data_only'] = True
-        if kwargs.get('async_req'):
-            return self.get_user_with_http_info(user_gid, **kwargs)  # noqa: E501
-        else:
-            (data) = self.get_user_with_http_info(user_gid, **kwargs)  # noqa: E501
-            return data
-
-    def get_user_with_http_info(self, user_gid, **kwargs):  # noqa: E501
-        """Get a user  # noqa: E501
-
-        Returns the full user record for the single user with the provided ID.  # noqa: E501
-        This method makes a synchronous HTTP request by default. To make an
-        asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_user_with_http_info(user_gid, async_req=True)
-        >>> result = thread.get()
-
-        :param async_req bool
-        :param str user_gid: A string identifying a user. This can either be the string \"me\", an email, or the gid of a user. (required)
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: UserResponseData
-                 If the method is called asynchronously,
-                 returns the request thread.
-        """
-
-        all_params = ['user_gid', 'opt_fields']  # noqa: E501
-        all_params.append('async_req')
-        all_params.append('_return_http_data_only')
-        all_params.append('_preload_content')
-        all_params.append('_request_timeout')
-
-        params = locals()
-        for key, val in six.iteritems(params['kwargs']):
-            if key not in all_params:
-                raise TypeError(
-                    "Got an unexpected keyword argument '%s'"
-                    " to method get_user" % key
-                )
-            params[key] = val
-        del params['kwargs']
-        # verify the required parameter 'user_gid' is set
-        if ('user_gid' not in params or
-                params['user_gid'] is None):
-            raise ValueError("Missing the required parameter `user_gid` when calling `get_user`")  # noqa: E501
-
-        collection_formats = {}
-
-        path_params = {}
-        if 'user_gid' in params:
-            path_params['user_gid'] = params['user_gid']  # noqa: E501
-
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
-
-        header_params = {}
-
-        form_params = []
-        local_var_files = {}
+            # Because form params and query params are both provided in the opts method parameter we need to remove the form params from the query params
+            query_params.pop('connect_to_app')
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
+        # HTTP header `Content-Type`
+        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
+            ['multipart/form-data'])  # noqa: E501
+
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/users/{user_gid}', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/attachments', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/attachments', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/attachments', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='UserResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_users(self, **kwargs):  # noqa: E501
-        """Get multiple users  # noqa: E501
+    def delete_attachment(self, attachment_gid, **kwargs):  # noqa: E501
+        """Delete an attachment  # noqa: E501
 
-        Returns the user records for all users in all workspaces and organizations accessible to the authenticated user. Accepts an optional workspace ID parameter. Results are sorted by user ID.  # noqa: E501
+        Deletes a specific, existing attachment.  Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_users(async_req=True)
+        >>> thread = api.delete_attachment(attachment_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str workspace: The workspace or organization ID to filter users on.
-        :param str team: The team ID to filter users on.
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: UserResponseArray
+        :param str attachment_gid: Globally unique identifier for the attachment. (required)
+        :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_users_with_http_info(**kwargs)  # noqa: E501
+            return self.delete_attachment_with_http_info(attachment_gid, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_users_with_http_info(**kwargs)  # noqa: E501
+            (data) = self.delete_attachment_with_http_info(attachment_gid, **kwargs)  # noqa: E501
             return data
 
-    def get_users_with_http_info(self, **kwargs):  # noqa: E501
-        """Get multiple users  # noqa: E501
+    def delete_attachment_with_http_info(self, attachment_gid, **kwargs):  # noqa: E501
+        """Delete an attachment  # noqa: E501
 
-        Returns the user records for all users in all workspaces and organizations accessible to the authenticated user. Accepts an optional workspace ID parameter. Results are sorted by user ID.  # noqa: E501
+        Deletes a specific, existing attachment.  Returns an empty data record.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_users_with_http_info(async_req=True)
+        >>> thread = api.delete_attachment_with_http_info(attachment_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str workspace: The workspace or organization ID to filter users on.
-        :param str team: The team ID to filter users on.
-        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
-        :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: UserResponseArray
+        :param str attachment_gid: Globally unique identifier for the attachment. (required)
+        :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace', 'team', 'limit', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_users" % key
+                    " to method delete_attachment" % key
                 )
             params[key] = val
         del params['kwargs']
+        # verify the required parameter 'attachment_gid' is set
+        if (attachment_gid is None):
+            raise ValueError("Missing the required parameter `attachment_gid` when calling `delete_attachment`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
+        path_params['attachment_gid'] = attachment_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'team' in params:
-            query_params.append(('team', params['team']))  # noqa: E501
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/users', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/attachments/{attachment_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/attachments/{attachment_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/attachments/{attachment_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='UserResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_users_for_team(self, team_gid, **kwargs):  # noqa: E501
-        """Get users in a team  # noqa: E501
+    def get_attachment(self, attachment_gid, opts, **kwargs):  # noqa: E501
+        """Get an attachment  # noqa: E501
 
-        Returns the compact records for all users that are members of the team. Results are sorted alphabetically and limited to 2000. For more results use the `/users` endpoint.  # noqa: E501
+        Get the full record for a single attachment.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_users_for_team(team_gid, async_req=True)
+        >>> thread = api.get_attachment(attachment_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str team_gid: Globally unique identifier for the team. (required)
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str attachment_gid: Globally unique identifier for the attachment. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: UserResponseArray
+        :return: AttachmentResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_users_for_team_with_http_info(team_gid, **kwargs)  # noqa: E501
+            return self.get_attachment_with_http_info(attachment_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_users_for_team_with_http_info(team_gid, **kwargs)  # noqa: E501
+            (data) = self.get_attachment_with_http_info(attachment_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_users_for_team_with_http_info(self, team_gid, **kwargs):  # noqa: E501
-        """Get users in a team  # noqa: E501
+    def get_attachment_with_http_info(self, attachment_gid, opts, **kwargs):  # noqa: E501
+        """Get an attachment  # noqa: E501
 
-        Returns the compact records for all users that are members of the team. Results are sorted alphabetically and limited to 2000. For more results use the `/users` endpoint.  # noqa: E501
+        Get the full record for a single attachment.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_users_for_team_with_http_info(team_gid, async_req=True)
+        >>> thread = api.get_attachment_with_http_info(attachment_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str team_gid: Globally unique identifier for the team. (required)
-        :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
+        :param str attachment_gid: Globally unique identifier for the attachment. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: UserResponseArray
+        :return: AttachmentResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['team_gid', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_users_for_team" % key
+                    " to method get_attachment" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'team_gid' is set
-        if ('team_gid' not in params or
-                params['team_gid'] is None):
-            raise ValueError("Missing the required parameter `team_gid` when calling `get_users_for_team`")  # noqa: E501
+        # verify the required parameter 'attachment_gid' is set
+        if (attachment_gid is None):
+            raise ValueError("Missing the required parameter `attachment_gid` when calling `get_attachment`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'team_gid' in params:
-            path_params['team_gid'] = params['team_gid']  # noqa: E501
+        path_params['attachment_gid'] = attachment_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/teams/{team_gid}/users', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/attachments/{attachment_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/attachments/{attachment_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
+            '/attachments/{attachment_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='UserResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_users_for_workspace(self, workspace_gid, **kwargs):  # noqa: E501
-        """Get users in a workspace or organization  # noqa: E501
+    def get_attachments_for_object(self, parent, opts, **kwargs):  # noqa: E501
+        """Get attachments from an object  # noqa: E501
 
-        Returns the compact records for all users in the specified workspace or organization. Results are sorted alphabetically and limited to 2000. For more results use the `/users` endpoint.  # noqa: E501
+        Returns the compact records for all attachments on the object.  There are three possible `parent` values for this request: `project`, `project_brief`, and `task`. For a project, an attachment refers to a file uploaded to the \"Key resources\" section in the project Overview. For a project brief, an attachment refers to inline files in the project brief itself. For a task, an attachment refers to a file directly associated to that task.  Note that within the Asana app, inline images in the task description do not appear in the index of image thumbnails nor as stories in the task. However, requests made to `GET /attachments` for a task will return all of the images in the task, including inline images.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_users_for_workspace(workspace_gid, async_req=True)
+        >>> thread = api.get_attachments_for_object(parent, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
+        :param str parent: Globally unique identifier for object to fetch statuses from. Must be a GID for a `project`, `project_brief`, or `task`. (required)
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: UserResponseArray
+        :return: AttachmentResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_users_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            return self.get_attachments_for_object_with_http_info(parent, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_users_for_workspace_with_http_info(workspace_gid, **kwargs)  # noqa: E501
+            (data) = self.get_attachments_for_object_with_http_info(parent, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_users_for_workspace_with_http_info(self, workspace_gid, **kwargs):  # noqa: E501
-        """Get users in a workspace or organization  # noqa: E501
+    def get_attachments_for_object_with_http_info(self, parent, opts, **kwargs):  # noqa: E501
+        """Get attachments from an object  # noqa: E501
 
-        Returns the compact records for all users in the specified workspace or organization. Results are sorted alphabetically and limited to 2000. For more results use the `/users` endpoint.  # noqa: E501
+        Returns the compact records for all attachments on the object.  There are three possible `parent` values for this request: `project`, `project_brief`, and `task`. For a project, an attachment refers to a file uploaded to the \"Key resources\" section in the project Overview. For a project brief, an attachment refers to inline files in the project brief itself. For a task, an attachment refers to a file directly associated to that task.  Note that within the Asana app, inline images in the task description do not appear in the index of image thumbnails nor as stories in the task. However, requests made to `GET /attachments` for a task will return all of the images in the task, including inline images.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
-        >>> thread = api.get_users_for_workspace_with_http_info(workspace_gid, async_req=True)
+        >>> thread = api.get_attachments_for_object_with_http_info(parent, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param str workspace_gid: Globally unique identifier for the workspace or organization. (required)
+        :param str parent: Globally unique identifier for object to fetch statuses from. Must be a GID for a `project`, `project_brief`, or `task`. (required)
+        :param int limit: Results per page. The number of objects to return per page. The value must be between 1 and 100.
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
-        :return: UserResponseArray
+        :return: AttachmentResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace_gid', 'offset', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
-                    " to method get_users_for_workspace" % key
+                    " to method get_attachments_for_object" % key
                 )
             params[key] = val
         del params['kwargs']
-        # verify the required parameter 'workspace_gid' is set
-        if ('workspace_gid' not in params or
-                params['workspace_gid'] is None):
-            raise ValueError("Missing the required parameter `workspace_gid` when calling `get_users_for_workspace`")  # noqa: E501
+        # verify the required parameter 'parent' is set
+        if (parent is None):
+            raise ValueError("Missing the required parameter `parent` when calling `get_attachments_for_object`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'workspace_gid' in params:
-            path_params['workspace_gid'] = params['workspace_gid']  # noqa: E501
 
-        query_params = []
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+        query_params['parent'] = parent
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
-            '/workspaces/{workspace_gid}/users', 'GET',
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/attachments', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/attachments',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
+            '/attachments', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='UserResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api/webhooks_api.py` & `asana_preview-1.2.40/asana_preview/api/webhooks_api.py`

 * *Files 21% similar despite different names*

```diff
@@ -12,127 +12,165 @@
 
 from __future__ import absolute_import
 
 import re  # noqa: F401
 
 # python 2 and python 3 compatibility library
 import six
-
 from asana_preview.api_client import ApiClient
-
+from asana_preview.pagination.event_iterator import EventIterator
+from asana_preview.pagination.page_iterator import PageIterator
 
 class WebhooksApi(object):
     """NOTE: This class is auto generated by the swagger code generator program.
 
     Do not edit the class manually.
     Ref: https://github.com/swagger-api/swagger-codegen
     """
 
     def __init__(self, api_client=None):
         if api_client is None:
             api_client = ApiClient()
         self.api_client = api_client
 
-    def create_webhook(self, body, **kwargs):  # noqa: E501
+    def create_webhook(self, body, opts, **kwargs):  # noqa: E501
         """Establish a webhook  # noqa: E501
 
         Establishing a webhook is a two-part process. First, a simple HTTP POST request initiates the creation similar to creating any other resource.  Next, in the middle of this request comes the confirmation handshake. When a webhook is created, we will send a test POST to the target with an `X-Hook-Secret` header. The target must respond with a `200 OK` or `204 No Content` and a matching `X-Hook-Secret` header to confirm that this webhook subscription is indeed expected. We strongly recommend storing this secret to be used to verify future webhook event signatures.  The POST request to create the webhook will then return with the status of the request. If you do not acknowledge the webhook’s confirmation handshake it will fail to setup, and you will receive an error in response to your attempt to create it. This means you need to be able to receive and complete the webhook *while* the POST request is in-flight (in other words, have a server that can handle requests asynchronously).  Invalid hostnames like localhost will recieve a 403 Forbidden status code.  ``` # Request curl -H \"Authorization: Bearer <personal_access_token>\" \\ -X POST https://app.asana.com/api/1.0/webhooks \\ -d \"resource=8675309\" \\ -d \"target=https://example.com/receive-webhook/7654\" ```  ``` # Handshake sent to https://example.com/ POST /receive-webhook/7654 X-Hook-Secret: b537207f20cbfa02357cf448134da559e8bd39d61597dcd5631b8012eae53e81 ```  ``` # Handshake response sent by example.com HTTP/1.1 200 X-Hook-Secret: b537207f20cbfa02357cf448134da559e8bd39d61597dcd5631b8012eae53e81 ```  ``` # Response HTTP/1.1 201 {   \"data\": {     \"gid\": \"43214\",     \"resource\": {       \"gid\": \"8675309\",       \"name\": \"Bugs\"     },     \"target\": \"https://example.com/receive-webhook/7654\",     \"active\": false,     \"last_success_at\": null,     \"last_failure_at\": null,     \"last_failure_content\": null   } } ```  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_webhook(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param WebhooksBody body: The webhook workspace and target. (required)
+        :param dict body: The webhook workspace and target. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: WebhookResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.create_webhook_with_http_info(body, **kwargs)  # noqa: E501
+            return self.create_webhook_with_http_info(body, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.create_webhook_with_http_info(body, **kwargs)  # noqa: E501
+            (data) = self.create_webhook_with_http_info(body, opts, **kwargs)  # noqa: E501
             return data
 
-    def create_webhook_with_http_info(self, body, **kwargs):  # noqa: E501
+    def create_webhook_with_http_info(self, body, opts, **kwargs):  # noqa: E501
         """Establish a webhook  # noqa: E501
 
         Establishing a webhook is a two-part process. First, a simple HTTP POST request initiates the creation similar to creating any other resource.  Next, in the middle of this request comes the confirmation handshake. When a webhook is created, we will send a test POST to the target with an `X-Hook-Secret` header. The target must respond with a `200 OK` or `204 No Content` and a matching `X-Hook-Secret` header to confirm that this webhook subscription is indeed expected. We strongly recommend storing this secret to be used to verify future webhook event signatures.  The POST request to create the webhook will then return with the status of the request. If you do not acknowledge the webhook’s confirmation handshake it will fail to setup, and you will receive an error in response to your attempt to create it. This means you need to be able to receive and complete the webhook *while* the POST request is in-flight (in other words, have a server that can handle requests asynchronously).  Invalid hostnames like localhost will recieve a 403 Forbidden status code.  ``` # Request curl -H \"Authorization: Bearer <personal_access_token>\" \\ -X POST https://app.asana.com/api/1.0/webhooks \\ -d \"resource=8675309\" \\ -d \"target=https://example.com/receive-webhook/7654\" ```  ``` # Handshake sent to https://example.com/ POST /receive-webhook/7654 X-Hook-Secret: b537207f20cbfa02357cf448134da559e8bd39d61597dcd5631b8012eae53e81 ```  ``` # Handshake response sent by example.com HTTP/1.1 200 X-Hook-Secret: b537207f20cbfa02357cf448134da559e8bd39d61597dcd5631b8012eae53e81 ```  ``` # Response HTTP/1.1 201 {   \"data\": {     \"gid\": \"43214\",     \"resource\": {       \"gid\": \"8675309\",       \"name\": \"Bugs\"     },     \"target\": \"https://example.com/receive-webhook/7654\",     \"active\": false,     \"last_success_at\": null,     \"last_failure_at\": null,     \"last_failure_content\": null   } } ```  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.create_webhook_with_http_info(body, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param WebhooksBody body: The webhook workspace and target. (required)
+        :param dict body: The webhook workspace and target. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: WebhookResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method create_webhook" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `create_webhook`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/webhooks', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/webhooks', 'POST',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/webhooks', 'POST',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='WebhookResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
@@ -147,15 +185,15 @@
 
         :param async_req bool
         :param str webhook_gid: Globally unique identifier for the webhook. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
             return self.delete_webhook_with_http_info(webhook_gid, **kwargs)  # noqa: E501
         else:
             (data) = self.delete_webhook_with_http_info(webhook_gid, **kwargs)  # noqa: E501
             return data
 
     def delete_webhook_with_http_info(self, webhook_gid, **kwargs):  # noqa: E501
@@ -169,73 +207,114 @@
 
         :param async_req bool
         :param str webhook_gid: Globally unique identifier for the webhook. (required)
         :return: EmptyResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['webhook_gid']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method delete_webhook" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'webhook_gid' is set
-        if ('webhook_gid' not in params or
-                params['webhook_gid'] is None):
+        if (webhook_gid is None):
             raise ValueError("Missing the required parameter `webhook_gid` when calling `delete_webhook`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'webhook_gid' in params:
-            path_params['webhook_gid'] = params['webhook_gid']  # noqa: E501
+        path_params['webhook_gid'] = webhook_gid  # noqa: E501
+
+        query_params = {}
 
-        query_params = []
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/webhooks/{webhook_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/webhooks/{webhook_gid}', 'DELETE',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/webhooks/{webhook_gid}', 'DELETE',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='EmptyResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_webhook(self, webhook_gid, **kwargs):  # noqa: E501
+    def get_webhook(self, webhook_gid, opts, **kwargs):  # noqa: E501
         """Get a webhook  # noqa: E501
 
         Returns the full record for the given webhook.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_webhook(webhook_gid, async_req=True)
         >>> result = thread.get()
@@ -243,22 +322,22 @@
         :param async_req bool
         :param str webhook_gid: Globally unique identifier for the webhook. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: WebhookResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_webhook_with_http_info(webhook_gid, **kwargs)  # noqa: E501
+            return self.get_webhook_with_http_info(webhook_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_webhook_with_http_info(webhook_gid, **kwargs)  # noqa: E501
+            (data) = self.get_webhook_with_http_info(webhook_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_webhook_with_http_info(self, webhook_gid, **kwargs):  # noqa: E501
+    def get_webhook_with_http_info(self, webhook_gid, opts, **kwargs):  # noqa: E501
         """Get a webhook  # noqa: E501
 
         Returns the full record for the given webhook.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_webhook_with_http_info(webhook_gid, async_req=True)
         >>> result = thread.get()
@@ -266,76 +345,115 @@
         :param async_req bool
         :param str webhook_gid: Globally unique identifier for the webhook. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: WebhookResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['webhook_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_webhook" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'webhook_gid' is set
-        if ('webhook_gid' not in params or
-                params['webhook_gid'] is None):
+        if (webhook_gid is None):
             raise ValueError("Missing the required parameter `webhook_gid` when calling `get_webhook`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'webhook_gid' in params:
-            path_params['webhook_gid'] = params['webhook_gid']  # noqa: E501
+        path_params['webhook_gid'] = webhook_gid  # noqa: E501
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
 
-        header_params = {}
+
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/webhooks/{webhook_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/webhooks/{webhook_gid}', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/webhooks/{webhook_gid}', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='WebhookResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def get_webhooks(self, workspace, **kwargs):  # noqa: E501
+    def get_webhooks(self, workspace, opts, **kwargs):  # noqa: E501
         """Get multiple webhooks  # noqa: E501
 
         Get the compact representation of all webhooks your app has registered for the authenticated user in the given workspace.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_webhooks(workspace, async_req=True)
         >>> result = thread.get()
@@ -346,22 +464,22 @@
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param str resource: Only return webhooks for the given resource.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: WebhookResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.get_webhooks_with_http_info(workspace, **kwargs)  # noqa: E501
+            return self.get_webhooks_with_http_info(workspace, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.get_webhooks_with_http_info(workspace, **kwargs)  # noqa: E501
+            (data) = self.get_webhooks_with_http_info(workspace, opts, **kwargs)  # noqa: E501
             return data
 
-    def get_webhooks_with_http_info(self, workspace, **kwargs):  # noqa: E501
+    def get_webhooks_with_http_info(self, workspace, opts, **kwargs):  # noqa: E501
         """Get multiple webhooks  # noqa: E501
 
         Get the compact representation of all webhooks your app has registered for the authenticated user in the given workspace.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.get_webhooks_with_http_info(workspace, async_req=True)
         >>> result = thread.get()
@@ -372,185 +490,257 @@
         :param str offset: Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. 'Note: You can only pass in an offset that was returned to you via a previously paginated request.'
         :param str resource: Only return webhooks for the given resource.
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: WebhookResponseArray
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['workspace', 'limit', 'offset', 'resource', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method get_webhooks" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'workspace' is set
-        if ('workspace' not in params or
-                params['workspace'] is None):
+        if (workspace is None):
             raise ValueError("Missing the required parameter `workspace` when calling `get_webhooks`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
 
-        query_params = []
-        if 'limit' in params:
-            query_params.append(('limit', params['limit']))  # noqa: E501
-        if 'offset' in params:
-            query_params.append(('offset', params['offset']))  # noqa: E501
-        if 'workspace' in params:
-            query_params.append(('workspace', params['workspace']))  # noqa: E501
-        if 'resource' in params:
-            query_params.append(('resource', params['resource']))  # noqa: E501
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
+        query_params = {}
+        query_params = opts
+        query_params['workspace'] = workspace
+
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
         body_params = None
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/webhooks', 'GET',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            query_params["limit"] = query_params.get("limit", self.api_client.configuration.page_limit)
+            return PageIterator(
+                self.api_client,
+                {
+                    "resource_path": '/webhooks',
+                    "method": 'GET',
+                    "path_params": path_params,
+                    "query_params": query_params,
+                    "header_params": header_params,
+                    "body": body_params,
+                    "post_params": form_params,
+                    "files": local_var_files,
+                    "response_type": object,
+                    "auth_settings": auth_settings,
+                    "async_req": params.get('async_req'),
+                    "_return_http_data_only": params.get('_return_http_data_only'),
+                    "_preload_content": params.get('_preload_content', True),
+                    "_request_timeout": params.get('_request_timeout'),
+                    "collection_formats": collection_formats
+                },
+                **kwargs
+            ).items()
+        else:
+            return self.api_client.call_api(
             '/webhooks', 'GET',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='WebhookResponseArray',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
 
-    def update_webhook(self, body, webhook_gid, **kwargs):  # noqa: E501
+    def update_webhook(self, body, webhook_gid, opts, **kwargs):  # noqa: E501
         """Update a webhook  # noqa: E501
 
         An existing webhook's filters can be updated by making a PUT request on the URL for that webhook. Note that the webhook's previous `filters` array will be completely overwritten by the `filters` sent in the PUT request.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_webhook(body, webhook_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param WebhooksWebhookGidBody body: The updated filters for the webhook. (required)
+        :param dict body: The updated filters for the webhook. (required)
         :param str webhook_gid: Globally unique identifier for the webhook. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: WebhookResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-        kwargs['_return_http_data_only'] = True
+        kwargs['_return_http_data_only'] = kwargs.get("_return_http_data_only", True)
         if kwargs.get('async_req'):
-            return self.update_webhook_with_http_info(body, webhook_gid, **kwargs)  # noqa: E501
+            return self.update_webhook_with_http_info(body, webhook_gid, opts, **kwargs)  # noqa: E501
         else:
-            (data) = self.update_webhook_with_http_info(body, webhook_gid, **kwargs)  # noqa: E501
+            (data) = self.update_webhook_with_http_info(body, webhook_gid, opts, **kwargs)  # noqa: E501
             return data
 
-    def update_webhook_with_http_info(self, body, webhook_gid, **kwargs):  # noqa: E501
+    def update_webhook_with_http_info(self, body, webhook_gid, opts, **kwargs):  # noqa: E501
         """Update a webhook  # noqa: E501
 
         An existing webhook's filters can be updated by making a PUT request on the URL for that webhook. Note that the webhook's previous `filters` array will be completely overwritten by the `filters` sent in the PUT request.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
         >>> thread = api.update_webhook_with_http_info(body, webhook_gid, async_req=True)
         >>> result = thread.get()
 
         :param async_req bool
-        :param WebhooksWebhookGidBody body: The updated filters for the webhook. (required)
+        :param dict body: The updated filters for the webhook. (required)
         :param str webhook_gid: Globally unique identifier for the webhook. (required)
         :param list[str] opt_fields: This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
         :return: WebhookResponseData
                  If the method is called asynchronously,
                  returns the request thread.
         """
-
-        all_params = ['body', 'webhook_gid', 'opt_fields']  # noqa: E501
+        all_params = []
         all_params.append('async_req')
+        all_params.append('header_params')
         all_params.append('_return_http_data_only')
         all_params.append('_preload_content')
         all_params.append('_request_timeout')
+        all_params.append('full_payload')
+        all_params.append('item_limit')
 
         params = locals()
         for key, val in six.iteritems(params['kwargs']):
             if key not in all_params:
                 raise TypeError(
                     "Got an unexpected keyword argument '%s'"
                     " to method update_webhook" % key
                 )
             params[key] = val
         del params['kwargs']
         # verify the required parameter 'body' is set
-        if ('body' not in params or
-                params['body'] is None):
+        if (body is None):
             raise ValueError("Missing the required parameter `body` when calling `update_webhook`")  # noqa: E501
         # verify the required parameter 'webhook_gid' is set
-        if ('webhook_gid' not in params or
-                params['webhook_gid'] is None):
+        if (webhook_gid is None):
             raise ValueError("Missing the required parameter `webhook_gid` when calling `update_webhook`")  # noqa: E501
 
         collection_formats = {}
 
         path_params = {}
-        if 'webhook_gid' in params:
-            path_params['webhook_gid'] = params['webhook_gid']  # noqa: E501
+        path_params['webhook_gid'] = webhook_gid  # noqa: E501
+
+        query_params = {}
+        query_params = opts
 
-        query_params = []
-        if 'opt_fields' in params:
-            query_params.append(('opt_fields', params['opt_fields']))  # noqa: E501
-            collection_formats['opt_fields'] = 'csv'  # noqa: E501
 
-        header_params = {}
+        header_params = kwargs.get("header_params", {})
 
         form_params = []
         local_var_files = {}
 
-        body_params = None
-        if 'body' in params:
-            body_params = params['body']
+        body_params = body
+
         # HTTP header `Accept`
         header_params['Accept'] = self.api_client.select_header_accept(
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # HTTP header `Content-Type`
         header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
             ['application/json; charset=UTF-8'])  # noqa: E501
 
         # Authentication setting
-        auth_settings = ['oauth2']  # noqa: E501
+        auth_settings = ['personalAccessToken']  # noqa: E501
 
-        return self.api_client.call_api(
+        # hard checking for True boolean value because user can provide full_payload or async_req with any data type
+        if kwargs.get("full_payload", False) is True or kwargs.get('async_req', False) is True:
+            return self.api_client.call_api(
+                '/webhooks/{webhook_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+        elif self.api_client.configuration.return_page_iterator:
+            (data) = self.api_client.call_api(
+                '/webhooks/{webhook_gid}', 'PUT',
+                path_params,
+                query_params,
+                header_params,
+                body=body_params,
+                post_params=form_params,
+                files=local_var_files,
+                response_type=object,  # noqa: E501
+                auth_settings=auth_settings,
+                async_req=params.get('async_req'),
+                _return_http_data_only=params.get('_return_http_data_only'),
+                _preload_content=params.get('_preload_content', True),
+                _request_timeout=params.get('_request_timeout'),
+                collection_formats=collection_formats
+            )
+            if params.get('_return_http_data_only') == False:
+                return data
+            return data["data"] if data else data
+        else:
+            return self.api_client.call_api(
             '/webhooks/{webhook_gid}', 'PUT',
             path_params,
             query_params,
             header_params,
             body=body_params,
             post_params=form_params,
             files=local_var_files,
-            response_type='WebhookResponseData',  # noqa: E501
+            response_type=object,  # noqa: E501
             auth_settings=auth_settings,
             async_req=params.get('async_req'),
             _return_http_data_only=params.get('_return_http_data_only'),
             _preload_content=params.get('_preload_content', True),
             _request_timeout=params.get('_request_timeout'),
             collection_formats=collection_formats)
```

### Comparing `asana_preview-1.0.9/asana_preview/api_client.py` & `asana_preview-1.2.40/asana_preview/api_client.py`

 * *Files 8% similar despite different names*

```diff
@@ -6,30 +6,33 @@
 
     OpenAPI spec version: 1.0
     
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 """
 from __future__ import absolute_import
 
+import logging
 import datetime
 import json
 import mimetypes
 from multiprocessing.pool import ThreadPool
 import os
+import platform
 import re
 import tempfile
 
 # python 2 and python 3 compatibility library
 import six
 from six.moves.urllib.parse import quote
 
 from asana_preview.configuration import Configuration
-import asana_preview.models
 from asana_preview import rest
 
+from urllib.parse import urlencode
+
 
 class ApiClient(object):
     """Generic API client for Swagger client library builds.
 
     Swagger generic API client. This client handles the client-
     server communication, and is invariant across implementations. Specifics of
     the methods and models for each application are generated from the Swagger
@@ -61,26 +64,40 @@
 
     def __init__(self, configuration=None, header_name=None, header_value=None,
                  cookie=None):
         if configuration is None:
             configuration = Configuration()
         self.configuration = configuration
 
-        self.pool = ThreadPool()
+        try:
+            self.pool = ThreadPool()
+        except OSError:
+            logging.warning('Looks like your system does not support ThreadPool but it will try without it if you do not use async requests')
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
-        self.user_agent = 'Swagger-Codegen/1.0.9/python'
+        self.user_agent = 'Swagger-Codegen/1.2.40/python'
+        # Add custom header
+        self.default_headers['X-Asana-Client-Lib'] = urlencode(
+            {
+                'language': 'Python',
+                'version': '1.2.40',
+                'language_version': platform.python_version(),
+                'os': platform.system(),
+                'os_version': platform.release()
+            }
+        )
 
     def __del__(self):
-        self.pool.close()
-        self.pool.join()
+        if hasattr(self, "pool"):
+            self.pool.close()
+            self.pool.join()
 
     @property
     def user_agent(self):
         """User agent for this API client"""
         return self.default_headers['User-Agent']
 
     @user_agent.setter
@@ -221,15 +238,17 @@
         # handle file downloading
         # save response body into a tmp file and return the instance
         if response_type == "file":
             return self.__deserialize_file(response)
 
         # fetch data from response object
         try:
-            data = json.loads(response.data)
+            # Decode the byte string and replace non-breaking space characters with regular
+            # spaces then parse the json bytes into a python dict
+            data = json.loads(response.data.decode('utf8').replace('\xa0', ' '))
         except ValueError:
             data = response.data
 
         return self.__deserialize(data, response_type)
 
     def __deserialize(self, data, klass):
         """Deserializes dict, list, str into an object.
@@ -252,27 +271,25 @@
                 sub_kls = re.match(r'dict\(([^,]*), (.*)\)', klass).group(2)
                 return {k: self.__deserialize(v, sub_kls)
                         for k, v in six.iteritems(data)}
 
             # convert str to class
             if klass in self.NATIVE_TYPES_MAPPING:
                 klass = self.NATIVE_TYPES_MAPPING[klass]
-            else:
-                klass = getattr(asana_preview.models, klass)
 
         if klass in self.PRIMITIVE_TYPES:
             return self.__deserialize_primitive(data, klass)
         elif klass == object:
             return self.__deserialize_object(data)
         elif klass == datetime.date:
             return self.__deserialize_date(data)
         elif klass == datetime.datetime:
             return self.__deserialize_datatime(data)
         else:
-            return self.__deserialize_model(data, klass)
+            return data
 
     def call_api(self, resource_path, method,
                  path_params=None, query_params=None, header_params=None,
                  body=None, post_params=None, files=None,
                  response_type=None, auth_settings=None, async_req=None,
                  _return_http_data_only=None, collection_formats=None,
                  _preload_content=True, _request_timeout=None):
@@ -308,14 +325,21 @@
         :return:
             If async_req parameter is True,
             the request will be called asynchronously.
             The method will return the request thread.
             If parameter async_req is False or missing,
             then the method will return the response directly.
         """
+
+        # Convert query params dict into a list of query param tuples.
+        # This step was previous implemented in the api.mustache but we needed
+        # to modify the query params dict for pagination so we move this conversion step here
+        if query_params:
+            query_params = [(k, v) for k, v in query_params.items()]
+
         if not async_req:
             return self.__call_api(resource_path, method,
                                    path_params, query_params, header_params,
                                    body, post_params, files,
                                    response_type, auth_settings,
                                    _return_http_data_only, collection_formats,
                                    _preload_content, _request_timeout)
@@ -488,15 +512,20 @@
         :param querys: Query parameters tuple list to be updated.
         :param auth_settings: Authentication setting identifiers list.
         """
         if not auth_settings:
             return
 
         for auth in auth_settings:
-            auth_setting = self.configuration.auth_settings().get(auth)
+            # In the OAS we define "personalAccessToken" but for the SDK we want users to use the term "token"
+            # this logic will get the auth_settings for "token" settings that we've added
+            if auth == 'personalAccessToken':
+                auth_setting = self.configuration.auth_settings().get('token')
+            else:
+                auth_setting = self.configuration.auth_settings().get(auth)
             if auth_setting:
                 if not auth_setting['value']:
                     continue
                 elif auth_setting['in'] == 'header':
                     headers[auth_setting['key']] = auth_setting['value']
                 elif auth_setting['in'] == 'query':
                     querys.append((auth_setting['key'], auth_setting['value']))
@@ -592,41 +621,7 @@
                     "Failed to parse `{0}` as datetime object"
                     .format(string)
                 )
             )
 
     def __hasattr(self, object, name):
             return name in object.__class__.__dict__
-
-    def __deserialize_model(self, data, klass):
-        """Deserializes list or dict to model.
-
-        :param data: dict, list.
-        :param klass: class literal.
-        :return: model object.
-        """
-
-        if not klass.swagger_types and not self.__hasattr(klass, 'get_real_child_model'):
-            return data
-
-        kwargs = {}
-        if klass.swagger_types is not None:
-            for attr, attr_type in six.iteritems(klass.swagger_types):
-                if (data is not None and
-                        klass.attribute_map[attr] in data and
-                        isinstance(data, (list, dict))):
-                    value = data[klass.attribute_map[attr]]
-                    kwargs[attr] = self.__deserialize(value, attr_type)
-
-        instance = klass(**kwargs)
-
-        if (isinstance(instance, dict) and
-                klass.swagger_types is not None and
-                isinstance(data, dict)):
-            for key, value in data.items():
-                if key not in klass.swagger_types:
-                    instance[key] = value
-        if self.__hasattr(instance, 'get_real_child_model'):
-            klass_name = instance.get_real_child_model(data)
-            if klass_name:
-                instance = self.__deserialize(data, klass_name)
-        return instance
```

### Comparing `asana_preview-1.0.9/asana_preview/configuration.py` & `asana_preview-1.2.40/asana_preview/configuration.py`

 * *Files 3% similar despite different names*

```diff
@@ -57,16 +57,14 @@
         self.api_key_prefix = {}
         # function to refresh API key if expired
         self.refresh_api_key_hook = None
         # Username for HTTP basic authentication
         self.username = ""
         # Password for HTTP basic authentication
         self.password = ""
-        # access token for OAuth
-        self.access_token = ""
         # Logging Settings
         self.logger = {}
         self.logger["package_logger"] = logging.getLogger("asana_preview")
         self.logger["urllib3_logger"] = logging.getLogger("urllib3")
         # Log format
         self.logger_format = '%(asctime)s %(levelname)s %(message)s'
         # Log stream handler
@@ -99,14 +97,22 @@
         self.connection_pool_maxsize = multiprocessing.cpu_count() * 5
 
         # Proxy URL
         self.proxy = None
         # Safe chars for path_param
         self.safe_chars_for_path_param = ''
 
+        # Collection
+        # by default we return a collection object to be used for pagination.
+        # If the user wants to turn this off they can set this to False
+        self.return_page_iterator = True
+
+        # The default limit query parameter value for api endpoints that return multiple resources
+        self.page_limit = 100
+
     @property
     def logger_file(self):
         """The logger file.
 
         If the logger_file is None, then add stream handler and remove file
         handler. Otherwise, add file handler and remove stream handler.
 
@@ -227,17 +233,18 @@
 
     def auth_settings(self):
         """Gets Auth Settings dict for api client.
 
         :return: The Auth Settings information dict.
         """
         return {
-            'oauth2':
+            # Add a case for OAS bearer token definition
+            'token':
                 {
-                    'type': 'oauth2',
+                    'type': 'token',
                     'in': 'header',
                     'key': 'Authorization',
                     'value': 'Bearer ' + self.access_token
                 },
         }
 
     def to_debug_report(self):
@@ -245,9 +252,9 @@
 
         :return: The report for debugging.
         """
         return "Python SDK Debug Report:\n"\
                "OS: {env}\n"\
                "Python Version: {pyversion}\n"\
                "Version of the API: 1.0\n"\
-               "SDK Package Version: 1.0.9".\
+               "SDK Package Version: 1.2.40".\
                format(env=sys.platform, pyversion=sys.version)
```

### Comparing `asana_preview-1.0.9/asana_preview/rest.py` & `asana_preview-1.2.40/asana_preview/rest.py`

 * *Files 1% similar despite different names*

```diff
@@ -38,19 +38,19 @@
         self.urllib3_response = resp
         self.status = resp.status
         self.reason = resp.reason
         self.data = resp.data
 
     def getheaders(self):
         """Returns a dictionary of the response headers."""
-        return self.urllib3_response.getheaders()
+        return self.urllib3_response.headers
 
     def getheader(self, name, default=None):
         """Returns a given response header."""
-        return self.urllib3_response.getheader(name, default)
+        return self.urllib3_response.headers.get(name, default)
 
 
 class RESTClientObject(object):
 
     def __init__(self, configuration, pools_size=4, maxsize=None):
         # urllib3.PoolManager will pass all kw parameters to connectionpool
         # https://github.com/shazow/urllib3/blob/f9409436f83aeb79fbaf090181cd81b784f1b8ce/urllib3/poolmanager.py#L75  # noqa: E501
```

### Comparing `asana_preview-1.0.9/setup.py` & `asana_preview-1.2.40/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,15 +10,15 @@
     Generated by: https://github.com/swagger-api/swagger-codegen.git
 """
 
 import os
 from setuptools import setup, find_packages  # noqa: H301
 
 NAME = "asana_preview"
-VERSION = "1.0.9"
+VERSION = "1.2.40"
 with open(os.path.join(os.path.dirname(__file__), 'README.md')) as readme:
     LONG_DESCRIPTION = readme.read()
 # To install the library, run the following
 #
 # python setup.py install
 #
 # prerequisite: setuptools
```

### Comparing `asana_preview-1.0.9/test/test_add_custom_field_setting_request.py` & `asana_preview-1.2.40/test/test_rules_api.py`

 * *Files 23% similar despite different names*

```diff
@@ -11,29 +11,30 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.add_custom_field_setting_request import AddCustomFieldSettingRequest  # noqa: E501
+from asana_preview.api.rules_api import RulesApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAddCustomFieldSettingRequest(unittest.TestCase):
-    """AddCustomFieldSettingRequest unit test stubs"""
+class TestRulesApi(unittest.TestCase):
+    """RulesApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = RulesApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testAddCustomFieldSettingRequest(self):
-        """Test AddCustomFieldSettingRequest"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.add_custom_field_setting_request.AddCustomFieldSettingRequest()  # noqa: E501
+    def test_trigger_rule(self):
+        """Test case for trigger_rule
+
+        Trigger a rule  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_add_followers_request.py` & `asana_preview-1.2.40/test/test_jobs_api.py`

 * *Files 19% similar despite different names*

```diff
@@ -11,29 +11,30 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.add_followers_request import AddFollowersRequest  # noqa: E501
+from asana_preview.api.jobs_api import JobsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAddFollowersRequest(unittest.TestCase):
-    """AddFollowersRequest unit test stubs"""
+class TestJobsApi(unittest.TestCase):
+    """JobsApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = JobsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testAddFollowersRequest(self):
-        """Test AddFollowersRequest"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.add_followers_request.AddFollowersRequest()  # noqa: E501
+    def test_get_job(self):
+        """Test case for get_job
+
+        Get a job by id  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_add_members_request.py` & `asana_preview-1.2.40/test/test_batch_api_api.py`

 * *Files 25% similar despite different names*

```diff
@@ -11,29 +11,30 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.add_members_request import AddMembersRequest  # noqa: E501
+from asana_preview.api.batch_api_api import BatchAPIApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAddMembersRequest(unittest.TestCase):
-    """AddMembersRequest unit test stubs"""
+class TestBatchAPIApi(unittest.TestCase):
+    """BatchAPIApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = BatchAPIApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testAddMembersRequest(self):
-        """Test AddMembersRequest"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.add_members_request.AddMembersRequest()  # noqa: E501
+    def test_create_batch_request(self):
+        """Test case for create_batch_request
+
+        Submit parallel requests  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_all_of_project_response_owner.py` & `asana_preview-1.2.40/test/test_audit_log_api_api.py`

 * *Files 24% similar despite different names*

```diff
@@ -11,29 +11,30 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.all_of_project_response_owner import AllOfProjectResponseOwner  # noqa: E501
+from asana_preview.api.audit_log_api_api import AuditLogAPIApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAllOfProjectResponseOwner(unittest.TestCase):
-    """AllOfProjectResponseOwner unit test stubs"""
+class TestAuditLogAPIApi(unittest.TestCase):
+    """AuditLogAPIApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = AuditLogAPIApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testAllOfProjectResponseOwner(self):
-        """Test AllOfProjectResponseOwner"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.all_of_project_response_owner.AllOfProjectResponseOwner()  # noqa: E501
+    def test_get_audit_log_events(self):
+        """Test case for get_audit_log_events
+
+        Get audit log events  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_all_of_story_response_old_date_value.py` & `asana_preview-1.2.40/test/test_events_api.py`

 * *Files 24% similar despite different names*

```diff
@@ -11,29 +11,30 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.all_of_story_response_old_date_value import AllOfStoryResponseOldDateValue  # noqa: E501
+from asana_preview.api.events_api import EventsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAllOfStoryResponseOldDateValue(unittest.TestCase):
-    """AllOfStoryResponseOldDateValue unit test stubs"""
+class TestEventsApi(unittest.TestCase):
+    """EventsApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = EventsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testAllOfStoryResponseOldDateValue(self):
-        """Test AllOfStoryResponseOldDateValue"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.all_of_story_response_old_date_value.AllOfStoryResponseOldDateValue()  # noqa: E501
+    def test_get_events(self):
+        """Test case for get_events
+
+        Get events on a resource  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_all_of_task_response_assignee_section.py` & `asana_preview-1.2.40/test/test_stories_api.py`

 * *Files 25% similar despite different names*

```diff
@@ -11,29 +11,58 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.all_of_task_response_assignee_section import AllOfTaskResponseAssigneeSection  # noqa: E501
+from asana_preview.api.stories_api import StoriesApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAllOfTaskResponseAssigneeSection(unittest.TestCase):
-    """AllOfTaskResponseAssigneeSection unit test stubs"""
+class TestStoriesApi(unittest.TestCase):
+    """StoriesApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = StoriesApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testAllOfTaskResponseAssigneeSection(self):
-        """Test AllOfTaskResponseAssigneeSection"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.all_of_task_response_assignee_section.AllOfTaskResponseAssigneeSection()  # noqa: E501
+    def test_create_story_for_task(self):
+        """Test case for create_story_for_task
+
+        Create a story on a task  # noqa: E501
+        """
+        pass
+
+    def test_delete_story(self):
+        """Test case for delete_story
+
+        Delete a story  # noqa: E501
+        """
+        pass
+
+    def test_get_stories_for_task(self):
+        """Test case for get_stories_for_task
+
+        Get stories from a task  # noqa: E501
+        """
+        pass
+
+    def test_get_story(self):
+        """Test case for get_story
+
+        Get a story  # noqa: E501
+        """
+        pass
+
+    def test_update_story(self):
+        """Test case for update_story
+
+        Update a story  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_all_of_user_task_list_compact_owner.py` & `asana_preview-1.2.40/test/test_user_task_lists_api.py`

 * *Files 26% similar despite different names*

```diff
@@ -11,29 +11,37 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.all_of_user_task_list_compact_owner import AllOfUserTaskListCompactOwner  # noqa: E501
+from asana_preview.api.user_task_lists_api import UserTaskListsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAllOfUserTaskListCompactOwner(unittest.TestCase):
-    """AllOfUserTaskListCompactOwner unit test stubs"""
+class TestUserTaskListsApi(unittest.TestCase):
+    """UserTaskListsApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = UserTaskListsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testAllOfUserTaskListCompactOwner(self):
-        """Test AllOfUserTaskListCompactOwner"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.all_of_user_task_list_compact_owner.AllOfUserTaskListCompactOwner()  # noqa: E501
+    def test_get_user_task_list(self):
+        """Test case for get_user_task_list
+
+        Get a user task list  # noqa: E501
+        """
+        pass
+
+    def test_get_user_task_list_for_user(self):
+        """Test case for get_user_task_list_for_user
+
+        Get a user's task list  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_all_of_workspace_membership_response_user_task_list_workspace.py` & `asana_preview-1.2.40/test/test_workspace_memberships_api.py`

 * *Files 24% similar despite different names*

```diff
@@ -11,29 +11,44 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.all_of_workspace_membership_response_user_task_list_workspace import AllOfWorkspaceMembershipResponseUserTaskListWorkspace  # noqa: E501
+from asana_preview.api.workspace_memberships_api import WorkspaceMembershipsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAllOfWorkspaceMembershipResponseUserTaskListWorkspace(unittest.TestCase):
-    """AllOfWorkspaceMembershipResponseUserTaskListWorkspace unit test stubs"""
+class TestWorkspaceMembershipsApi(unittest.TestCase):
+    """WorkspaceMembershipsApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = WorkspaceMembershipsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testAllOfWorkspaceMembershipResponseUserTaskListWorkspace(self):
-        """Test AllOfWorkspaceMembershipResponseUserTaskListWorkspace"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.all_of_workspace_membership_response_user_task_list_workspace.AllOfWorkspaceMembershipResponseUserTaskListWorkspace()  # noqa: E501
+    def test_get_workspace_membership(self):
+        """Test case for get_workspace_membership
+
+        Get a workspace membership  # noqa: E501
+        """
+        pass
+
+    def test_get_workspace_memberships_for_user(self):
+        """Test case for get_workspace_memberships_for_user
+
+        Get workspace memberships for a user  # noqa: E501
+        """
+        pass
+
+    def test_get_workspace_memberships_for_workspace(self):
+        """Test case for get_workspace_memberships_for_workspace
+
+        Get the workspace memberships for a workspace  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_asana_named_resource_array.py` & `asana_preview-1.2.40/test/test_task_templates_api.py`

 * *Files 26% similar despite different names*

```diff
@@ -11,29 +11,44 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.asana_named_resource_array import AsanaNamedResourceArray  # noqa: E501
+from asana_preview.api.task_templates_api import TaskTemplatesApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAsanaNamedResourceArray(unittest.TestCase):
-    """AsanaNamedResourceArray unit test stubs"""
+class TestTaskTemplatesApi(unittest.TestCase):
+    """TaskTemplatesApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = TaskTemplatesApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testAsanaNamedResourceArray(self):
-        """Test AsanaNamedResourceArray"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.asana_named_resource_array.AsanaNamedResourceArray()  # noqa: E501
+    def test_get_task_template(self):
+        """Test case for get_task_template
+
+        Get a task template  # noqa: E501
+        """
+        pass
+
+    def test_get_task_templates(self):
+        """Test case for get_task_templates
+
+        Get multiple task templates  # noqa: E501
+        """
+        pass
+
+    def test_instantiate_task(self):
+        """Test case for instantiate_task
+
+        Instantiate a task from a task template  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_attachment_compact.py` & `asana_preview-1.2.40/test/test_custom_field_settings_api.py`

 * *Files 27% similar despite different names*

```diff
@@ -11,29 +11,37 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.attachment_compact import AttachmentCompact  # noqa: E501
+from asana_preview.api.custom_field_settings_api import CustomFieldSettingsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAttachmentCompact(unittest.TestCase):
-    """AttachmentCompact unit test stubs"""
+class TestCustomFieldSettingsApi(unittest.TestCase):
+    """CustomFieldSettingsApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = CustomFieldSettingsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testAttachmentCompact(self):
-        """Test AttachmentCompact"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.attachment_compact.AttachmentCompact()  # noqa: E501
+    def test_get_custom_field_settings_for_portfolio(self):
+        """Test case for get_custom_field_settings_for_portfolio
+
+        Get a portfolio's custom fields  # noqa: E501
+        """
+        pass
+
+    def test_get_custom_field_settings_for_project(self):
+        """Test case for get_custom_field_settings_for_project
+
+        Get a project's custom fields  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_attachment_response_data.py` & `asana_preview-1.2.40/test/test_attachments_api.py`

 * *Files 26% similar despite different names*

```diff
@@ -11,29 +11,51 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.attachment_response_data import AttachmentResponseData  # noqa: E501
+from asana_preview.api.attachments_api import AttachmentsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAttachmentResponseData(unittest.TestCase):
-    """AttachmentResponseData unit test stubs"""
+class TestAttachmentsApi(unittest.TestCase):
+    """AttachmentsApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = AttachmentsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testAttachmentResponseData(self):
-        """Test AttachmentResponseData"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.attachment_response_data.AttachmentResponseData()  # noqa: E501
+    def test_create_attachment_for_object(self):
+        """Test case for create_attachment_for_object
+
+        Upload an attachment  # noqa: E501
+        """
+        pass
+
+    def test_delete_attachment(self):
+        """Test case for delete_attachment
+
+        Delete an attachment  # noqa: E501
+        """
+        pass
+
+    def test_get_attachment(self):
+        """Test case for get_attachment
+
+        Get an attachment  # noqa: E501
+        """
+        pass
+
+    def test_get_attachments_for_object(self):
+        """Test case for get_attachments_for_object
+
+        Get attachments from an object  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_attachments_api.py` & `asana_preview-1.2.40/test/test_status_updates_api.py`

 * *Files 24% similar despite different names*

```diff
@@ -11,51 +11,51 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.api.attachments_api import AttachmentsApi  # noqa: E501
+from asana_preview.api.status_updates_api import StatusUpdatesApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAttachmentsApi(unittest.TestCase):
-    """AttachmentsApi unit test stubs"""
+class TestStatusUpdatesApi(unittest.TestCase):
+    """StatusUpdatesApi unit test stubs"""
 
     def setUp(self):
-        self.api = AttachmentsApi()  # noqa: E501
+        self.api = StatusUpdatesApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def test_create_attachment_for_object(self):
-        """Test case for create_attachment_for_object
+    def test_create_status_for_object(self):
+        """Test case for create_status_for_object
 
-        Upload an attachment  # noqa: E501
+        Create a status update  # noqa: E501
         """
         pass
 
-    def test_delete_attachment(self):
-        """Test case for delete_attachment
+    def test_delete_status(self):
+        """Test case for delete_status
 
-        Delete an attachment  # noqa: E501
+        Delete a status update  # noqa: E501
         """
         pass
 
-    def test_get_attachment(self):
-        """Test case for get_attachment
+    def test_get_status(self):
+        """Test case for get_status
 
-        Get an attachment  # noqa: E501
+        Get a status update  # noqa: E501
         """
         pass
 
-    def test_get_attachments_for_object(self):
-        """Test case for get_attachments_for_object
+    def test_get_statuses_for_object(self):
+        """Test case for get_statuses_for_object
 
-        Get attachments from an object  # noqa: E501
+        Get status updates from an object  # noqa: E501
         """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_audit_log_api_api.py` & `asana_preview-1.2.40/test/test_time_periods_api.py`

 * *Files 23% similar despite different names*

```diff
@@ -11,30 +11,37 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.api.audit_log_api_api import AuditLogAPIApi  # noqa: E501
+from asana_preview.api.time_periods_api import TimePeriodsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestAuditLogAPIApi(unittest.TestCase):
-    """AuditLogAPIApi unit test stubs"""
+class TestTimePeriodsApi(unittest.TestCase):
+    """TimePeriodsApi unit test stubs"""
 
     def setUp(self):
-        self.api = AuditLogAPIApi()  # noqa: E501
+        self.api = TimePeriodsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def test_get_audit_log_events(self):
-        """Test case for get_audit_log_events
+    def test_get_time_period(self):
+        """Test case for get_time_period
 
-        Get audit log events  # noqa: E501
+        Get a time period  # noqa: E501
+        """
+        pass
+
+    def test_get_time_periods(self):
+        """Test case for get_time_periods
+
+        Get time periods  # noqa: E501
         """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_batch_api_api.py` & `asana_preview-1.2.40/test/test_organization_exports_api.py`

 * *Files 22% similar despite different names*

```diff
@@ -11,30 +11,37 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.api.batch_api_api import BatchAPIApi  # noqa: E501
+from asana_preview.api.organization_exports_api import OrganizationExportsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestBatchAPIApi(unittest.TestCase):
-    """BatchAPIApi unit test stubs"""
+class TestOrganizationExportsApi(unittest.TestCase):
+    """OrganizationExportsApi unit test stubs"""
 
     def setUp(self):
-        self.api = BatchAPIApi()  # noqa: E501
+        self.api = OrganizationExportsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def test_create_batch_request(self):
-        """Test case for create_batch_request
+    def test_create_organization_export(self):
+        """Test case for create_organization_export
 
-        Submit parallel requests  # noqa: E501
+        Create an organization export request  # noqa: E501
+        """
+        pass
+
+    def test_get_organization_export(self):
+        """Test case for get_organization_export
+
+        Get details on an org export request  # noqa: E501
         """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_batch_request_actions.py` & `asana_preview-1.2.40/test/test_typeahead_api.py`

 * *Files 27% similar despite different names*

```diff
@@ -11,29 +11,30 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.batch_request_actions import BatchRequestActions  # noqa: E501
+from asana_preview.api.typeahead_api import TypeaheadApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestBatchRequestActions(unittest.TestCase):
-    """BatchRequestActions unit test stubs"""
+class TestTypeaheadApi(unittest.TestCase):
+    """TypeaheadApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = TypeaheadApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testBatchRequestActions(self):
-        """Test BatchRequestActions"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.batch_request_actions.BatchRequestActions()  # noqa: E501
+    def test_typeahead_for_workspace(self):
+        """Test case for typeahead_for_workspace
+
+        Get objects via typeahead  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_custom_field_settings_api.py` & `asana_preview-1.2.40/test/test_webhooks_api.py`

 * *Files 26% similar despite different names*

```diff
@@ -11,37 +11,58 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.api.custom_field_settings_api import CustomFieldSettingsApi  # noqa: E501
+from asana_preview.api.webhooks_api import WebhooksApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestCustomFieldSettingsApi(unittest.TestCase):
-    """CustomFieldSettingsApi unit test stubs"""
+class TestWebhooksApi(unittest.TestCase):
+    """WebhooksApi unit test stubs"""
 
     def setUp(self):
-        self.api = CustomFieldSettingsApi()  # noqa: E501
+        self.api = WebhooksApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def test_get_custom_field_settings_for_portfolio(self):
-        """Test case for get_custom_field_settings_for_portfolio
+    def test_create_webhook(self):
+        """Test case for create_webhook
 
-        Get a portfolio's custom fields  # noqa: E501
+        Establish a webhook  # noqa: E501
         """
         pass
 
-    def test_get_custom_field_settings_for_project(self):
-        """Test case for get_custom_field_settings_for_project
+    def test_delete_webhook(self):
+        """Test case for delete_webhook
 
-        Get a project's custom fields  # noqa: E501
+        Delete a webhook  # noqa: E501
+        """
+        pass
+
+    def test_get_webhook(self):
+        """Test case for get_webhook
+
+        Get a webhook  # noqa: E501
+        """
+        pass
+
+    def test_get_webhooks(self):
+        """Test case for get_webhooks
+
+        Get multiple webhooks  # noqa: E501
+        """
+        pass
+
+    def test_update_webhook(self):
+        """Test case for update_webhook
+
+        Update a webhook  # noqa: E501
         """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_custom_fields_api.py` & `asana_preview-1.2.40/test/test_custom_fields_api.py`

 * *Files identical despite different names*

### Comparing `asana_preview-1.0.9/test/test_events_api.py` & `asana_preview-1.2.40/test/test_users_api.py`

 * *Files 27% similar despite different names*

```diff
@@ -11,30 +11,58 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.api.events_api import EventsApi  # noqa: E501
+from asana_preview.api.users_api import UsersApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestEventsApi(unittest.TestCase):
-    """EventsApi unit test stubs"""
+class TestUsersApi(unittest.TestCase):
+    """UsersApi unit test stubs"""
 
     def setUp(self):
-        self.api = EventsApi()  # noqa: E501
+        self.api = UsersApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def test_get_events(self):
-        """Test case for get_events
+    def test_get_favorites_for_user(self):
+        """Test case for get_favorites_for_user
 
-        Get events on a resource  # noqa: E501
+        Get a user's favorites  # noqa: E501
+        """
+        pass
+
+    def test_get_user(self):
+        """Test case for get_user
+
+        Get a user  # noqa: E501
+        """
+        pass
+
+    def test_get_users(self):
+        """Test case for get_users
+
+        Get multiple users  # noqa: E501
+        """
+        pass
+
+    def test_get_users_for_team(self):
+        """Test case for get_users_for_team
+
+        Get users in a team  # noqa: E501
+        """
+        pass
+
+    def test_get_users_for_workspace(self):
+        """Test case for get_users_for_workspace
+
+        Get users in a workspace or organization  # noqa: E501
         """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_goal_membership_response.py` & `asana_preview-1.2.40/test/test_project_memberships_api.py`

 * *Files 24% similar despite different names*

```diff
@@ -11,29 +11,37 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.goal_membership_response import GoalMembershipResponse  # noqa: E501
+from asana_preview.api.project_memberships_api import ProjectMembershipsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestGoalMembershipResponse(unittest.TestCase):
-    """GoalMembershipResponse unit test stubs"""
+class TestProjectMembershipsApi(unittest.TestCase):
+    """ProjectMembershipsApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = ProjectMembershipsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testGoalMembershipResponse(self):
-        """Test GoalMembershipResponse"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.goal_membership_response.GoalMembershipResponse()  # noqa: E501
+    def test_get_project_membership(self):
+        """Test case for get_project_membership
+
+        Get a project membership  # noqa: E501
+        """
+        pass
+
+    def test_get_project_memberships_for_project(self):
+        """Test case for get_project_memberships_for_project
+
+        Get memberships from a project  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_goal_relationships_api.py` & `asana_preview-1.2.40/test/test_goal_relationships_api.py`

 * *Files identical despite different names*

### Comparing `asana_preview-1.0.9/test/test_goals_api.py` & `asana_preview-1.2.40/test/test_goals_api.py`

 * *Files identical despite different names*

### Comparing `asana_preview-1.0.9/test/test_jobs_api.py` & `asana_preview-1.2.40/test/test_teams_api.py`

 * *Files 27% similar despite different names*

```diff
@@ -11,30 +11,72 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.api.jobs_api import JobsApi  # noqa: E501
+from asana_preview.api.teams_api import TeamsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestJobsApi(unittest.TestCase):
-    """JobsApi unit test stubs"""
+class TestTeamsApi(unittest.TestCase):
+    """TeamsApi unit test stubs"""
 
     def setUp(self):
-        self.api = JobsApi()  # noqa: E501
+        self.api = TeamsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def test_get_job(self):
-        """Test case for get_job
+    def test_add_user_for_team(self):
+        """Test case for add_user_for_team
 
-        Get a job by id  # noqa: E501
+        Add a user to a team  # noqa: E501
+        """
+        pass
+
+    def test_create_team(self):
+        """Test case for create_team
+
+        Create a team  # noqa: E501
+        """
+        pass
+
+    def test_get_team(self):
+        """Test case for get_team
+
+        Get a team  # noqa: E501
+        """
+        pass
+
+    def test_get_teams_for_user(self):
+        """Test case for get_teams_for_user
+
+        Get teams for a user  # noqa: E501
+        """
+        pass
+
+    def test_get_teams_for_workspace(self):
+        """Test case for get_teams_for_workspace
+
+        Get teams in a workspace  # noqa: E501
+        """
+        pass
+
+    def test_remove_user_for_team(self):
+        """Test case for remove_user_for_team
+
+        Remove a user from a team  # noqa: E501
+        """
+        pass
+
+    def test_update_team(self):
+        """Test case for update_team
+
+        Update a team  # noqa: E501
         """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_memberships_api.py` & `asana_preview-1.2.40/test/test_memberships_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -38,24 +38,24 @@
     def test_delete_membership(self):
         """Test case for delete_membership
 
         Delete a membership  # noqa: E501
         """
         pass
 
-    def test_get_memberships(self):
-        """Test case for get_memberships
+    def test_get_membership(self):
+        """Test case for get_membership
 
-        Get multiple memberships  # noqa: E501
+        Get a membership  # noqa: E501
         """
         pass
 
-    def test_update_membership(self):
-        """Test case for update_membership
+    def test_get_memberships(self):
+        """Test case for get_memberships
 
-        Update a membership  # noqa: E501
+        Get multiple memberships  # noqa: E501
         """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_portfolio_membership_response_data.py` & `asana_preview-1.2.40/test/test_portfolio_memberships_api.py`

 * *Files 20% similar despite different names*

```diff
@@ -11,29 +11,44 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.portfolio_membership_response_data import PortfolioMembershipResponseData  # noqa: E501
+from asana_preview.api.portfolio_memberships_api import PortfolioMembershipsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestPortfolioMembershipResponseData(unittest.TestCase):
-    """PortfolioMembershipResponseData unit test stubs"""
+class TestPortfolioMembershipsApi(unittest.TestCase):
+    """PortfolioMembershipsApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = PortfolioMembershipsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testPortfolioMembershipResponseData(self):
-        """Test PortfolioMembershipResponseData"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.portfolio_membership_response_data.PortfolioMembershipResponseData()  # noqa: E501
+    def test_get_portfolio_membership(self):
+        """Test case for get_portfolio_membership
+
+        Get a portfolio membership  # noqa: E501
+        """
+        pass
+
+    def test_get_portfolio_memberships(self):
+        """Test case for get_portfolio_memberships
+
+        Get multiple portfolio memberships  # noqa: E501
+        """
+        pass
+
+    def test_get_portfolio_memberships_for_portfolio(self):
+        """Test case for get_portfolio_memberships_for_portfolio
+
+        Get memberships from a portfolio  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_portfolio_memberships_api.py` & `asana_preview-1.2.40/test/test_team_memberships_api.py`

 * *Files 18% similar despite different names*

```diff
@@ -11,44 +11,51 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.api.portfolio_memberships_api import PortfolioMembershipsApi  # noqa: E501
+from asana_preview.api.team_memberships_api import TeamMembershipsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestPortfolioMembershipsApi(unittest.TestCase):
-    """PortfolioMembershipsApi unit test stubs"""
+class TestTeamMembershipsApi(unittest.TestCase):
+    """TeamMembershipsApi unit test stubs"""
 
     def setUp(self):
-        self.api = PortfolioMembershipsApi()  # noqa: E501
+        self.api = TeamMembershipsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def test_get_portfolio_membership(self):
-        """Test case for get_portfolio_membership
+    def test_get_team_membership(self):
+        """Test case for get_team_membership
 
-        Get a portfolio membership  # noqa: E501
+        Get a team membership  # noqa: E501
         """
         pass
 
-    def test_get_portfolio_memberships(self):
-        """Test case for get_portfolio_memberships
+    def test_get_team_memberships(self):
+        """Test case for get_team_memberships
 
-        Get multiple portfolio memberships  # noqa: E501
+        Get team memberships  # noqa: E501
         """
         pass
 
-    def test_get_portfolio_memberships_for_portfolio(self):
-        """Test case for get_portfolio_memberships_for_portfolio
+    def test_get_team_memberships_for_team(self):
+        """Test case for get_team_memberships_for_team
 
-        Get memberships from a portfolio  # noqa: E501
+        Get memberships from a team  # noqa: E501
+        """
+        pass
+
+    def test_get_team_memberships_for_user(self):
+        """Test case for get_team_memberships_for_user
+
+        Get memberships from a user  # noqa: E501
         """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_portfolio_response_workspace.py` & `asana_preview-1.2.40/test/test_time_tracking_entries_api.py`

 * *Files 27% similar despite different names*

```diff
@@ -11,29 +11,58 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.portfolio_response_workspace import PortfolioResponseWorkspace  # noqa: E501
+from asana_preview.api.time_tracking_entries_api import TimeTrackingEntriesApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestPortfolioResponseWorkspace(unittest.TestCase):
-    """PortfolioResponseWorkspace unit test stubs"""
+class TestTimeTrackingEntriesApi(unittest.TestCase):
+    """TimeTrackingEntriesApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = TimeTrackingEntriesApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testPortfolioResponseWorkspace(self):
-        """Test PortfolioResponseWorkspace"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.portfolio_response_workspace.PortfolioResponseWorkspace()  # noqa: E501
+    def test_create_time_tracking_entry(self):
+        """Test case for create_time_tracking_entry
+
+        Create a time tracking entry  # noqa: E501
+        """
+        pass
+
+    def test_delete_time_tracking_entry(self):
+        """Test case for delete_time_tracking_entry
+
+        Delete a time tracking entry  # noqa: E501
+        """
+        pass
+
+    def test_get_time_tracking_entries_for_task(self):
+        """Test case for get_time_tracking_entries_for_task
+
+        Get time tracking entries for a task  # noqa: E501
+        """
+        pass
+
+    def test_get_time_tracking_entry(self):
+        """Test case for get_time_tracking_entry
+
+        Get a time tracking entry  # noqa: E501
+        """
+        pass
+
+    def test_update_time_tracking_entry(self):
+        """Test case for update_time_tracking_entry
+
+        Update a time tracking entry  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_portfolios_api.py` & `asana_preview-1.2.40/test/test_portfolios_api.py`

 * *Files identical despite different names*

### Comparing `asana_preview-1.0.9/test/test_project_brief_response_project.py` & `asana_preview-1.2.40/test/test_project_statuses_api.py`

 * *Files 27% similar despite different names*

```diff
@@ -11,29 +11,51 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.project_brief_response_project import ProjectBriefResponseProject  # noqa: E501
+from asana_preview.api.project_statuses_api import ProjectStatusesApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestProjectBriefResponseProject(unittest.TestCase):
-    """ProjectBriefResponseProject unit test stubs"""
+class TestProjectStatusesApi(unittest.TestCase):
+    """ProjectStatusesApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = ProjectStatusesApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testProjectBriefResponseProject(self):
-        """Test ProjectBriefResponseProject"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.project_brief_response_project.ProjectBriefResponseProject()  # noqa: E501
+    def test_create_project_status_for_project(self):
+        """Test case for create_project_status_for_project
+
+        Create a project status  # noqa: E501
+        """
+        pass
+
+    def test_delete_project_status(self):
+        """Test case for delete_project_status
+
+        Delete a project status  # noqa: E501
+        """
+        pass
+
+    def test_get_project_status(self):
+        """Test case for get_project_status
+
+        Get a project status  # noqa: E501
+        """
+        pass
+
+    def test_get_project_statuses_for_project(self):
+        """Test case for get_project_statuses_for_project
+
+        Get statuses from a project  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_project_briefs_api.py` & `asana_preview-1.2.40/test/test_project_briefs_api.py`

 * *Files identical despite different names*

### Comparing `asana_preview-1.0.9/test/test_project_request.py` & `asana_preview-1.2.40/test/test_project_templates_api.py`

 * *Files 25% similar despite different names*

```diff
@@ -11,29 +11,58 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.models.project_request import ProjectRequest  # noqa: E501
+from asana_preview.api.project_templates_api import ProjectTemplatesApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestProjectRequest(unittest.TestCase):
-    """ProjectRequest unit test stubs"""
+class TestProjectTemplatesApi(unittest.TestCase):
+    """ProjectTemplatesApi unit test stubs"""
 
     def setUp(self):
-        pass
+        self.api = ProjectTemplatesApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def testProjectRequest(self):
-        """Test ProjectRequest"""
-        # FIXME: construct object with mandatory attributes with example values
-        # model = asana_preview.models.project_request.ProjectRequest()  # noqa: E501
+    def test_delete_project_template(self):
+        """Test case for delete_project_template
+
+        Delete a project template  # noqa: E501
+        """
+        pass
+
+    def test_get_project_template(self):
+        """Test case for get_project_template
+
+        Get a project template  # noqa: E501
+        """
+        pass
+
+    def test_get_project_templates(self):
+        """Test case for get_project_templates
+
+        Get multiple project templates  # noqa: E501
+        """
+        pass
+
+    def test_get_project_templates_for_team(self):
+        """Test case for get_project_templates_for_team
+
+        Get a team's project templates  # noqa: E501
+        """
+        pass
+
+    def test_instantiate_project(self):
+        """Test case for instantiate_project
+
+        Instantiate a project from a project template  # noqa: E501
+        """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_project_templates_api.py` & `asana_preview-1.2.40/test/test_sections_api.py`

 * *Files 27% similar despite different names*

```diff
@@ -11,58 +11,72 @@
 """
 
 from __future__ import absolute_import
 
 import unittest
 
 import asana_preview
-from asana_preview.api.project_templates_api import ProjectTemplatesApi  # noqa: E501
+from asana_preview.api.sections_api import SectionsApi  # noqa: E501
 from asana_preview.rest import ApiException
 
 
-class TestProjectTemplatesApi(unittest.TestCase):
-    """ProjectTemplatesApi unit test stubs"""
+class TestSectionsApi(unittest.TestCase):
+    """SectionsApi unit test stubs"""
 
     def setUp(self):
-        self.api = ProjectTemplatesApi()  # noqa: E501
+        self.api = SectionsApi()  # noqa: E501
 
     def tearDown(self):
         pass
 
-    def test_delete_project_template(self):
-        """Test case for delete_project_template
+    def test_add_task_for_section(self):
+        """Test case for add_task_for_section
 
-        Delete a project template  # noqa: E501
+        Add task to section  # noqa: E501
         """
         pass
 
-    def test_get_project_template(self):
-        """Test case for get_project_template
+    def test_create_section_for_project(self):
+        """Test case for create_section_for_project
 
-        Get a project template  # noqa: E501
+        Create a section in a project  # noqa: E501
         """
         pass
 
-    def test_get_project_templates(self):
-        """Test case for get_project_templates
+    def test_delete_section(self):
+        """Test case for delete_section
 
-        Get multiple project templates  # noqa: E501
+        Delete a section  # noqa: E501
         """
         pass
 
-    def test_get_project_templates_for_team(self):
-        """Test case for get_project_templates_for_team
+    def test_get_section(self):
+        """Test case for get_section
 
-        Get a team's project templates  # noqa: E501
+        Get a section  # noqa: E501
         """
         pass
 
-    def test_instantiate_project(self):
-        """Test case for instantiate_project
+    def test_get_sections_for_project(self):
+        """Test case for get_sections_for_project
 
-        Instantiate a project from a project template  # noqa: E501
+        Get sections in a project  # noqa: E501
+        """
+        pass
+
+    def test_insert_section_for_project(self):
+        """Test case for insert_section_for_project
+
+        Move or Insert sections  # noqa: E501
+        """
+        pass
+
+    def test_update_section(self):
+        """Test case for update_section
+
+        Update a section  # noqa: E501
         """
         pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `asana_preview-1.0.9/test/test_projects_api.py` & `asana_preview-1.2.40/test/test_projects_api.py`

 * *Files identical despite different names*

### Comparing `asana_preview-1.0.9/test/test_tags_api.py` & `asana_preview-1.2.40/test/test_tags_api.py`

 * *Files identical despite different names*

### Comparing `asana_preview-1.0.9/test/test_tasks_api.py` & `asana_preview-1.2.40/test/test_tasks_api.py`

 * *Files identical despite different names*

### Comparing `asana_preview-1.0.9/test/test_workspaces_api.py` & `asana_preview-1.2.40/test/test_workspaces_api.py`

 * *Files identical despite different names*

