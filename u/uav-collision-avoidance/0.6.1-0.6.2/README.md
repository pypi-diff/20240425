# Comparing `tmp/uav_collision_avoidance-0.6.1-py3-none-any.whl.zip` & `tmp/uav_collision_avoidance-0.6.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,38 @@
-Zip file size: 107403 bytes, number of entries: 81
+Zip file size: 129761 bytes, number of entries: 96
+-rw-r--r--  2.0 unx      107 b- defN 24-Apr-16 08:15 build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
+-rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
+-rw-r--r--  2.0 unx     2203 b- defN 24-Apr-15 19:36 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+-rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
+-rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
+-rw-r--r--  2.0 unx     9540 b- defN 24-Apr-11 18:19 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
+-rw-r--r--  2.0 unx     8671 b- defN 24-Apr-16 07:07 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx     6057 b- defN 24-Apr-11 11:29 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
+-rw-r--r--  2.0 unx     7112 b- defN 24-Apr-11 19:12 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+-rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
+-rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
+-rw-r--r--  2.0 unx     6110 b- defN 24-Apr-11 12:04 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
+-rw-r--r--  2.0 unx    23164 b- defN 24-Apr-11 12:26 build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-16 08:15 build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
 -rw-r--r--  2.0 unx     2203 b- defN 24-Apr-15 19:36 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx     9540 b- defN 24-Apr-11 18:19 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx    11332 b- defN 24-Apr-22 13:54 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx     8671 b- defN 24-Apr-16 07:07 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx     6057 b- defN 24-Apr-11 11:29 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     9028 b- defN 24-Apr-20 15:08 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx     7108 b- defN 24-Apr-22 12:03 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
--rw-r--r--  2.0 unx     7112 b- defN 24-Apr-11 19:12 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+-rw-r--r--  2.0 unx     6613 b- defN 24-Apr-21 14:26 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
--rw-r--r--  2.0 unx     6110 b- defN 24-Apr-11 12:04 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
--rw-r--r--  2.0 unx    23164 b- defN 24-Apr-11 12:26 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
+-rw-r--r--  2.0 unx     6290 b- defN 24-Apr-20 15:07 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
+-rw-r--r--  2.0 unx    23168 b- defN 24-Apr-18 21:19 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-16 08:15 build/lib/build/lib/build/lib/tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
 -rw-r--r--  2.0 unx     2203 b- defN 24-Apr-15 19:36 build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
 -rw-r--r--  2.0 unx    11332 b- defN 24-Apr-22 13:54 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
@@ -60,24 +75,24 @@
 -rw-r--r--  2.0 unx     6290 b- defN 24-Apr-20 15:07 build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
 -rw-r--r--  2.0 unx    23168 b- defN 24-Apr-18 21:19 build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
 -rw-r--r--  2.0 unx      107 b- defN 24-Apr-16 08:15 tests/test_sample.py
 -rw-r--r--  2.0 unx      121 b- defN 24-Mar-28 17:13 uav_collision_avoidance/__init__.py
 -rw-r--r--  2.0 unx     2203 b- defN 24-Apr-15 19:36 uav_collision_avoidance/main.py
 -rw-r--r--  2.0 unx      238 b- defN 24-Apr-22 14:13 uav_collision_avoidance/version.py
 -rw-r--r--  2.0 unx     1662 b- defN 24-Mar-28 17:17 uav_collision_avoidance/src/aircraft/aircraft.py
--rw-r--r--  2.0 unx    11332 b- defN 24-Apr-22 13:54 uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+-rw-r--r--  2.0 unx    13017 b- defN 24-Apr-24 17:23 uav_collision_avoidance/src/aircraft/aircraft_fcc.py
 -rw-r--r--  2.0 unx     4195 b- defN 24-Apr-05 07:31 uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
--rw-r--r--  2.0 unx     9028 b- defN 24-Apr-20 15:08 uav_collision_avoidance/src/simulation/simulation.py
--rw-r--r--  2.0 unx     7108 b- defN 24-Apr-22 12:03 uav_collision_avoidance/src/simulation/simulation_adsb.py
+-rw-r--r--  2.0 unx     9630 b- defN 24-Apr-24 17:35 uav_collision_avoidance/src/simulation/simulation.py
+-rw-r--r--  2.0 unx     7072 b- defN 24-Apr-24 14:39 uav_collision_avoidance/src/simulation/simulation_adsb.py
 -rw-r--r--  2.0 unx     1979 b- defN 24-Mar-28 17:20 uav_collision_avoidance/src/simulation/simulation_fps.py
--rw-r--r--  2.0 unx     6613 b- defN 24-Apr-21 14:26 uav_collision_avoidance/src/simulation/simulation_physics.py
+-rw-r--r--  2.0 unx     6613 b- defN 24-Apr-24 14:18 uav_collision_avoidance/src/simulation/simulation_physics.py
 -rw-r--r--  2.0 unx     1041 b- defN 24-Mar-28 17:20 uav_collision_avoidance/src/simulation/simulation_render.py
 -rw-r--r--  2.0 unx      682 b- defN 24-Apr-06 09:52 uav_collision_avoidance/src/simulation/simulation_settings.py
--rw-r--r--  2.0 unx     6290 b- defN 24-Apr-20 15:07 uav_collision_avoidance/src/simulation/simulation_state.py
--rw-r--r--  2.0 unx    23168 b- defN 24-Apr-18 21:19 uav_collision_avoidance/src/simulation/simulation_widget.py
--rw-r--r--  2.0 unx     1075 b- defN 24-Apr-22 14:19 uav_collision_avoidance-0.6.1.dist-info/LICENSE
--rw-r--r--  2.0 unx     6409 b- defN 24-Apr-22 14:19 uav_collision_avoidance-0.6.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-22 14:19 uav_collision_avoidance-0.6.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       73 b- defN 24-Apr-22 14:19 uav_collision_avoidance-0.6.1.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       58 b- defN 24-Apr-22 14:19 uav_collision_avoidance-0.6.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    10031 b- defN 24-Apr-22 14:19 uav_collision_avoidance-0.6.1.dist-info/RECORD
-81 files, 393688 bytes uncompressed, 90255 bytes compressed:  77.1%
+-rw-r--r--  2.0 unx     6290 b- defN 24-Apr-24 14:18 uav_collision_avoidance/src/simulation/simulation_state.py
+-rw-r--r--  2.0 unx    25822 b- defN 24-Apr-24 16:52 uav_collision_avoidance/src/simulation/simulation_widget.py
+-rw-r--r--  2.0 unx     1075 b- defN 24-Apr-24 17:40 uav_collision_avoidance-0.6.2.dist-info/LICENSE
+-rw-r--r--  2.0 unx     7068 b- defN 24-Apr-24 17:40 uav_collision_avoidance-0.6.2.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-24 17:40 uav_collision_avoidance-0.6.2.dist-info/WHEEL
+-rw-r--r--  2.0 unx       73 b- defN 24-Apr-24 17:40 uav_collision_avoidance-0.6.2.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       58 b- defN 24-Apr-24 17:40 uav_collision_avoidance-0.6.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    12372 b- defN 24-Apr-24 17:40 uav_collision_avoidance-0.6.2.dist-info/RECORD
+96 files, 477360 bytes uncompressed, 108497 bytes compressed:  77.3%
```

## zipnote {}

```diff
@@ -1,7 +1,52 @@
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py
+Comment: 
+
+Filename: build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py
+Comment: 
+
 Filename: build/lib/build/lib/build/lib/build/lib/tests/test_sample.py
 Comment: 
 
 Filename: build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py
 Comment: 
 
 Filename: build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py
@@ -219,26 +264,26 @@
 
 Filename: uav_collision_avoidance/src/simulation/simulation_state.py
 Comment: 
 
 Filename: uav_collision_avoidance/src/simulation/simulation_widget.py
 Comment: 
 
-Filename: uav_collision_avoidance-0.6.1.dist-info/LICENSE
+Filename: uav_collision_avoidance-0.6.2.dist-info/LICENSE
 Comment: 
 
-Filename: uav_collision_avoidance-0.6.1.dist-info/METADATA
+Filename: uav_collision_avoidance-0.6.2.dist-info/METADATA
 Comment: 
 
-Filename: uav_collision_avoidance-0.6.1.dist-info/WHEEL
+Filename: uav_collision_avoidance-0.6.2.dist-info/WHEEL
 Comment: 
 
-Filename: uav_collision_avoidance-0.6.1.dist-info/entry_points.txt
+Filename: uav_collision_avoidance-0.6.2.dist-info/entry_points.txt
 Comment: 
 
-Filename: uav_collision_avoidance-0.6.1.dist-info/top_level.txt
+Filename: uav_collision_avoidance-0.6.2.dist-info/top_level.txt
 Comment: 
 
-Filename: uav_collision_avoidance-0.6.1.dist-info/RECORD
+Filename: uav_collision_avoidance-0.6.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py

```diff
@@ -27,14 +27,16 @@
             self.target_yaw_angle : float = self.find_best_yaw_angle(aircraft.position, initial_target)
             self.add_first_destination(initial_target)
 
         self.initial_course : float = copy(self.target_yaw_angle)
         self.target_roll_angle : float = 0.0
         self.target_pitch_angle : float = 0.0
         self.__target_speed : float = self.aircraft.absolute_speed
+        self.__is_turning_right : bool = False
+        self.__is_turning_left : bool = False
 
         self.__evade_maneuver : bool = False
         self.vector_sharing_resolution : QVector3D | None = None
 
         self.destinations_history : List[QVector3D] = []
         self.visited : List[QVector3D] = []
     
@@ -44,37 +46,63 @@
         return self.__target_speed
     
     @target_speed.setter
     def target_speed(self, speed : float) -> None:
         """Sets target speed"""
         if speed > 0:
             self.__target_speed = speed
+    
+    @property
+    def is_turning_right(self) -> bool:
+        """Returns turning right state"""
+        return self.__is_turning_right
+    
+    @is_turning_right.setter
+    def is_turning_right(self, value : bool) -> None:
+        """Sets turning right state"""
+        self.__is_turning_right = value
+
+    @property
+    def is_turning_left(self) -> bool:
+        """Returns turning left state"""
+        return self.__is_turning_left
+    
+    @is_turning_left.setter
+    def is_turning_left(self, value : bool) -> None:
+        """Sets turning left state"""
+        self.__is_turning_left = value
 
     def add_last_destination(self, destination : QVector3D) -> None:
-        """Appends given location to the end of destinations list"""
-        assert isinstance(destination.x(), (int, float))
-        assert isinstance(destination.y(), (int, float))
-        assert isinstance(destination.z(), (int, float))
+        """Appends the given location (QVector3D) to the end of the destinations list."""
+        if not all(isinstance(coord, (int, float)) for coord in (destination.x(), destination.y(), destination.z())):
+            raise TypeError("Destination coordinates must be int or float.")
 
         self.destinations.append(destination)
 
     def add_first_destination(self, destination : QVector3D) -> None:
         """Pushes given location to the top of destinations list"""
-        assert isinstance(destination.x(), (int, float))
-        assert isinstance(destination.y(), (int, float))
-        assert isinstance(destination.z(), (int, float))
+        if not all(isinstance(coord, (int, float)) for coord in (destination.x(), destination.y(), destination.z())):
+            raise TypeError("Destination coordinates must be int or float.")
 
-        if len(self.destinations) > 0 and dist(destination.toTuple(), self.destinations[0].toTuple()) < 1:
+        if len(self.destinations) > 0 and dist(destination.toTuple(), self.destinations[0].toTuple()) < 1.0:
             print("Attempted to stack same destination")
-            logging.warning("Attempted to stack same destination")
+            logging.warning(f"Attempted to stack same destination: {destination}")
             return
 
         self.destinations.appendleft(destination)
         logging.info("Aircraft %s added new first destination: %s", self.aircraft.aircraft_id, destination.toTuple())
 
+    @property
+    def destination(self) -> QVector3D | None:
+        """Returns current destination"""
+        if len(self.destinations) > 0:
+            return self.destinations[0]
+        else:
+            return None
+
     def append_visited(self) -> None:
         """Appends current location to visited list"""
         self.visited.append(copy(self.aircraft.position))
 
     def normalize_angle(self, angle : float) -> float:
         """Normalizes -180-180 angle into 360 domain"""
         angle = angle % 360
@@ -121,19 +149,46 @@
     def reset_evade_maneuver(self) -> None:
         """Resets evade maneuver"""
         if self.__evade_maneuver:
             logging.info("Aircraft %s reset evade maneuver", self.aircraft.aircraft_id)
             self.__evade_maneuver = False
             #self.vector_sharing_resolution = None
 
-    def find_best_roll_angle(self, current_yaw_angle : float, target_yaw_angle : float) -> float:
+    def find_best_roll_angle(self, current_yaw_angle: float, target_yaw_angle: float) -> float:
         """Finds best roll angle for the targeted yaw angle"""
         difference = (target_yaw_angle - current_yaw_angle + 180) % 360 - 180
-        return 0.0 if abs(difference) < 0.01 else 30.0 if difference > 0 else -30.0
-
+        if abs(difference) < 0.001:
+            self.is_turning_right = False
+            self.is_turning_left = False
+            return 0.0
+        elif difference > 0:
+            self.is_turning_right = True
+            self.is_turning_left = False
+            if difference > 90:
+                return 30.0
+            elif difference > 45:
+                return 20.0
+            elif difference > 20:
+                return 10.0
+            else:
+                return 5.0
+        elif difference < 0:
+            self.is_turning_left = True
+            self.is_turning_right = False
+            if difference < -90:
+                return -30.0
+            elif difference < -45:
+                return -20.0
+            elif difference < -20:
+                return -10.0
+            else:
+                return -5.0
+        else:
+            return 0.0
+        
     def find_best_yaw_angle(self, position : QVector3D, destination : QVector3D) -> float:
         """Finds best yaw angle for the given destination"""
         target_yaw_angle : float  = degrees(atan2(
             destination.y() - position.y(),
             destination.x() - position.x()))
         target_yaw_angle += 90
         return self.format_angle(target_yaw_angle)
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -23,38 +23,46 @@
 class Simulation(QMainWindow):
     """Main simulation App"""
 
     def __init__(self, aircrafts : List[Aircraft] | None = None, simulation_time : int = 100_000) -> None:
         super().__init__()
         SimulationSettings().__init__()
         if aircrafts is None:
-            self.aircrafts : List[Aircraft] = [
-                Aircraft( # detection test
-                    position = QVector3D(100, 1000, 1000),
-                    speed = QVector3D(50, -50, 0),
-                    initial_target = QVector3D(1_000_100, -1_001_000, 1000)),
-                Aircraft(
-                    position = QVector3D(900, 1300, 1000),
-                    speed = QVector3D(0, -70, 0),
-                    initial_target = QVector3D(900, -1_001_300, 1000)),
-                # Aircraft( # head on
-                #     position = QVector3D(100, 500, 1000),
-                #     speed = QVector3D(70, 0, 0)),
-                # Aircraft(
-                #     position = QVector3D(900, 500, 1000),
-                #     speed = QVector3D(-50, 0, 0)),
-                # Aircraft( # avoidance test
-                #     position = QVector3D(10, -10, 0),
-                #     speed = QVector3D(300, -300, 0),
-                #     initial_target = QVector3D(75000, -75000, 0)), # 75 km, -75 km
-                # Aircraft(
-                #     position = QVector3D(0, -100_000, 0),
-                #     speed = QVector3D(300, 290, 0),
-                #     initial_target = QVector3D(75000, -27500, 0)), # 75 km, -27.5 km
-            ]
+            test_case : int = 0
+            if test_case == 0:
+                self.aircrafts : List[Aircraft] = [
+                    Aircraft( # detection test
+                        position = QVector3D(-800, 4000, 1000),
+                        speed = QVector3D(60, -60, 0),
+                        initial_target = QVector3D(1_000_100, -1_001_000, 1000)),
+                    Aircraft(
+                        position = QVector3D(4000, 6000, 1000),
+                        speed = QVector3D(0, -85, 0),
+                        initial_target = QVector3D(900, -1_001_300, 1000)),
+                ]
+            elif test_case == 1:
+                self.aircrafts : List[Aircraft] = [
+                    Aircraft( # almost head on
+                        position = QVector3D(-3000, 500, 1000),
+                        speed = QVector3D(70, 0.1, 0)),
+                    Aircraft(
+                        position = QVector3D(5000, 500, 1000),
+                        speed = QVector3D(-50, 0, 0)),
+                ]
+            elif test_case == 2:
+                self.aircrafts : List[Aircraft] = [
+                    Aircraft( # avoidance test
+                        position = QVector3D(10, -10, 1000),
+                        speed = QVector3D(300, -300, 0),
+                        initial_target = QVector3D(75000, -75000, 0)), # 75 km, -75 km
+                    Aircraft(
+                        position = QVector3D(0, -100_000, 1000),
+                        speed = QVector3D(300, 290, 0),
+                        initial_target = QVector3D(75000, -27500, 0)), # 75 km, -27.5 km
+                ]
         else:
             self.aircrafts = aircrafts
         self.simulation_time : int = simulation_time
         self.state : SimulationState | None = None
 
     def run_realtime(self) -> None:
         """Executes realtime simulation"""
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py

```diff
@@ -40,14 +40,22 @@
             self.adsb_cycles += 1
             self.simulation_state.update_adsb_settings()
 
             relative_position = aircraft_vehicle_1.position - aircraft_vehicle_2.position
             speed_difference = aircraft_vehicle_1.speed - aircraft_vehicle_2.speed
             time_to_closest_approach = -(QVector3D.dotProduct(relative_position, speed_difference) / QVector3D.dotProduct(speed_difference, speed_difference))
             print("Time to closest approach: " + "{:.2f}".format(time_to_closest_approach) + "s")
+            
+            for aircraft in self.aircraft_vehicles:
+                # path
+                self.aircraft_fccs[aircraft.aircraft_id].append_visited()
+
+                # console output
+                if self.simulation_state.adsb_report and aircraft.aircraft_id == 0:
+                    self.print_adsb_report(aircraft)
 
             if not self.simulation_state.avoid_collisions:
                 return
 
             if time_to_closest_approach > 0:
                 # miss distance at closest approach
                 speed_difference_unit = speed_difference.normalized()
@@ -81,31 +89,43 @@
                 if collision_region > 0:
                     print("Collision detected")
             else:
                 for aircraft in self.aircraft_fccs:
                     if aircraft.evade_maneuver:
                         aircraft.reset_evade_maneuver()
 
-            for aircraft in self.aircraft_vehicles:
-                # path
-                self.aircraft_fccs[aircraft.aircraft_id].append_visited()
-
-                # console output
-                if self.simulation_state.adsb_report and aircraft.aircraft_id == 0:
-                    self.print_adsb_report(aircraft)
-
     def print_adsb_report(self, aircraft : AircraftVehicle) -> None:
         """Prints ADS-B report for the aircraft to the console"""
-        print("Aircraft id: " + str(aircraft.aircraft_id) +
+        fcc = self.aircraft_fccs[aircraft.aircraft_id]
+        turning_direction = "Not turning"
+        if fcc.is_turning_left:
+            turning_direction = "Turning left"
+        elif fcc.is_turning_right:
+            turning_direction = "Turning right"
+        print("- Aircraft id: " + str(aircraft.aircraft_id) +
             "; speed: " + "{:.2f}".format(aircraft.absolute_speed) +
-            "; target speed: " + "{:.2f}".format(self.aircraft_fccs[aircraft.aircraft_id].target_speed) +
+            "; turning: " + turning_direction +
+            "; roll angle: " + "{:.2f}".format(aircraft.roll_angle) +
+            "; target roll angle: " + "{:.2f}".format(fcc.target_roll_angle) +
+            "; yaw angle: " + "{:.2f}".format(aircraft.yaw_angle) +
+            "; target yaw angle: " + "{:.2f}".format(fcc.target_yaw_angle) +
             "; x: " + "{:.2f}".format(aircraft.position.x()) +
             "; y: " + "{:.2f}".format(aircraft.position.y()) +
-            "; yaw angle: " + "{:.2f}".format(aircraft.yaw_angle) +
-            "; target yaw angle: " + "{:.2f}".format(self.aircraft_fccs[aircraft.aircraft_id].target_yaw_angle) +
-            "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
-            "; roll angle: " + "{:.2f}".format(aircraft.roll_angle) +
-            "; target roll angle: " + "{:.2f}".format(self.aircraft_fccs[aircraft.aircraft_id].target_roll_angle) +
-            "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
-            "; fps: " + "{:.2f}".format(self.simulation_state.fps) +
-            "; t: " + str(self.adsb_cycles) +
-            "; phys: " + str(self.simulation_state.physics_cycles))
+            "; z: " + "{:.2f}".format(aircraft.position.z()))
+        if fcc.destination is not None:
+            print("target pitch angle: " + "{:.2f}".format(fcc.target_pitch_angle) +
+                "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
+                "; dest x: " + "{:.2f}".format(fcc.destination.x()) +
+                "; dest y: " + "{:.2f}".format(fcc.destination.y()) +
+                "; dest z: " + "{:.2f}".format(fcc.destination.z()) +
+                "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
+                "; fps: " + "{:.2f}".format(self.simulation_state.fps) +
+                "; t: " + str(self.adsb_cycles) +
+                "; phys: " + str(self.simulation_state.physics_cycles))
+        else:
+            print("target pitch angle: " + "{:.2f}".format(fcc.target_pitch_angle) +
+                "; pitch angle: " + "{:.2f}".format(aircraft.pitch_angle) +
+                "; distance covered: " + "{:.2f}".format(aircraft.distance_covered) +
+                "; fps: " + "{:.2f}".format(self.simulation_state.fps) +
+                "; t: " + str(self.adsb_cycles) +
+                "; phys: " + str(self.simulation_state.physics_cycles) +
+                "; no destination")
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py

```diff
@@ -117,34 +117,24 @@
             # pitch angle
 
             # yaw angle
             roll_angle : float = aircraft.roll_angle
 
             if roll_angle == 0.0:
                 continue
-            elif fcc.target_roll_angle > 0.0 and roll_angle < 0.0:
-                continue
-            elif fcc.target_roll_angle < 0.0 and roll_angle > 0.0:
-                continue
 
             current_yaw_angle : float = aircraft.yaw_angle
             target_yaw_angle : float = fcc.target_yaw_angle
             if abs(current_yaw_angle - target_yaw_angle) < 0.001:
                 continue
             current_horizontal_speed : float = aircraft.horizontal_speed
-            max_delta_yaw_angle : float = self.simulation_state.g_acceleration * tan(radians(roll_angle)) / (current_horizontal_speed / elapsed_time)
-            max_delta_yaw_angle = abs(max_delta_yaw_angle)
-            if roll_angle < 0.0:
-                max_delta_yaw_angle = -max_delta_yaw_angle
+            delta_yaw_angle : float = self.simulation_state.g_acceleration * tan(radians(roll_angle)) / (current_horizontal_speed / elapsed_time)
 
             new_yaw_angle : float = 0.0
-            if abs(current_yaw_angle - target_yaw_angle) < abs(max_delta_yaw_angle):
-                new_yaw_angle = target_yaw_angle
-            else:
-                new_yaw_angle = current_yaw_angle + max_delta_yaw_angle
+            new_yaw_angle = current_yaw_angle + delta_yaw_angle
 
             aircraft.speed.setX(sin(radians(new_yaw_angle)) * current_horizontal_speed)
             aircraft.speed.setY(-cos(radians(new_yaw_angle)) * current_horizontal_speed)
 
     def count_cycles(self) -> None:
         """Increments physics cycle counter"""
         self.cycles += 1
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py

```diff
@@ -23,28 +23,32 @@
         self.minimum_separation : float = 9260.0 # 5nmi
         self.physics_cycles : int = 0
         self.is_paused : bool = False
         self.is_running : bool = True
         self.__reset_demanded : bool = False
         self.pause_start_timestamp : QTime | None = None
         self.time_paused : int = 0 # ms
-        self.__adsb_report : bool = False
+        self.__adsb_report : bool = True
         self.__collision : bool = False
         self.__first_cause_collision : bool = False
         self.__second_cause_collision : bool = False
 
         if is_realtime:
             # render state
-            self.__gui_scale : float = 1.0 # define gui scaling
-            if SimulationSettings.screen_resolution.height() < 1440:
-                self.gui_scale = 0.75
-            elif SimulationSettings.screen_resolution.height() < 1080:
-                self.gui_scale = 0.5
-            elif SimulationSettings.screen_resolution.height() < 480:
-                self.gui_scale = 0.25
+            override_gui_scale : bool = True
+            if not override_gui_scale:
+                self.__gui_scale : float = 0.5 # define gui scaling
+                if SimulationSettings.screen_resolution.height() < 1440:
+                    self.gui_scale = 0.375
+                elif SimulationSettings.screen_resolution.height() < 1080:
+                    self.gui_scale = 0.25
+                elif SimulationSettings.screen_resolution.height() < 480:
+                    self.gui_scale = 0.125
+            else:
+                self.__gui_scale : float = 0.75
             self.fps : float = 0.0
             self.draw_fps : bool = True
             self.draw_aircraft : bool = True
             self.draw_grid : bool = False
             self.draw_path : bool = True
             self.draw_speed_vectors : bool = True
             self.draw_collision_detection : bool = True
```

## build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py

```diff
@@ -396,17 +396,17 @@
                 return super().keyPressEvent(event)
             self.simulation_state.toggle_pause()
         elif event.key() == Qt.Key.Key_R:
             if event.isAutoRepeat():
                 return super().keyPressEvent(event)
             self.simulation_state.reset()
         elif event.key() == Qt.Key.Key_Plus:
-            self.zoom(0.25)
+            self.zoom(0.0625)
         elif event.key() == Qt.Key.Key_Minus:
-            self.zoom(-0.25)
+            self.zoom(-0.0625)
         elif event.key() == Qt.Key.Key_F1:
             self.simulation_state.toggle_adsb_report()
         elif event.key() == Qt.Key.Key_F2:
             self.aircraft_fccs[0].target_speed -= 10.0
         elif event.key() == Qt.Key.Key_F3:
             self.aircraft_fccs[0].target_speed += 10.0
         elif event.key() == Qt.Key.Key_O:
```

## uav_collision_avoidance/src/aircraft/aircraft_fcc.py

```diff
@@ -29,14 +29,15 @@
 
         self.initial_course : float = copy(self.target_yaw_angle)
         self.target_roll_angle : float = 0.0
         self.target_pitch_angle : float = 0.0
         self.__target_speed : float = self.aircraft.absolute_speed
         self.__is_turning_right : bool = False
         self.__is_turning_left : bool = False
+        self.ignore_destinations : bool = False
 
         self.__evade_maneuver : bool = False
         self.vector_sharing_resolution : QVector3D | None = None
 
         self.destinations_history : List[QVector3D] = []
         self.visited : List[QVector3D] = []
     
@@ -120,34 +121,49 @@
 
     def apply_evade_maneuver(self, opponent_speed : QVector3D, miss_distance_vector : QVector3D, unresolved_region : float, time_to_closest_approach : float) -> None:
         """Applies evade maneuver"""
         print(str(self.aircraft.aircraft_id) + ": opponent speed: " + "{:.2f}".format(opponent_speed.x()) + " " + "{:.2f}".format(opponent_speed.y()) + " " + "{:.2f}".format(opponent_speed.z()))
         print(str(self.aircraft.aircraft_id) + ": miss distance vector: " + "{:.2f}".format(miss_distance_vector.x()) + " " + "{:.2f}".format(miss_distance_vector.y()) + " " + "{:.2f}".format(miss_distance_vector.z()))
         print(str(self.aircraft.aircraft_id) + ": unresolved region: " + "{:.2f}".format(unresolved_region))
         print(str(self.aircraft.aircraft_id) + ": time to closest approach: " + "{:.2f}".format(time_to_closest_approach))
-        
-        if (miss_distance_vector.x() == 0 and miss_distance_vector.y() == 0 and miss_distance_vector.z() == 0):
-            return
 
         if self.__evade_maneuver:
             logging.warning("Another evade maneuver in progress")
         else:
             print(f"Aircraft {self.aircraft.aircraft_id} applying evade maneuver")
             logging.info("Aircraft %s applying evade maneuver", self.aircraft.aircraft_id)
             self.__evade_maneuver = True
-            self.vector_sharing_resolution : QVector3D | None = None
-            if self.aircraft_id == 0:
-                self.vector_sharing_resolution = (opponent_speed.length() * unresolved_region * -(miss_distance_vector)) / ((self.aircraft.speed.length() + opponent_speed.length()) * miss_distance_vector.length())
+
+            # this is temporal solution of the problem below
+            if miss_distance_vector.length() == 0:
+                miss_distance_vector = QVector3D(0.01, 0.01, 0.0)
+
+            target_avoiding : QVector3D = QVector3D()
+            if miss_distance_vector.length() == 0:
+                # todo: fix or just change height
+                # modified_speed_vector : QVector3D = self.aircraft.speed + 0.01 * (self.aircraft.speed.normalized().z() * self.aircraft.speed)
+                # modified_speed_vector : QVector3D = self.aircraft.speed + 0.01 * QVector3D.crossProduct(self.aircraft.speed.normalized(), self.aircraft.speed)
+                # modified_speed_vector : QVector3D = self.aircraft.speed + (QVector3D.crossProduct(QVector3D(0, 0, self.aircraft.speed.normalized().z()), self.aircraft.speed))
+                # print("Modified speed vector: " + "{:.2f}".format(modified_speed_vector.x()) + " " + "{:.2f}".format(modified_speed_vector.y()) + " " + "{:.2f}".format(modified_speed_vector.z()))
+                # unit_vector : QVector3D = modified_speed_vector.normalized()
+                # print("Unit vector: " + "{:.2f}".format(unit_vector.x()) + " " + "{:.2f}".format(unit_vector.y()) + " " + "{:.2f}".format(unit_vector.z()))
+                # target_avoiding = self.aircraft.position + (unit_vector * modified_speed_vector.length())
+                pass
             else:
-                self.vector_sharing_resolution = (opponent_speed.length() * unresolved_region * miss_distance_vector) / ((opponent_speed.length() + self.aircraft.speed.length()) * miss_distance_vector.length())
-            print("Vector sharing resolution: " + "{:.2f}".format(self.vector_sharing_resolution.x()) + " " + "{:.2f}".format(self.vector_sharing_resolution.y()) + " " + "{:.2f}".format(self.vector_sharing_resolution.z()))
+                self.vector_sharing_resolution : QVector3D | None = None
+                if self.aircraft_id == 0:
+                    self.vector_sharing_resolution = (opponent_speed.length() * unresolved_region * -(miss_distance_vector)) / ((self.aircraft.speed.length() + opponent_speed.length()) * miss_distance_vector.length())
+                elif self.aircraft_id == 1:
+                    self.vector_sharing_resolution = (opponent_speed.length() * unresolved_region * miss_distance_vector) / ((opponent_speed.length() + self.aircraft.speed.length()) * miss_distance_vector.length())
+                print("Vector sharing resolution: " + "{:.2f}".format(self.vector_sharing_resolution.x()) + " " + "{:.2f}".format(self.vector_sharing_resolution.y()) + " " + "{:.2f}".format(self.vector_sharing_resolution.z()))
+                modified_speed_vector : QVector3D = (self.aircraft.speed * time_to_closest_approach + self.vector_sharing_resolution)
+                unit_vector : QVector3D = modified_speed_vector.normalized()
+                target_avoiding = self.aircraft.position + (unit_vector * modified_speed_vector.length())
             
-            # self.vector_sharing_resolution *= 2
-
-            target_avoiding : QVector3D = self.aircraft.position + (self.aircraft.speed * time_to_closest_approach + self.vector_sharing_resolution)
+            print("Set target avoiding collision: " + "{:.2f}".format(target_avoiding.x()) + " " + "{:.2f}".format(target_avoiding.y()) + " " + "{:.2f}".format(target_avoiding.z()))
             self.add_first_destination(target_avoiding)
 
     def reset_evade_maneuver(self) -> None:
         """Resets evade maneuver"""
         if self.__evade_maneuver:
             logging.info("Aircraft %s reset evade maneuver", self.aircraft.aircraft_id)
             self.__evade_maneuver = False
@@ -191,15 +207,15 @@
             destination.y() - position.y(),
             destination.x() - position.x()))
         target_yaw_angle += 90
         return self.format_angle(target_yaw_angle)
 
     def update_target_yaw_angle(self) -> None:
         """Updates current yaw angle"""
-        if self.destinations:
+        if self.destinations and not self.ignore_destinations:
             destination = self.destinations[0]
             distance = dist(self.aircraft.position.toTuple(), destination.toTuple())
             if distance < self.aircraft.size / 2:
                 self.destinations_history.append(self.destinations.popleft())
                 if self.destinations:
                     destination = self.destinations[0]
                     logging.info("Aircraft %s visited destination and took next one", self.aircraft.aircraft_id)
```

## uav_collision_avoidance/src/simulation/simulation.py

```diff
@@ -23,15 +23,15 @@
 class Simulation(QMainWindow):
     """Main simulation App"""
 
     def __init__(self, aircrafts : List[Aircraft] | None = None, simulation_time : int = 100_000) -> None:
         super().__init__()
         SimulationSettings().__init__()
         if aircrafts is None:
-            test_case : int = 0
+            test_case : int = 3
             if test_case == 0:
                 self.aircrafts : List[Aircraft] = [
                     Aircraft( # detection test
                         position = QVector3D(-800, 4000, 1000),
                         speed = QVector3D(60, -60, 0),
                         initial_target = QVector3D(1_000_100, -1_001_000, 1000)),
                     Aircraft(
@@ -47,21 +47,32 @@
                     Aircraft(
                         position = QVector3D(5000, 500, 1000),
                         speed = QVector3D(-50, 0, 0)),
                 ]
             elif test_case == 2:
                 self.aircrafts : List[Aircraft] = [
                     Aircraft( # avoidance test
-                        position = QVector3D(10, -10, 1000),
+                        position = QVector3D(0, 0, 1000),
+                        speed = QVector3D(30, -30, 0),
+                        initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
+                    Aircraft(
+                        position = QVector3D(0, -100_000, 1000),
+                        speed = QVector3D(30, 29, 0),
+                        initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
+                ]
+            elif test_case == 3:
+                self.aircrafts : List[Aircraft] = [
+                    Aircraft( # avoidance test fast
+                        position = QVector3D(0, 0, 1000),
                         speed = QVector3D(300, -300, 0),
-                        initial_target = QVector3D(75000, -75000, 0)), # 75 km, -75 km
+                        initial_target = QVector3D(75000, -75000, 1000)), # 75 km, -75 km
                     Aircraft(
                         position = QVector3D(0, -100_000, 1000),
                         speed = QVector3D(300, 290, 0),
-                        initial_target = QVector3D(75000, -27500, 0)), # 75 km, -27.5 km
+                        initial_target = QVector3D(75000, -27500, 1000)), # 75 km, -27.5 km
                 ]
         else:
             self.aircrafts = aircrafts
         self.simulation_time : int = simulation_time
         self.state : SimulationState | None = None
 
     def run_realtime(self) -> None:
```

## uav_collision_avoidance/src/simulation/simulation_adsb.py

```diff
@@ -62,16 +62,15 @@
                 miss_distance_vector : QVector3D = QVector3D.crossProduct(
                     speed_difference_unit,
                     QVector3D.crossProduct(relative_position, speed_difference_unit))
                 print("Miss distance at closest approach: " + "{:.2f}".format(miss_distance_vector.length()) + "m")
 
                 if miss_distance_vector.length() == 0:
                     print("Head-on collision detected")
-                    # todo: height change maneuver
-                    # else other evade maneuver
+                    logging.info("Head-on collision detected")
 
                 # resolve confict condition
                 unresolved_region : float = self.simulation_state.minimum_separation - abs(miss_distance_vector.length())
                 if unresolved_region > 0.0:
                     print("Conflict condition detected")
                     for aircraft in self.aircraft_fccs:
                         if not aircraft.evade_maneuver:
```

## uav_collision_avoidance/src/simulation/simulation_widget.py

```diff
@@ -38,24 +38,42 @@
             SimulationSettings.screen_resolution.height() / 2 - self.window_height / 2 - 30,
             self.window_width,
             self.window_height)
         self.setStyleSheet("background-color: white;")
         self.setWindowTitle(QApplication.applicationName() + " " + QApplication.applicationVersion())
 
         self.icon = QIcon()
-        self.icon.addPixmap(self.simulation_state.aircraft_pixmap, QIcon.Mode.Normal, QIcon.State.Off)
+        self.icon.addPixmap(self.generate_icon(), QIcon.Mode.Normal, QIcon.State.Off)
         self.setWindowIcon(self.icon)
 
-        self.__moving_view_up = False
-        self.__moving_view_down = False
-        self.__moving_view_left = False
-        self.__moving_view_right = False
+        self.__moving_view_up : bool = False
+        self.__moving_view_down : bool = False
+        self.__moving_view_left : bool = False
+        self.__moving_view_right : bool = False
+        self.__steering_left : bool = False
+        self.__steering_right : bool = False
+        self.__steering_up : bool = False
+        self.__steering_down : bool = False
 
         self.center_offsets()
 
+    def generate_icon(self) -> QPixmap:
+        """Returns icon for the main window"""
+        pixmap = QPixmap(self.simulation_state.aircraft_pixmap)
+        painter = QPainter(pixmap)
+        painter.setBrush(QColor("white"))
+        painter.drawEllipse(self.simulation_state.aircraft_pixmap.rect())
+        painter.drawPixmap(
+            self.simulation_state.aircraft_pixmap.width() * 0.125,
+            self.simulation_state.aircraft_pixmap.height() * 0.125,
+            self.simulation_state.aircraft_pixmap.scaled(self.simulation_state.aircraft_pixmap.width() * 0.75,
+            self.simulation_state.aircraft_pixmap.height() * 0.75))
+        painter.end()
+        return pixmap
+
     def draw_aircraft(self, aircraft : AircraftVehicle, scale : float) -> None:
         """Draws given aircraft vehicle"""
         yaw_angle : float = aircraft.yaw_angle
         size : float = aircraft.size * scale
         pixmap : QPixmap
         if not self.simulation_state.aircraft_pixmap.isNull():
             pixmap = self.simulation_state.aircraft_pixmap.scaled(
@@ -272,14 +290,40 @@
         if self.__moving_view_down:
             self.screen_offset_y -= 10.0 / scale
         if self.__moving_view_left:
             self.screen_offset_x += 10.0 / scale
         if self.__moving_view_right:
             self.screen_offset_x -= 10.0 / scale
 
+    def update_steering(self) -> None:
+        """Updates aircraft steering based on current input"""
+        if self.aircrafts[0] and (self.__steering_up or self.__steering_down or self.__steering_left or self.__steering_right):
+            if sum([self.__steering_up, self.__steering_down, self.__steering_left, self.__steering_right]) >= 3:
+                return
+            self.aircraft_fccs[0].ignore_destinations = True
+            target_yaw_angle : float | None = None
+            if self.__steering_up and self.__steering_left:
+                target_yaw_angle = -45.0
+            elif self.__steering_up and self.__steering_right:
+                target_yaw_angle = 45.0
+            elif self.__steering_down and self.__steering_left:
+                target_yaw_angle = -135.0
+            elif self.__steering_down and self.__steering_right:
+                target_yaw_angle = 135.0
+            elif self.__steering_up:
+                target_yaw_angle = 0.0
+            elif self.__steering_down:
+                target_yaw_angle = 180.0
+            elif self.__steering_left:
+                target_yaw_angle = -90.0
+            elif self.__steering_right:
+                target_yaw_angle = 90.0
+            if target_yaw_angle is not None:
+                self.aircraft_fccs[0].target_yaw_angle = target_yaw_angle
+
     def center_offsets(self) -> None:
         """Updates screen offsets centering on selected aircraft"""
         scale : float = self.simulation_state.gui_scale
         id = self.simulation_state.focus_aircraft_id
         self.screen_offset_x = - self.aircraft_vehicles[id].position.x() + self.window_width / 2 / scale
         self.screen_offset_y = - self.aircraft_vehicles[id].position.y() + self.window_height / 2 / scale
 
@@ -291,21 +335,22 @@
     def zoom(self, factor : float) -> None:
         """Zooms in/out the simulation render"""
         if self.simulation_state.gui_scale + factor <= 0:
             return
         old_scale : float = self.simulation_state.gui_scale
         self.simulation_state.gui_scale += factor
         scale : float = self.simulation_state.gui_scale
-        self.screen_offset_x = self.screen_offset_x * old_scale / scale
-        self.screen_offset_y = self.screen_offset_y * old_scale / scale
+        self.screen_offset_x = self.screen_offset_x * (old_scale / scale)
+        self.screen_offset_y = self.screen_offset_y * (old_scale / scale)
 
     def paintEvent(self, event : QPaintEvent) -> None:
         """Qt method painting the aircrafts"""
         self.simulation_fps.count_frame()
         scale : float = self.simulation_state.gui_scale
+        self.update_steering()
         if not self.simulation_state.follow_aircraft:
             self.update_moving_offsets()
         else:
             self.center_offsets()
 
         if self.simulation_state.draw_fps:
             self.draw_text(QVector3D(10, 10, 0), 0, "FPS: " + "{:.2f}".format(self.simulation_state.fps))
@@ -395,14 +440,15 @@
             if event.isAutoRepeat():
                 return super().keyPressEvent(event)
             self.simulation_state.toggle_pause()
         elif event.key() == Qt.Key.Key_R:
             if event.isAutoRepeat():
                 return super().keyPressEvent(event)
             self.simulation_state.reset()
+            self.center_offsets()
         elif event.key() == Qt.Key.Key_Plus:
             self.zoom(0.0625)
         elif event.key() == Qt.Key.Key_Minus:
             self.zoom(-0.0625)
         elif event.key() == Qt.Key.Key_F1:
             self.simulation_state.toggle_adsb_report()
         elif event.key() == Qt.Key.Key_F2:
@@ -425,35 +471,45 @@
             self.__moving_view_right = True
         elif event.key() == Qt.Key.Key_Up:
             self.__moving_view_up = True
         elif event.key() == Qt.Key.Key_Down:
             self.__moving_view_down = True
         if self.aircrafts[0]:
             if event.key() == Qt.Key.Key_A:
-                self.aircraft_fccs[0].target_yaw_angle = -90.0
+                self.__steering_left = True
             elif event.key() == Qt.Key.Key_D:
-                self.aircraft_fccs[0].target_yaw_angle = 90.0
+                self.__steering_right = True
             elif event.key() == Qt.Key.Key_W:
-                self.aircraft_fccs[0].target_yaw_angle = 0.0
+                self.__steering_up = True
             elif event.key() == Qt.Key.Key_S:
-                self.aircraft_fccs[0].target_yaw_angle = 180.0
+                self.__steering_down = True
         return super().keyPressEvent(event)
     
     def keyReleaseEvent(self, event: QKeyEvent) -> None:
         """Qt method controlling keyboard input"""
         if event.key() == Qt.Key.Key_Slash and event.isAutoRepeat() and self.simulation_state.is_paused:
             self.simulation_state.toggle_pause()
         elif event.key() == Qt.Key.Key_Left:
             self.__moving_view_left = False
         elif event.key() == Qt.Key.Key_Right:
             self.__moving_view_right = False
         elif event.key() == Qt.Key.Key_Up:
             self.__moving_view_up = False
         elif event.key() == Qt.Key.Key_Down:
             self.__moving_view_down = False
+        if self.aircrafts[0]:
+            self.aircraft_fccs[0].ignore_destinations = False
+            if event.key() == Qt.Key.Key_A:
+                self.__steering_left = False
+            elif event.key() == Qt.Key.Key_D:
+                self.__steering_right = False
+            elif event.key() == Qt.Key.Key_W:
+                self.__steering_up = False
+            elif event.key() == Qt.Key.Key_S:
+                self.__steering_down = False
         return super().keyReleaseEvent(event)
     
     def resizeEvent(self, event: QPaintEvent) -> None:
         """Qt method controlling window resize event"""
         self.update_resolutions()
         return super().resizeEvent(event)
```

## Comparing `uav_collision_avoidance-0.6.1.dist-info/LICENSE` & `uav_collision_avoidance-0.6.2.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `uav_collision_avoidance-0.6.1.dist-info/METADATA` & `uav_collision_avoidance-0.6.2.dist-info/METADATA`

 * *Files 9% similar despite different names*

```diff
@@ -1,36 +1,41 @@
 Metadata-Version: 2.1
 Name: uav-collision-avoidance
-Version: 0.6.1
+Version: 0.6.2
 Summary: UAV collision avoidance simulation
 Author-email: mldxo <miloszmaculewicz@gmail.com>
 Project-URL: Homepage, https://github.com/mldxo/uav-collision-avoidance
 Project-URL: Issues, https://github.com/mldxo/uav-collision-avoidance/issues
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
 License-File: LICENSE
 
 # UAV Collision Avoidance
 
 Python project regarding implementation of UAV physics and collision detection/avoidance algorithms.
-- [Github repo](https://github.com/mldxo/uav-collision-avoidance)
-- [PyPi project](https://pypi.org/project/uav-collision-avoidance)
+- [Github](https://github.com/mldxo/uav-collision-avoidance)
+- [PyPi](https://pypi.org/project/uav-collision-avoidance)
 
 ## Research work
 
 ### Introduction
 
-UAV Collision Avoidance is my Bachelor's thesis project meeting problem of UAVs safe cooperation in the 3D space. Project implements functional physics calculations, scalable GUI, realistic ADS-B probable collision avoidance systems and on-board flight planning. Application offers realtime simulation presenting moving aircrafts as well as rendered simulation allowing for algorithm effectiveness testing.
+UAV Collision Avoidance is my Bachelor's thesis project meeting problem of UAVs safe cooperation in the 3D space. Project implements functional physics calculations, scalable GUI, realistic ADS-B probable collision avoidance systems and on-board flight planning. Application offers multithreaded realtime simulation presenting simulated aircrafts as well as linearly prerendered simulation allowing for quick algorithm effectiveness testing.
 
 ### Premises
 
-3-dimensional (3D) space defined in XYZ coordinate system, where X and Y describe flat horizontal plane and Z is height above the sea level. Physics is simulated differentiating between parts of the second according to adequate formulas. In scope of this project, UAVs' physics are considered relative to the Earth frame and the aeroplanes are considered HTOL drones (Horizontal Take-off and Landing) that can only move in direction of their speed vectors. Aircrafts' form are approaximated to simple solid sphere. The space is shared by two or three UAVs. There is no other objects or gusts of wind assumpted. No aerodynamic lift force assumed at this moment. The default distance units are meters [m] and speed is meters per second [m/s], frame times are represented in miliseconds [ms].
+1. System Definition: The system is defined as a 3-dimensional (3D) space using an XYZ coordinate system. X and Y represent a flat horizontal plane, while Z represents height above sea level.
+2. Physics Simulation: Physics are simulated by differentiating parts of the second according to appropriate formulas. The physics of Unmanned Aerial Vehicles (UAVs) are considered relative to the Earth's frame, separated from the aircraft's frame and wind relative frame. 3D space is flat, and the Earth's curvature is not considered.
+3. Aircraft Characteristics: The aircraft are considered Horizontal Take-off and Landing (HTOL) drones. They can only move in the direction of their speed vectors. The form of the aircraft is approximated to a simple solid sphere.
+4. Environment: The space is shared by two or three UAVs. There are no other objects or wind gusts assumed in this environment.
+5. Aerodynamics: No aerodynamic lift force is assumed at this moment. When turning, aircraft always take the maximum angle change that physics allow, respecting mass inertia. The angles are not approximated to meet exact courses.
+6. Units of Measurement: The default distance units are meters (m), speed is measured in meters per second (m/s), and frame times are represented in milliseconds (ms).
 
 ### Algorithms
 
 Both collision detection and avoidance algorithms rely on geometrical approach. They were presented in referenced paper[^4]. Collision detection differentiates between collision and head-on collision. The second one applies when UAVs have no distance between their projected center of masses collision, and the first one when it is every other type of contact.
 
 ## Python Project
 
@@ -114,20 +119,23 @@
 ### Remarks
 
 One coding convention is not preserved in the scope of the project. Qt's methods are CamelCase formatted and the rest is default Python naming convention including snake_case for variable and member names.
 
 ## Current Work / TODOs
 
 - [ ] Reimplement safe zone
-- [ ] Symmetrical bank (roll) during turn, no angle approaximation
+- [ ] Head-on collision avoidance
+- [x] Symmetrical bank (roll) during turn, no angle approaximation
 - [ ] Altitude change with symmetrical command
-- [ ] Generating test cases
+- [ ] Generating test cases and batch loading
 - [ ] Test cases comparison
-- [ ] Documentation
+- [ ] Aircraft 0 manual control override
+- [ ] Flight control computer angle optimization
 - [ ] Centered view optimization
+- [ ] Documentation
 
 ## Authors
 
 - [Miosz Maculewicz](https://github.com/mldxo)
 
 ## References
```

## Comparing `uav_collision_avoidance-0.6.1.dist-info/RECORD` & `uav_collision_avoidance-0.6.2.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,22 +1,37 @@
+build/lib/build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=kXX-REh00037lwvz5n2EAci-9f2nYYAAAkypW1lDpJU,2203
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=7y-WaszHOstlbNzr3cAqYNZK4F94-lZqwtFX2M3pRQ8,9540
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=GakasXPXcBn-VBRsF2DxUGB_bQF4ngxRAa2KOdsj7kY,8671
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=xF-IM-ljjJyc2GWSuiwVVcGzlzirrPhEAv3y8qAWobU,6057
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=6yf0nb_AfOsEmyaea5ywDy2q0N1tgfY_fimis4HG3YY,7112
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=lFwovBDK4mmX3Y6B34v--dv-2975e1va6aAtFQ70Ie4,6110
+build/lib/build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=XaPV0vLLQ0PrP1_r9dmJ8BlEkfaQ9dHJROGTjqv4t2Q,23164
 build/lib/build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=kXX-REh00037lwvz5n2EAci-9f2nYYAAAkypW1lDpJU,2203
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=7y-WaszHOstlbNzr3cAqYNZK4F94-lZqwtFX2M3pRQ8,9540
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=XQOQjmXNAaX5aNeD0SPGLSSqU2dBksXdhOR1acALwgY,11332
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=GakasXPXcBn-VBRsF2DxUGB_bQF4ngxRAa2KOdsj7kY,8671
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=xF-IM-ljjJyc2GWSuiwVVcGzlzirrPhEAv3y8qAWobU,6057
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation.py,sha256=E0SjNZiSmjte8UHPu9yebCFPjzg2-mF3Z7U45cd9KU8,9028
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=Av5-ayC8GFdNFXplPsBr3CBhfc_7yoiz3AICrMVdShQ,7108
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=6yf0nb_AfOsEmyaea5ywDy2q0N1tgfY_fimis4HG3YY,7112
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=0HVuLQl4q7-HkJWGd1dJkss-Dg3WXYVJZl3CkEAGvJI,6613
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
 build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=lFwovBDK4mmX3Y6B34v--dv-2975e1va6aAtFQ70Ie4,6110
-build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=XaPV0vLLQ0PrP1_r9dmJ8BlEkfaQ9dHJROGTjqv4t2Q,23164
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=OANRlZ5PlGypf36dXPaXbQTwQ7PLQ1BgnFXyWs0RpXg,6290
+build/lib/build/lib/build/lib/build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=f_Pa-mno9bDVRga2LhTAcoQ3jtVRLjuJlMVEFW5cnq4,23168
 build/lib/build/lib/build/lib/tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 build/lib/build/lib/build/lib/uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
 build/lib/build/lib/build/lib/uav_collision_avoidance/main.py,sha256=kXX-REh00037lwvz5n2EAci-9f2nYYAAAkypW1lDpJU,2203
 build/lib/build/lib/build/lib/uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=XQOQjmXNAaX5aNeD0SPGLSSqU2dBksXdhOR1acALwgY,11332
 build/lib/build/lib/build/lib/uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
@@ -59,23 +74,23 @@
 build/lib/uav_collision_avoidance/src/simulation/simulation_state.py,sha256=OANRlZ5PlGypf36dXPaXbQTwQ7PLQ1BgnFXyWs0RpXg,6290
 build/lib/uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=f_Pa-mno9bDVRga2LhTAcoQ3jtVRLjuJlMVEFW5cnq4,23168
 tests/test_sample.py,sha256=iSdvIjN0pJhhnnrvTowieDMMnjU1HcZycfH0PK5lhEo,107
 uav_collision_avoidance/__init__.py,sha256=fE4gQOSVcsNLjTsO_Efa39pHqkC6Fjj6nCMGp0twYDw,121
 uav_collision_avoidance/main.py,sha256=kXX-REh00037lwvz5n2EAci-9f2nYYAAAkypW1lDpJU,2203
 uav_collision_avoidance/version.py,sha256=I6WvYCjHdTuOXOG8owwghajl8vOW_aevumGXnBl_sPk,238
 uav_collision_avoidance/src/aircraft/aircraft.py,sha256=HbmkQi8lHpJHZL8KBCa3DTzw2q3ybdg7OTHz0eCXJAY,1662
-uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=XQOQjmXNAaX5aNeD0SPGLSSqU2dBksXdhOR1acALwgY,11332
+uav_collision_avoidance/src/aircraft/aircraft_fcc.py,sha256=tTvb9t_vO-ZwMivy5p1M66zx70oEigyd0sVsZQlgeu8,13017
 uav_collision_avoidance/src/aircraft/aircraft_vehicle.py,sha256=Hdc1sQujBzdVMM5q5TsVDyJCyIxm7xi8S5FXD9WHJ8g,4195
-uav_collision_avoidance/src/simulation/simulation.py,sha256=E0SjNZiSmjte8UHPu9yebCFPjzg2-mF3Z7U45cd9KU8,9028
-uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=Av5-ayC8GFdNFXplPsBr3CBhfc_7yoiz3AICrMVdShQ,7108
+uav_collision_avoidance/src/simulation/simulation.py,sha256=PWU65G5kARp5A3saSLI01ieAe2JWgnY0ObmHTrfcF-Y,9630
+uav_collision_avoidance/src/simulation/simulation_adsb.py,sha256=xsWQk4Z8GJWhvFC9LIoTznzYBHR88MwsJH50l96mbyE,7072
 uav_collision_avoidance/src/simulation/simulation_fps.py,sha256=fBVukWmBt1md9Klep9J7_WqpzRIDWYHpdo4o8UZyvk0,1979
 uav_collision_avoidance/src/simulation/simulation_physics.py,sha256=0HVuLQl4q7-HkJWGd1dJkss-Dg3WXYVJZl3CkEAGvJI,6613
 uav_collision_avoidance/src/simulation/simulation_render.py,sha256=_Mb1k6Y1mRHtejgWByU-MmAIx4cSmwVBtaBqao0nrLk,1041
 uav_collision_avoidance/src/simulation/simulation_settings.py,sha256=gL0BI6DecE8MYBNex8-KMgNVqpUWuFoOo65chOypXi0,682
 uav_collision_avoidance/src/simulation/simulation_state.py,sha256=OANRlZ5PlGypf36dXPaXbQTwQ7PLQ1BgnFXyWs0RpXg,6290
-uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=f_Pa-mno9bDVRga2LhTAcoQ3jtVRLjuJlMVEFW5cnq4,23168
-uav_collision_avoidance-0.6.1.dist-info/LICENSE,sha256=VCiagDkTdM8_xItFjcyMl-mMsGbzL1CQEXpynU0QLxY,1075
-uav_collision_avoidance-0.6.1.dist-info/METADATA,sha256=YxkJXe-H4aIeVcgGcaYV0oxZOt-c-pwo4fzEARgX9a4,6409
-uav_collision_avoidance-0.6.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-uav_collision_avoidance-0.6.1.dist-info/entry_points.txt,sha256=fcy0NnMoUjf7wZty5G169lvrCzHpWtJXyQuYsEGyg3k,73
-uav_collision_avoidance-0.6.1.dist-info/top_level.txt,sha256=miPZH4d_mAR-Tj76v8c0YFs_CNl1TTT4Yf7zwcPSuwY,58
-uav_collision_avoidance-0.6.1.dist-info/RECORD,,
+uav_collision_avoidance/src/simulation/simulation_widget.py,sha256=EkTPWUgSrPVfz19RQJAaT09kqYyrkES8P15xLEayVwQ,25822
+uav_collision_avoidance-0.6.2.dist-info/LICENSE,sha256=VCiagDkTdM8_xItFjcyMl-mMsGbzL1CQEXpynU0QLxY,1075
+uav_collision_avoidance-0.6.2.dist-info/METADATA,sha256=FMHwaO_D91RequECMXUAsoNDgeaqzVJDAx8ZWqolrUY,7068
+uav_collision_avoidance-0.6.2.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+uav_collision_avoidance-0.6.2.dist-info/entry_points.txt,sha256=fcy0NnMoUjf7wZty5G169lvrCzHpWtJXyQuYsEGyg3k,73
+uav_collision_avoidance-0.6.2.dist-info/top_level.txt,sha256=miPZH4d_mAR-Tj76v8c0YFs_CNl1TTT4Yf7zwcPSuwY,58
+uav_collision_avoidance-0.6.2.dist-info/RECORD,,
```

